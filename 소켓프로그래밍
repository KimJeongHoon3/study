전제 : c언어, 리눅스


chapter02 - 소켓의 타입과 프로토콜의 설정

-프로토콜 : 데이터 송수신을 위한 약속!
-소켓생성시 3가지 파라미터를 넘겨줌 int socket(int domain, int type, int protocol)
	1번 파라미터) 소켓이 사용할 프로토콜 체계(protocol family) 정보전달
		-프로토콜의 상위개념(상위카테고리)으로 프로토콜 체계안에서 여러 프로토콜이 정의됨..
		-IPv6 인터넷 프로토콜체계, IPv4인터넷 프로토콜체계, 로컬통신을 위한 Unix프로토콜 체계, Low level소켓을 위한 프로토콜체계, IPX 노벨 프로토콜 체계 등
	2번 파라미터) 소켓타입 : 소켓의 데이터 전송방식을 의미
		-프로토콜체계안에 둘 이상의 데이터 전송방식을 지닌다..
		-IPv4인터넷 프로토콜체계의 데이터전송방식
			-연결지향형소켓 : 데이터를 잃지않는다.. 순서를 보장한다.. 데이터 송수신시 데이터 경계가없다..
				=> 신뢰성있는 순차적인 바이트 기반의 연결지향 데이터 전송방식의 소켓
				=> TCP 프로토콜로 연결되며 최종적으로 TCP 소켓이 생성(즉, 이후 3번째 파라미터는 1,2번 파라미터가 이렇게 정해져있다면 한개밖에없음)
			-비연결지향형소켓 : 데이터를 잃을수있다.. 순서 보장안한다.. 데이터 전달하는데 제한이있다..(아무래도 빨리 전달하는것이 목적이므로) 한번 write하면 해당 내용을 연결되거나 합쳐지지않고 그대로 read됨(데이터 송수신에 경계가있음!)
				=> 신뢰성과 순차적 데이터 전송을 보장하지않는, 고속의 데이터 전송을 목적으로 하는 소켓
				=> UDP 프로토콜로 연결되며 최종적으로 UDP 소켓이 생성(즉, 이후 3번째 파라미터는 1,2번 파라미터가 이렇게 정해져있다면 한개밖에없음)
	3번 파라미터) 프로토콜 : 최종적으로 소켓이 사용하게될 프로토콜을 정의..
	
chapter03 - 주소체계와 데이터 정렬


-port : 컴퓨터의 프로그램상에서 소켓을 구분하기위해 사용(16비트)
	-서버에서 반드시 하나만 사용이됨
	-TCP랑 UDP는 구분되어있음.. 즉, TCP에서 9000포트사용해도 UDP에 9000포트 사용가능
-인터넷 주소
	-IPv4 : 4바이트 주소체계.. 
		-네트워크주소 + 호스트주소
			-클래스A : 1byte의 네트워크ID + 3byte의 hostID (첫번재 비트가 항상 0으로 시작)
			-클래스B : 2byte의 네트워크ID + 2byte의 hostID (첫번째 비트가 10으로 시작)
			-클래스C : 3byte의 네트워크ID + 1byte의 hostID (첫번째 비트가 110으로 시작)
			-클래스D : 4바이트의 멀티캐스트 IP주소
			-클래스E : 예약되어있는 주소체계
			=> 네트워크ID를 먼저찾고(라우터), 라우터에서 hostID를 찾아줌.. 즉, 그냥 우리가 생각하는IP는 네트워크ID+hostID임
			*라우터는 외부로부터 데이터를 송수신하기위한 물리적장치.. 스위치랑 기능이 비슷한데 스위치는 라우터보다 제공하는 기능이 더 적은것뿐..
			
	-IPv6 : 16바이트 주소체계.. IPv4가 부족할까봐..
-CPU가 데이터를 메모리에 저장하는방식
	-빅 엔디안 : 작은 번지부터 큰 번지로 데이터를 순차적으로 저장
		-네트워크 바이트 순서로 지정
	-리틀 엔디안 : 큰 번지부터 작은번지로 데이터를 저장
		-AMD,인텔 CPU를 사용하면 리틀엔디안!
	*호스트 바이트 순서 : CPU의 데이터 저장방식을 의미
	*네트워크 바이트 순서 : 데이터를 전송할때 통일된 기준으로 데이터를 전송하기로 약속한것
	=> 빅 엔디안을 기본으로 사용한다면 굳이 순서를 변경할 필요가 없겠지만, 리틀 엔디안이라면 네트워크바이트순서인 빅 엔디안으로 정렬방식을 변경해주어야함..
	

chapter04 - TCP 기반 서버/클라이언트 1

OSI 7계층 / 인터넷계층(4계층)

(오른쪽으로 갈수록 하위 계층..)
Application계층 -> TCP/UDP계층(Transport계층) -> IP계층 -> Link 계층

이런계층이 생긴이유? : 인터넷을 토한 효율적인 데이터의 송수신을 위해서는 표준이 필요했다..! 그래서 개방형시스템(Open System)을 설계하여 표준화하였고, 이로인해 교체나 유지보수가 용이하다! 발전도 더 잘되고!

-Link 계층 : 데이터를 보내기 위한 물리적계층
-IP계층 : 데이터를 보내기위한 경로를 셋팅(Internet Protocol)
	-IP 자체는 비 연결지향적, 신뢰할수없는 프로토콜임..
-TCP/UDP 계층(Transport계층) : 데이터의 실제 송수신담당 계층,, 신뢰성, 비신뢰성을 결정
	-TCP: 신뢰성없는 IP에 신뢰성을 보장,, 여러 패킷이 들어오는것을 하나씩 확인해서 못받으면 재요청
	-UDP:
-Application 계층 : 사용자가 application사용을 위한 cli <-> server간의 약속을 정의해놓은 계층(이전 계층의 작업은 소켓이 알아서 책이져줌..ㅎ)

-server socket
	-socket -> bind -> listen ->  accept -> read/write
	-서버 소켓(client를 받는 문지기)을 통해서 accept(연결) 되면 해당주소를 가진 socket을 내부적으로 만들어주고, 이를 통해서 데이터를 송수신한다..
-client socket
	-socket -> connect -> read/write
	-소켓을 생성할때는 바드시 IP와 Port가 필요한데(어느놈한테 보내야할지를 알아야하니깐..) client소켓에는 별도로 지정하는 부분이 없다.. 이는 커널에서 알아서 ip와 port를 바인딩 해주기때문이다!!!
	
chapter05 - TCP 기반 서버/클라이언트 2
-TCP의 이론적인 이야기
	-입출력버퍼
		-write시 출력버퍼에 저장되고, read시 입력버퍼에 저장된것을 읽어온다.. 즉, 데이터 송수신시 출력버퍼에 있는 데이터를 상대방의 입력버퍼로, 상대방의 출력버퍼에있는것을 나의 입력버퍼로 전달되는것이다!
			-30바이트를 보냈는데, 10바이트씩 받았다면 처음 10바이트 받았을때 나머지 20바이트는 입력버퍼에 저장되어있음!
			-그래서 java에서는 write하고 flush를 해줘야 출력버퍼에있는 데이터가 넘어간다..
		-입출력 버퍼는 TCP 소켓 각각에 대해 별도로 존재..
		-입출력 버퍼는 소켓 생성시 자동 생성
		-소켓을 닫아도 출력버퍼는 남아있는데이터 다 보냄..
		-소켓 닫으면 입력버퍼 데이터 날아감
		-TCP에는 '슬라이딩 윈도우' 라는 프로토콜이 있어서 이를 통해서 내 입력버퍼가 얼마나 받을수있는지를 상대방과 지속되는 통신을 통해 전달하므로 버퍼에 차고넘치는 데이터를 받아서 없어지는 경우가 없다!
	-상대 소켓과의 연결시 이뤄지는 동작
		-three way handshaking : 3단계의 과정으로 이루어짐
			1) sync ( A -> B )  ex. SEQ:1000, ACK: -    => A가 B에게 자신의 SEQ를 SYNC하도록함 (ACK로 1001보내달라는것)
			2) sync + ack ( A <- B )  ex. SEQ:2000, ACK:1001   => B는 A에게 동기화되었다는 응답으로 1001을 보내고, 나도 동기화해달라고 SEQ에 2000을 보냄
			3) ack ( A -> B ) 		  ex. SEQ:1001, ACK:2001   => A는 B에게 동기화되었다는 응답으로 2001을 보냄.. SEQ는 1001을 보내는데, 이는 앞서 보낸 1000보다 1증가한것.. (메세지 하나 새로 보낼때마다 적어도 하나씩은 증가하는듯)
	-상대 소켓과의 데이터 송수신시 이뤄지는 동작
		-ACK번호 -> SEQ번호+전송된바이트크기+1
			ex) A -> B - SEQ:1200, 100 byte data
			 A <- B - ACK:1301
			 A -> B - SEQ:1301, 100 byte data
			 A <- B - ACK:1402
			 
			 (ACK가 다음 보낼 SEQ를 보냄으로써 온전히 데이터를 신뢰성있게 잘 받았는지 확인해주는듯함)
			 
		-만일 ACK가 일정시간안에 없으면 timeout이 발생하고 다시 재요청을 진행한다
	-상대 소켓과의 연결종료시 이뤄지는 동작
		-상호간의 FIN메세지를 주고받고 종료가됨
		-four way handshaking : 4단계의 과정으로 이루어짐
			ex) A -> B : FIN - SEQ 5000, ACK -
				A <- B : ACK - SEQ 7500, ACK 5001
				A <- B : FIN - SEQ 7501, ACK 5001 (B가 응답한뒤에 FIN 메세지또한 보낸다)
				A -> B : ACK - SEQ 5001, ACK 7502
				
chapter06 - UDP 기반 서버/클라이언트
-UDP특성
	-흐름제어x => 신뢰성 떨어짐 ,, 그러나 생각만큼 데이터 손실 많지않음
		-흐름제어를 별도로 하지않는다는것은 데이터 송신하고 더이상 신경안쓴다는것... SEQ나 이런것도 신경안씀..
	-데이터의 경계가 있음
	-일반적으로 TCP보다 속도가 빠르나, TCP또한 송수신하는 데이터의 양이 크면 클수록 속도가 UDP 못지않다
	-편지와같음!
		-우체통하나로 편지를 보내기도하고 편지를 받기도함.. 편지를 보낼때 수신자가 완전히 받았는지는 확인이안됨..
-UDP동작의 원리
	-IP로 위치를 파악했다면 해당 UDP 소켓으로 전송하기위해서 해당 Port로 연결시켜주는것은 UDP의 역할이다.. 
-UDP의 효율적 사용
	-데이터 양이 적고 잦은 연결이 필요하다면 사용하는것이좋음
		-잦은연결시 TCP사용하게되면, 많은 비용이발생(연결,해제시의 흐름제어..)
	-압축파일과같은 하나라도 손실되어서는 안되는것이 아닌, 스트리밍같은것은 좋음
-UDP에서는 서버건 클라이언트건 하나의 소켓만 있으면된다!
-UDP소켓은 연결상태를 유지하지않는다
	-데이터를 전송할때 목적지 주소를 항상같이 넘겨줌.. 
-UDP소켓을 열때 포트번호를 bind하지않으면, 데이터를 보낼때(sendto함수 호출시) 사용하지않는 port를 알아서 할당해줌..
-UDP는 데이터 경계가 있기때문에 sendto한 횟수와 recvFrom 한 횟수와 동일해야함.. 
-unconnected udp소켓
	-sendto 함수 호출시 아래와 같은 순서로 동작
		-1단계 : UDP 소켓에 목적지의 IP와 PORT번호 등록
		-2단계 : 데이터 전송 
		-3단계 : UDP 소켓에 등록된 목적지 정보 삭제
-connected udp소켓
	-목적지에 대한 정보를 등록(connect함수)
		-여기서 connect는 연결설정과정을 거치는것이아니라, 그냥 목적지의 IP와 PORT가 등록되는것일뿐!
	-sendto 함수나 recvFrom을 사용하지않고 write와 read함수를 사용(목적지를 등록해놨기때문에 계속 파라미터로 주소 안넘겨도되니깐)
	-unconnected의 1,3단계를 pass,, 1/3정도 속도 증가!

chapter07 - 소켓의 우아한 연결종료
-소켓이 연결되면 두개의 스트림(일방적으로 흐르는 흐름)이 생기게된다. 입력버퍼에 데이터를 전달받는 스트림, 출력버퍼의 데이터를 전달하는 스트림
-half-close
	-두개의 스트림을 모두 끊는것이아닌 하나만(절반만) 끊는것
	-소켓을 그냥 close하게되면 두개의 스트림이 바로 끊어지게된다.. 그래서 우아한종료를 위해 half-close가 필요!
	
chapter08 - 도메인 이름과 인터넷 주소
-IP주소와 도메인 이름 사이에서의 변환을 수행하는 시스템이 DNS(Domain name system)이다.
-모든 컴퓨터에는 디폴트 DNS 서버의 주소가 등록되어있고, 도메인으로 요청하면 디폴트 DNS서버가 IP주소를 찾아서 연결해줌!
	-만약 디폴트 DNS서버에 IP를 찾을수없다면 상위의 DNS Server로 계속 올라가면서 IP주소를 찾는다! 즉, DNS는 계층적으로 관리되는 일종의 분산 데이터베이스 시스템이다
-하나의 DNS에는 여러개의 IP주소가 있을수 있다.. 이는 서버분산을 위해서 사용된다!



chapter 09 소켓의 다양한 옵션
    -소켓 타입(TCP or UDP)은 한번 지정하면 바꿀수없다!
    -운영체제가 핸들링하는 입출력 버퍼는 사용자가 요청한 값대로 정확히 변경안될수있다!! 입출력버퍼는 상당히 중요한 영역이기 때문에 내부적으로 알아서 처리해주는 부분이 있다! 우리가 요청하는것은 요구사항을 전달하는것이고 이를 반영하여 내부적으로 처리한다 보면됨!!
    -REUSEADDR
        -서버가 문제가 생겨서 갑작스레 종료되었을때 TIME-WAIT 상태가되면 포트가 이미 점유되어있기때문에 재실행이 불가능! 이를 해결하기위한 옵션이다!(재사용하겠따!)
            -클라이언트쪽에는 문제가안되는게,, 포트를 지정해서 연결하지않기때문!
        *TIME-WAIT : 소켓 종료시 four-way-handshake를 거치게 되는데, 먼저 종료를 실행한 쪽에 TIME-WAIT이 생긴다. 왜냐하면 상대방의 FIN메세지에 응답하기 위해서이다..! 만약 상대방의 FIN메세지를 받지 못해서 응답을 못했을때 상대방은 다시 FIN을 보낼것이다.. 그러면서 계속 ACK를 하염없이 기다릴것이다. 이를 막기위해서 일정시간 기다림을(time wait) 통해서 마지막 ACK를 해주기위함이다
        
        참고사이트 : TCP의 TIME_WAIT를 없애는 법 - https://sunyzero.tistory.com/m/198

        -참고로 리눅스에서 net.ipv4.tcp_timestamps가 켜져있어야 REUSEADDR 옵션이 먹힘..
    -TCP_NODELAY
        -Nagle 알고리즘 : ACK메세지 받아야 다음데이터 보낸느것
            -이를 사용하지않으면, 출력버퍼에서 들어오자마자 바로바로 보내기 떄문에 이에 따르는 헤더의 비용(수십바이트)이 발생함,, 그로인해 트래픽에 대한 부하가 있다
            -용량이 큰 파일의 데이터 전송에 있어서는 출력버퍼를 빠르게 채워서 한꺼번에 전송하기 때문에 알고리즘 적용안하는게 유리!!


chapter 10 멀티프로세스 기반의 서버구현
    -멀티프로세스 기반 : 다수의 프로세스를 생성하는 방식으로 서비스제공
    -멀티 플렉싱 기반 : 입출력 대상을 묶어서 관리하는 방식으로 서비스제공
    -멀티 쓰레딩 기반 : 클라이언트의 수만큼 스레드를 생성하는 방식으로 서비스제공

    -프로세스 : 메모리 공간을 차지한 상태에서 실행중인 프로그램
        -하나의 프로그램 실행에 여러 프로세스가 생성되기도함. 

chapter 11 프로세스간 통신(Inter Process Communication)
    -운영체제가 제공해주는 "파이프"라는것을 통해서 통신가능

chapter 12 IO 멀티플렉싱
    -다중 클라이언트 접속시 멀티 프로세스방법으로 IPC가 필요한 상황을 해결하기위해 대안으로 사용..
    -하나의 프로세스를 가지고 여러 클라이언트와 데이터 송수신 가능!
    -멀티플렉싱 서버는 클라이언트 소켓이 이벤트발생하면 처리하는방식..
    -select
        -감시해야할 파일디스크립터(소켓)를 select 함수를 통하여 등록하여(Os에 등록하는거겠지..?) 소켓에 이벤트가 발생하면 디스크립터를 하나하나씩 확인해나가면서 이벤트 발생한것을 찾아서 처리한다.. (read이벤트, write이벤트, error이벤트,, 이렇게 3가지 등록가능)
        -이벤트발생하면 바로 어떤 소켓이 무슨 이벤트 변화가 나타났는지 알아차리는것이아니라 다 일일이 루프를 돌면서 찾아서 일한다.. 그러니깐 당연히 성능떨어지겟지..
            => 이에 대한 해결책은 추후 다시 나오니 그때 발견하면 정리하자..
            

chapter 13 다양한 입출력 함수들
    -데이터를 읽을때 버퍼에 메세지를 그대로 남겨둘수도있고(MSG_PEEK 옵션), 이에 더해 데이터가 없을떄 블럭되지않도록(MSG_DONTWAIT 옵션) 을 같이 사용한다
    -출력버퍼에 데이터를 쓸때나 입력버퍼에서 데이터를 읽을때 어느정도 채워서 보낼수도있다.. 이렇게 데이터를 모아서 쓴다면 nagle 알고리즘을 사용하지 않는것이 유리!!
    *offset : 기본이 되는 위치를 바탕으로 상대적 위치를 표현하는 것이 오프셋..

chapter 14 멀티캐스트 & 브로드캐스트
    -멀티 캐스트
        -UDP 기반
        -멀티캐스트 그룹을 대상으로 데이터를 전송하면 멀티캐스트 그룹에 속한 대상은 다 받게됨
        -멀티캐스트 그룹의 수는 IP주소 범위 내에서 얼마든지 추가가능
        -멀티캐스트 그룹은 클래스D에 속하는 IP주소(224.0.0.0~239.255.255.255)
        -하나의 데이터를 라우터가 복사해서 멀티캐스트 그룹에 속해잇는 클라에게 뿌려줌
        -기존에 클라이언트에게 1:1로 전달해주는것보단 특정 라우터 그룹에 속해잇는 클라에게 전송하는것이 트래픽 측면에서 확실히 장점은 잇으나, 라우터가 멀티캐스트 그룹에 속해잇는 클라만큼 복사를 하기때문에 트래픽상에서 부담이 있는것은 사실..! 그래서 의도적으로 라우터에 멀티캐스트 안되게 막아놓기도한다함..
        -TTL 이라는것을 설정해주어야함
            *TTL(Time to live) : 패킷을 얼마나 멀리 전달할것인지를 설정하는것으로, 라우터를 거칠때마다 1씩 감소한다.. 끙까.. 만약 멀리 보내야한다면 TTL의 숫자가 커야겟지만 너무 커지면 트래픽에 좋지못한 영향을 줄수있다...
    -브로드 캐스트
        -UDP 기반
        -서로 다른 네트워크 상이라도해도 멀티캐슽느 그룹에 가입만 되어잇으면 데이터 송수신이 가능한 멀티캐스트와 달리, 브로드 캐스트는 동일한 네트워크로 연결되어있는 호스트로만 전송할수있음..(한마디로 같은 네트워크 상에 있는 놈들한테만 보낼수있다!)
        -direct 브로드캐스트 : 특정 네트워크에 브로드캐스트 x.x.x.255
        -local 브로드캐스트 : 내가 속한 네트워크에 브로드캐스트 255.255.255.255
    
****** 리눅스 기반 프로그래밍 ******
chapter 15 소켓과 표준입출력
    -표준입출력 함수 : C에서 제공해주는, 모든 운영체제에서 지원하는 함수 (표준입출력함수를 통해서 OS영역에 속하는 입출력 소켓 버퍼에 direct로 접근x => 입출력소켓버퍼에 다이렉트로 접근하는것은 시스템함수를 사용!)
        -이식성이 좋음
        -버퍼링을 통한 성능향상에 도움이됨
            - 서버 <=> 입출력함수 버퍼 <=> 소켓버퍼 <=> 클라
                -입출력함수버퍼는 "성능향상"을 목적
                    -어떻게 성능향상? => 이는 지속적으로 한 바이트씩 쪼개서 보내는것보다 한꺼번에 보내는것이 속도와 트래픽측면에서 훨씬이득! 동일한 양의 데이터를 10번왓다갓다리하는것보다 한번이 당연 낫겟지!
                -소켓버퍼는 "TCP사용"을 목적

chapter 16 입출력 스트림의 분리에 대한 나머지 이야기

chapter 17 select 보다 나은 epoll
    -전통적인 IO 멀티플렉싱 방법으로 select가 있으나, 성능적인 아쉬움으로 리눅스 epoll, BSD의 kqueue, 솔라리스의 /dev/poll, 윈도우의 IOCP 가 대안이되었다!
    -기존 select 같은경우는 select함수호출할때마다 운영체제에 관찰대상을 전달해주어야했다.. 이것이 성능에 큰 영향을 미쳤다.. 이를 해결하기위해서 epoll을 도입!
    -epoll은 운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려주고 관찰대상의 범위, 또는 내용 변경이 있을때 변경사항만 알려준다!
        -이로인해 전체 파일 디스크립터를 대상으로 어떤놈이 변경이 일어났는지 루프돌면서 확인하는 작업 필요업슴
        -관찰대상의 정보를 매번 보낼필요도없음!
    -이벤트 발생시점에 따른 방식
        -레벨트리거 : 입력버퍼에 데이터 남아있으면 계속 이벤트 발생
        -엣지트리거 : 입력버퍼에 데이터 남아있어도 딱 한번만 이벤트 발생
            -소켓nonblocking & errno전역변수셋팅 필요!!
            -이벤트가 한번발생하기때문에 이벤트발생했으면 데이터를 다 읽을때까지 read함수를 계속 호출해줘야한다..
            -그리고 read함수 호출했을때 block이되면 더이상 진행안되므로 nonblock으로 되어야하고
            -errno가 eagain이면 더이상 읽을 데이터가 없다는것이기때문에 read하는 루프에서 빠져나와 다시 epoll_wait 호출하러 가야한다
        => 엣지트리거가 데이터의 수신과 데이터가 처리되는 시점을 분리하기에 좋다! 그리고 성능상에서도 소켓에 데이터 남아있다해서 이벤트를 계속 받는것이아니라 한번만 받고 루프에서 처리하기때문에 속도도 좀더 빠를수있다..(항상그렇진않을수있다.. 데이터 양에따라..?)
            -이벤트를 읽어드리고 처리하는데 상당한 유연성이 있다.. 데이터가 들어와서 epollin에 대한 이벤트를 받았을때 아직 처리하지않아야한다면 해당 이벤트를 다시 호출하도록 하거나(이런거 가능하겠지?) 하면되는데, 레벨트리거로한다면 해당 이벤트를 계속 미루고 처리하는데에있어서 처리할 소켓의 데이터가 남아있으면 계속 발생하므로 너무너무나 복잡하다.. 

chapter 18 멀티스레드 기반의 서버구현
    -프로세스 : 운영체제 관점에서 별도의 실행흐름을 구성하는 단위
    -스레드 : 프로세스 관점에서 별도의 실행흐름을 구성하는 단위
        -join 함수 : 스레드 종료시 까지 기다리도록함(block 되어있음)
        -임계영역에 대한 처리가 필요 
            *임계영역 : 둘 이상의 스레드가 접근하면 문제가 일어날수잇는 영역
            => 스레드 안전에 유의하라!
            => CPU에서 정의한 처리가 아주 이상적으 다 끝나기 전에 다른 스레드가 실행될수있음,, 그렇기때문에 공유되는 영역에서 예상한 결과값이 안나올수있음..
            => 동기화!
        -동기화
            -동기화가 필요한 상황
                -동일한 메모리 영역으로서의 동시접근이 발생하는 상황
                -동일한 메모리 영역에 접근하는 쓰레드의 실행순서를 지정해야하는 상황
            -동기화기법
                -뮤텍스 : lock을 호출하였을때 이미 lock이 되어있다면 unlock이 될때까지 기다렸다가 unlock이 호출되면 실행
                -세마포어 : 0과 1을 왓다갓다함.. 0이면 block, 1이면 진행


    -멀티 프로세스의 문제점을 해결하기 위해서 멀티스레드 사용

        -멀티 프로세스의 문제점
            -프로세스 생성이라는 부담스러운 작업과정
            -두 프로세스 사이에서의 데이터 교환을 위해서는 별도의 IPC 기법을 적용해야함
            -초당 적게는 수십번에서 많게는 수천번까지 일어나는 '컨텍스트 스위칭' (이게 젤 문제)
            *컨텍스트 스위칭 : 메인메모리에서 프로세스를 바꾸는것!(자세한것은 "multiProcess_multiThread_contextSwitchin" 참고)
            -데이터 영역, 힙 영역, 스택영역이 모두 복사가된다.. 컨텍스트스위칭때 그만큼 비용이 많이듬..
        -멀티 스레드의 장점
            -스레드의 생성 및 컨텍스트 스위칭은 프로세스의 생성 및 컨텍스트 스위칭보다 빠르다
            -스레드 사이에서의 데이터 교환에는 특별한 기법이 필요없다
            -데이터 영역, 힙영역은 공유하고 스택영역만 생성하므로 컨텍스트 스위칭시 데이터 영역과 힙영역 올릴필요없음
            -공유 하는 데이터영역과 힙영역을 사용하여 데이터를 교환 가능
        

****** 윈도우 기반 프로그래밍 ******

chapter 19 windows에서의 쓰레드 사용 
    -커널 오브젝트 : 프로세스, 스레드, 파일, 세마포어, 뮤텍스 등등 운영체제가 만드는것들(프로그래머의 호출에 의해)은 운영체제의 관리를 목적으로 정보를 기록하기 위해 내부적으로 데이터 블럭을 생허나는데, 이것이 커널 오브젝트! 운영체제가 소유함!! 유형에 따라 커널 오브젝트가 다르다!
        -소유가 운영체제라는것은 생성,관리, 소멸시점 모두가 운영체제 몫이라는것!
        -커널 오브젝트를 구분하는 Handle이 있다.(handle은 정수형태)
        -커널 오브젝트는 리소스의 성격에 따라 많은 정보가 담기는데, 그중에 "상태"라는것이 중요하다
            -종료된 상태를 가리켜 signaled 상태 ,, 이벤트가 발생했을때를 이야기하기도함
            -종료되지않은 상태를 가리켜 non-signaled 상태 ,, 처음 생성되어 초기상태라 이야기하기도함
            => 커널 오브젝트가 어떤 상태인지를 물어서 signaled상태가 된것을 자동으로 nonsignaled 상태로 전환(auto-reset모드라함) 하기도하고 반대로 수동으로 non-signaled 상태로 전환하기도함(manual-reset모드) 

chapter 20 windows에서의 쓰레드 동기화
    -윈도우 운영체제의 연산방식(프로그램 실행방식)을 가리켜 이중모드 연산방식이라함.. 왜냐하면 윈도우에는 두가지 모드가 존재하기때문
        -유저모드 : 응용프로그램이 실행되는 기본모드,, 물리적인 영역으로의 접근이 허용되지않으며, 접근할 수 있는 메모리 영역에도 제한이 따름 => 응용프로그램의 실행모드
        -커널모드 : 운영체제가 실행될 떄의 모드로, 메모리뿐만 아니라, 하드웨어의 접근에도 제한이 따르지않는다.. => 운영체제의 실행모드
        -유저모드와 커널모드를 오가며 실행하게된다! 예를들어 스레드의 생성요청은 프로그램상의 함수(유저모드)에서 실행되지만, 실제로 스레드를 생성하는것은 운영체제이다(커널모드)
            -왜이리 두가지로정의?
                => 안정성을위해! 커널모드에서 작용하는것은 유저모드에서 다 가능하게 되엇을때 실수로 잘못건들면 운영체제에 심각한 문제가 생길수있기때문에!!
            -이렇게 모드가 변환되는것을 모드 스위칭이라함!
                -컨텍스트 스위칭을 하기위해서는 모드 스위칭이 반드시 수반된다! 왜냐면 컨텍스트 스위칭하는곳이 커널쪽에서 진행하기때문이다! 

                참고 : https://daehee87.tistory.com/473
    
    -유저모드 동기화 : 운영체제의 도움없이 응용프로그램상에서 진행되기때문에 속도가 빠르다.. but 기능은제한적..
        -CRITICAL_SECTION 오브젝트라는것을 생성해서 동기화(mutex랑 사용방법동일)
    -커널모드 동기화 : 제공하는 기능이 겁나많음! 서로 다른 프로세스에 포함되어있는 두 쓰레드간의 동기화도 가능! but 커널모드에서 다시 유저모드로의 빈번한 변환이 불가피..
        -Event(manual-reset,auto-reset 선택가능), 세마포어(autu-reset), 뮤텍스(auto-reset)

chapter 21 Aysnchronous Notification IO 모델
    -동기 : 함수 콜하고 콜한 목적에 맞추어 Return 값을 받을때까지 한없이 기다림
    -비동기 : 함수콜하고 바로 Return, 완료되엇는지는 완료되었을때 알수있음.. 비동기는 block되지않으니 cpu를 효율적으로 사용가능
    -대표적인 synchronous notification io는 select 이다 (IO의 상태변화알리는것!)
        -select은 관찰대상의 상태변화가 있으면(ex.데이터수신) 움직인다!(그렇지 않으면 block!)
        -asynchronous notification io는 그니깐 관찰대상을 OS에게 지정한뒤에, 내 할일하다가 관찰대상의 상태변화가 잇었는지 확인하는 방식이다! 그래서 함수도 나눠줘있다!(관찰대상지정 / 관찰대상상태확인)
    -WSAEventSelect
        -운영체제에 소켓정보가 등록되기때문에 기존 select과 다르게 함수의 재호출필요없음
        -소켓과 eventobject를 연결하여(이게 운영체제에 등록되는것) eventObject가 어떤 상태가되었는지를 확인하면서 로직을처리!


chapter 22 Overlapped IO 모델
    -해당 챕터는 비동기 notification이 아닌, IO를 비동기로 처리하는것!
    -하나의 스레드 내에서 동시에 둘 이상의 영역으로 데이터를 전송(또는 수신)함으로 인해서, 입출력이 중첩되는 상황을 가리켜 IO 중첩이라한다!
    -이에 대한 핵심은 비동기IO! =>호출되는 입출력 함수는 non-blocking이어야함!
    -overlapped IO == 비동기 IO
        -비동기 IO + 입출력 완료의 확인(callbackt사용)까지!

chapter 23 IOCP(Input Output Completion Port) 
    => IOCP는 서버소켓이 클라를 받는것과, 받은 클라들의 IO결과들을 가지고 처리하는 로직을 분리할수 있다.. 그리고 모든 구간이 비동기로 이루어지기때문에 지체구간이없어서 상당히 빠른 속도를 보일수있다!
    1) CP(Completion Port) 오브젝트 생성 (해당 소켓을 기반으로 진행되는 IO의 완료상황을 등록해주는곳)
    2) CP 오브젝트와 소켓 연결     
    3) CP 오브젝트의 결과를 확인하는 함수호출을 통해서 소켓의정보, 입출력 데이터 & rwmode (이는 구조체에서 만들어줘야함) 들을 가져올수있다
    
    *select 모델과 비교했을때 차이점
        -넌블로킹 방식IO 이기 때문에 IO작업으로인한 시간의 지연이 발생하지않는다
        -IO가 완료된 핸들을 찾기위해 반복문 구성 x
        -IO의 진행대상인 소켓의 핸들을 배열에 저장해놓고, 관리할 필요없음
        -IO의 처리를 위한 스레드의 수를 조절가능!(IO처리에 대한 더 빠른 속도보장..  + serversocket이 클라이언트 연결하는 스레드와 IO처리하는 스레드를 분리)
        
