전제 : c언어, 리눅스


chapter02 - 소켓의 타입과 프로토콜의 설정

-프로토콜 : 데이터 송수신을 위한 약속!
-소켓생성시 3가지 파라미터를 넘겨줌 int socket(int domain, int type, int protocol)
	1번 파라미터) 소켓이 사용할 프로토콜 체계(protocol family) 정보전달
		-프로토콜의 상위개념(상위카테고리)으로 프로토콜 체계안에서 여러 프로토콜이 정의됨..
		-IPv6 인터넷 프로토콜체계, IPv4인터넷 프로토콜체계, 로컬통신을 위한 Unix프로토콜 체계, Low level소켓을 위한 프로토콜체계, IPX 노벨 프로토콜 체계 등
	2번 파라미터) 소켓타입 : 소켓의 데이터 전송방식을 의미
		-프로토콜체계안에 둘 이상의 데이터 전송방식을 지닌다..
		-IPv4인터넷 프로토콜체계의 데이터전송방식
			-연결지향형소켓 : 데이터를 잃지않는다.. 순서를 보장한다.. 데이터 송수신시 데이터 경계가없다..
				=> 신뢰성있는 순차적인 바이트 기반의 연결지향 데이터 전송방식의 소켓
				=> TCP 프로토콜로 연결되며 최종적으로 TCP 소켓이 생성(즉, 이후 3번째 파라미터는 1,2번 파라미터가 이렇게 정해져있다면 한개밖에없음)
			-비연결지향형소켓 : 데이터를 잃을수있다.. 순서 보장안한다.. 데이터 전달하는데 제한이있다..(아무래도 빨리 전달하는것이 목적이므로) 한번 write하면 해당 내용을 연결되거나 합쳐지지않고 그대로 read됨(데이터 송수신에 경계가있음!)
				=> 신뢰성과 순차적 데이터 전송을 보장하지않는, 고속의 데이터 전송을 목적으로 하는 소켓
				=> UDP 프로토콜로 연결되며 최종적으로 UDP 소켓이 생성(즉, 이후 3번째 파라미터는 1,2번 파라미터가 이렇게 정해져있다면 한개밖에없음)
	3번 파라미터) 프로토콜 : 최종적으로 소켓이 사용하게될 프로토콜을 정의..
	
chapter03 - 주소체계와 데이터 정렬


-port : 컴퓨터의 프로그램상에서 소켓을 구분하기위해 사용(16비트)
	-서버에서 반드시 하나만 사용이됨
	-TCP랑 UDP는 구분되어있음.. 즉, TCP에서 9000포트사용해도 UDP에 9000포트 사용가능
-인터넷 주소
	-IPv4 : 4바이트 주소체계.. 
		-네트워크주소 + 호스트주소
			-클래스A : 1byte의 네트워크ID + 3byte의 hostID (첫번재 비트가 항상 0으로 시작)
			-클래스B : 2byte의 네트워크ID + 2byte의 hostID (첫번째 비트가 10으로 시작)
			-클래스C : 3byte의 네트워크ID + 1byte의 hostID (첫번째 비트가 110으로 시작)
			-클래스D : 4바이트의 멀티캐스트 IP주소
			-클래스E : 예약되어있는 주소체계
			=> 네트워크ID를 먼저찾고(라우터), 라우터에서 hostID를 찾아줌.. 즉, 그냥 우리가 생각하는IP는 네트워크ID+hostID임
			*라우터는 외부로부터 데이터를 송수신하기위한 물리적장치.. 스위치랑 기능이 비슷한데 스위치는 라우터보다 제공하는 기능이 더 적은것뿐..
			
	-IPv6 : 16바이트 주소체계.. IPv4가 부족할까봐..
-CPU가 데이터를 메모리에 저장하는방식
	-빅 엔디안 : 작은 번지부터 큰 번지로 데이터를 순차적으로 저장
		-네트워크 바이트 순서로 지정
	-리틀 엔디안 : 큰 번지부터 작은번지로 데이터를 저장
		-AMD,인텔 CPU를 사용하면 리틀엔디안!
	*호스트 바이트 순서 : CPU의 데이터 저장방식을 의미
	*네트워크 바이트 순서 : 데이터를 전송할때 통일된 기준으로 데이터를 전송하기로 약속한것
	=> 빅 엔디안을 기본으로 사용한다면 굳이 순서를 변경할 필요가 없겠지만, 리틀 엔디안이라면 네트워크바이트순서인 빅 엔디안으로 정렬방식을 변경해주어야함..
	

chapter04 - TCP 기반 서버/클라이언트 1

OSI 7계층 / 인터넷계층(4계층)

(오른쪽으로 갈수록 하위 계층..)
Application계층 -> TCP/UDP계층(Transport계층) -> IP계층 -> Link 계층

이런계층이 생긴이유? : 인터넷을 토한 효율적인 데이터의 송수신을 위해서는 표준이 필요했다..! 그래서 개방형시스템(Open System)을 설계하여 표준화하였고, 이로인해 교체나 유지보수가 용이하다! 발전도 더 잘되고!

-Link 계층 : 데이터를 보내기 위한 물리적계층
-IP계층 : 데이터를 보내기위한 경로를 셋팅(Internet Protocol)
	-IP 자체는 비 연결지향적, 신뢰할수없는 프로토콜임..
-TCP/UDP 계층(Transport계층) : 데이터의 실제 송수신담당 계층,, 신뢰성, 비신뢰성을 결정
	-TCP: 신뢰성없는 IP에 신뢰성을 보장,, 여러 패킷이 들어오는것을 하나씩 확인해서 못받으면 재요청
	-UDP:
-Application 계층 : 사용자가 application사용을 위한 cli <-> server간의 약속을 정의해놓은 계층(이전 계층의 작업은 소켓이 알아서 책이져줌..ㅎ)

-server socket
	-socket -> bind -> listen ->  accept -> read/write
	-서버 소켓(client를 받는 문지기)을 통해서 accept(연결) 되면 해당주소를 가진 socket을 내부적으로 만들어주고, 이를 통해서 데이터를 송수신한다..
-client socket
	-socket -> connect -> read/write
	-소켓을 생성할때는 바드시 IP와 Port가 필요한데(어느놈한테 보내야할지를 알아야하니깐..) client소켓에는 별도로 지정하는 부분이 없다.. 이는 커널에서 알아서 ip와 port를 바인딩 해주기때문이다!!!
	
chapter05 - TCP 기반 서버/클라이언트 2
-TCP의 이론적인 이야기
	-입출력버퍼
		-write시 출력버퍼에 저장되고, read시 입력버퍼에 저장된것을 읽어온다.. 즉, 데이터 송수신시 출력버퍼에 있는 데이터를 상대방의 입력버퍼로, 상대방의 출력버퍼에있는것을 나의 입력버퍼로 전달되는것이다!
			-30바이트를 보냈는데, 10바이트씩 받았다면 처음 10바이트 받았을때 나머지 20바이트는 입력버퍼에 저장되어있음!
			-그래서 java에서는 write하고 flush를 해줘야 출력버퍼에있는 데이터가 넘어간다..
		-입출력 버퍼는 TCP 소켓 각각에 대해 별도로 존재..
		-입출력 버퍼는 소켓 생성시 자동 생성
		-소켓을 닫아도 출력버퍼는 남아있는데이터 다 보냄..
		-소켓 닫으면 입력버퍼 데이터 날아감
		-TCP에는 '슬라이딩 윈도우' 라는 프로토콜이 있어서 이를 통해서 내 입력버퍼가 얼마나 받을수있는지를 상대방과 지속되는 통신을 통해 전달하므로 버퍼에 차고넘치는 데이터를 받아서 없어지는 경우가 없다!
	-상대 소켓과의 연결시 이뤄지는 동작
		-three way handshaking : 3단계의 과정으로 이루어짐
			1) sync ( A -> B )  ex. SEQ:1000, ACK: -    => A가 B에게 자신의 SEQ를 SYNC하도록함 (ACK로 1001보내달라는것)
			2) sync + ack ( A <- B )  ex. SEQ:2000, ACK:1001   => B는 A에게 동기화되었다는 응답으로 1001을 보내고, 나도 동기화해달라고 SEQ에 2000을 보냄
			3) ack ( A -> B ) 		  ex. SEQ:1001, ACK:2001   => A는 B에게 동기화되었다는 응답으로 2001을 보냄.. SEQ는 1001을 보내는데, 이는 앞서 보낸 1000보다 1증가한것.. (메세지 하나 새로 보낼때마다 적어도 하나씩은 증가하는듯)
	-상대 소켓과의 데이터 송수신시 이뤄지는 동작
		-ACK번호 -> SEQ번호+전송된바이트크기+1
			ex) A -> B - SEQ:1200, 100 byte data
			 A <- B - ACK:1301
			 A -> B - SEQ:1301, 100 byte data
			 A <- B - ACK:1402
			 
			 (ACK가 다음 보낼 SEQ를 보냄으로써 온전히 데이터를 신뢰성있게 잘 받았는지 확인해주는듯함)
			 
		-만일 ACK가 일정시간안에 없으면 timeout이 발생하고 다시 재요청을 진행한다
	-상대 소켓과의 연결종료시 이뤄지는 동작
		-상호간의 FIN메세지를 주고받고 종료가됨
		-four way handshaking : 4단계의 과정으로 이루어짐
			ex) A -> B : FIN - SEQ 5000, ACK -
				A <- B : ACK - SEQ 7500, ACK 5001
				A <- B : FIN - SEQ 7501, ACK 5001 (B가 응답한뒤에 FIN 메세지또한 보낸다)
				A -> B : ACK - SEQ 5001, ACK 7502
				
chapter06 - UDP 기반 서버/클라이언트
-UDP특성
	-흐름제어x => 신뢰성 떨어짐 ,, 그러나 생각만큼 데이터 손실 많지않음
		-흐름제어를 별도로 하지않는다는것은 데이터 송신하고 더이상 신경안쓴다는것... SEQ나 이런것도 신경안씀..
	-데이터의 경계가 있음
	-일반적으로 TCP보다 속도가 빠르나, TCP또한 송수신하는 데이터의 양이 크면 클수록 속도가 UDP 못지않다
	-편지와같음!
		-우체통하나로 편지를 보내기도하고 편지를 받기도함.. 편지를 보낼때 수신자가 완전히 받았는지는 확인이안됨..
-UDP동작의 원리
	-IP로 위치를 파악했다면 해당 UDP 소켓으로 전송하기위해서 해당 Port로 연결시켜주는것은 UDP의 역할이다.. 
-UDP의 효율적 사용
	-데이터 양이 적고 잦은 연결이 필요하다면 사용하는것이좋음
		-잦은연결시 TCP사용하게되면, 많은 비용이발생(연결,해제시의 흐름제어..)
	-압축파일과같은 하나라도 손실되어서는 안되는것이 아닌, 스트리밍같은것은 좋음
-UDP에서는 서버건 클라이언트건 하나의 소켓만 있으면된다!
-UDP소켓은 연결상태를 유지하지않는다
	-데이터를 전송할때 목적지 주소를 항상같이 넘겨줌.. 
-UDP소켓을 열때 포트번호를 bind하지않으면, 데이터를 보낼때(sendto함수 호출시) 사용하지않는 port를 알아서 할당해줌..
-UDP는 데이터 경계가 있기때문에 sendto한 횟수와 recvFrom 한 횟수와 동일해야함.. 
-unconnected udp소켓
	-sendto 함수 호출시 아래와 같은 순서로 동작
		-1단계 : UDP 소켓에 목적지의 IP와 PORT번호 등록
		-2단계 : 데이터 전송 
		-3단계 : UDP 소켓에 등록된 목적지 정보 삭제
-connected udp소켓
	-목적지에 대한 정보를 등록(connect함수)
		-여기서 connect는 연결설정과정을 거치는것이아니라, 그냥 목적지의 IP와 PORT가 등록되는것일뿐!
	-sendto 함수나 recvFrom을 사용하지않고 write와 read함수를 사용(목적지를 등록해놨기때문에 계속 파라미터로 주소 안넘겨도되니깐)
	-unconnected의 1,3단계를 pass,, 1/3정도 속도 증가!

chapter07 - 소켓의 우아한 연결종료
-소켓이 연결되면 두개의 스트림(일방적으로 흐르는 흐름)이 생기게된다. 입력버퍼에 데이터를 전달받는 스트림, 출력버퍼의 데이터를 전달하는 스트림
-half-close
	-두개의 스트림을 모두 끊는것이아닌 하나만(절반만) 끊는것
	-소켓을 그냥 close하게되면 두개의 스트림이 바로 끊어지게된다.. 그래서 우아한종료를 위해 half-close가 필요!
	
chapter08 - 도메인 이름과 인터넷 주소
-IP주소와 도메인 이름 사이에서의 변환을 수행하는 시스템이 DNS(Domain name system)이다.
-모든 컴퓨터에는 디폴트 DNS 서버의 주소가 등록되어있고, 도메인으로 요청하면 디폴트 DNS서버가 IP주소를 찾아서 연결해줌!
	-만약 디폴트 DNS서버에 IP를 찾을수없다면 상위의 DNS Server로 계속 올라가면서 IP주소를 찾는다! 즉, DNS는 계층적으로 관리되는 일종의 분산 데이터베이스 시스템이다
-하나의 DNS에는 여러개의 IP주소가 있을수 있다.. 이는 서버분산을 위해서 사용된다!