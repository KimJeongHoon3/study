- 디자인원칙
  - 달라지는 부분과 달리지지않는 부분을 분리한다!
    - 달라지는 부분은 나머지에 영향을 주지않도록 "캡슐화"를 한다.
      - 이를 통해 나중에 바뀌지않는 부분에 영향을 미치지않고 변경되는부분만 고칠수있다!
  - 구현이 아닌, 인터페이스에 맞춰서 프로그래밍한다!
  - 상속보다는 구성을 활용한다
    - 구성이란 인스턴스변수에서 사용되는것..
    - 캡슐화가능(인터페이스화)
      - 그로인해 runtime간 동적으로 행동변경도 가능
      - 이는 기존 소스를 건드리지않기때문에 기존 코드에서 버그가 생기거나 의도치않은 부작용을 원천봉쇄할수있다
  - 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야한다  
    - 이래야 유연하고 변화에강하다!
  - OCP(Opne Close Principle) : 클래스는 확장에는 열려있고, 코드 변경에는 닫혀있어야한다 
    - 모든 부분에 이렇게 사용가능하지는않다! 그리고 이것을 적용하려하면 소스코드만 복잡해질뿐이다. 최대한 바뀔확률이 높은 부분을 중점적으로 살펴보고 원칙을 적용하는것이 좋다!
  - 의존성 뒤집기 원칙(Dependcy Inversion Principle)
    - 구상클래스에 의존하는것이 아닌(new 범벅..), 추상화된것에 의존하도록 만들기! 
  - 최소 지식 원칙
    - 친한 친구하고만 얘기하기!(변경이 일어났을때, 연쇄적으로 변경하는것을 막기위함)
    - >여러 객체하고 인연 맺는것을 피하는방법(아래 종류의 객체만 메소드에서 호출하면됨!) <br> 1) 객체 자체 <br> 2) 메소드에 매개변수로 전달된 객체 <br> 3) 그 메소드에서 생성하거나 인스턴스를 만든객체 <br> 4) 그 객체에 속하는 구성요소(멤버변수)
  - 헐리우드 원칙
    - "먼저 연락하지마세요. 저희가 연락드리겠습니다"
    - 저수준 구성요소들은 고수준 구성요소에서 사용할지를 결정하고, 저수준 구성요소는 고수준 구성요에 접근하지 못하게하는것!
    - 즉, 고수준 구성요소가 저수준 구성요소에게 먼저 연락하지말라고 하는것이다!
    - 예를들어, 템플릿 메소드 패턴에서 추상클래스에서 알고리즘을정의한 템플릿메소드는 추상메소드를 정의한 서브클래스를 호출하지만, 서브클래스에서는 본인보다 상위인 추상클래스의 메소드를 호출하지않도록한다!
    - 팩토리, 옵저버 등도 헐리우드 원칙
  - 클래스를 바꾸는 이유는 한 가지 뿐이어야한다 (직역해서 그런건지.. 내용이랑은 매칭이잘..)
    - 최대한 한 클래스에서는 한가지 역할만수행하도록! (응집도 높다!! 응집도가 높다는것은 역할이 여러개 모여있다는것이 아니라, 필수적이고 필요한 연관된것만 모여있다는것이다!!)
    - 한 클래스에 여러 역할들을 담당하고있으면 고쳐야하는 부분이 상호간에 연관될수있음..
  - ***토비 스프링에서 이야기하는 디자인패턴에 대한 설명***
    - 소프트웨어 설계시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할수있는 재사용 가능한 솔루션
    - 이러한 디자인 패턴에는 설계의 의도와 해결책을 설명할수있다
    - 주로 객체지향설계에 관한것!
    - 디자인패턴은 객체지향을 추구하다보니, 이 원칙을 근간으로 만들어져잇는데, 그로인해 크게 보면 두가지의 모습이 나타남
      - 클래스상속
      - 오브젝트 합성
     
- 스트레이티지 패턴 (DUCK)
  - 알고리즘군을 정의하고 이를 캡슐화하여 원하는 알고리즘(알고리즘군을 구성하는)을 교체할수있도록(동적으로도가능) 만들어주는 패턴
  - 간단한 정리
    - 변경이 자주 일어나는부분을 인터페이스화(행동을 캡슐화)
      - 예를들어, 날아가는 행동을 하는 부분을 인터페이스로만들어놓고 이를 클래스에 "구성"함으로써 언제든지 변경이 가능하도록해줌(set함수로 해당 인터페이스의 구상클래스를 변경할수있도록) 
    - 해당 인터페이스를 인스턴스 변수에 정의
    - 이를 구성하고 있는 추상클래스는 해당 인터페이스에 정의되어있는 함수를 실행해줌
    - 또한 동적으로 인스턴스를 변경할수있도록 setter 메소드를 활용
    - => 핵심은 "쉽게 확장/변경 가능하도록 캡슐화", "동적으로 확장/변경 가능"
    - 실제 행동은 다른 객체에 위임!


- 옵저버 패턴 (기상정보 화면에 보여주기)
  - 한 객체(SUBJECT)의 상태가 바뀌면 해당 객체에 의존하는(Observer) 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식의 일대다 의존성을 정의하는 패턴
  - 간단한 정리
    - Subject를 Observer가 구독하는 개념
    - 즉, Subject 인터페이스의 구현부에는 Observer 인터페이스들을 가지고있어서, 특정 상태변화시 Observer들에게(이때, Observer가 구체적으로 어떤 놈인지는 모르는게 핵심) 특정 값을 전달해준다..
    - Observer는 구체적으로 어떤 놈인지 모르는데, 그렇기때문에 느슨한 결합이라할수있으며, 데이터를 noti받아서 Observer 구현부에서 각자의 행동에 맡게 데이터를 처리하면됨
    - Observer가 변경된다해서 Subejct가 변경이 필요하지않음!
  - Observable이라는 클래스가 자바에서는 제공되는데, 이를 통해서도 옵저버 패턴을 구현할수있다.
    - 그러나 이는 클래스를 상속받아서 진행되어야하므로(서브클래스가됨) 재사용하기에 어려움이있음
    - Observable은 상태변화를 지속적으로 Observable측에서 해줘야함..(noti하고나면 상태값이 false가 됨. setChanged 라는 메소드를 noti전에 호출해줘야함.. 이게 필요한 이유는 너무 자주 반복적으로 noti를 주는것을 막기위함이라함)
    - Observer가 Observable에게 데이터를 noti받으면 해당 데이터를 push방식으로 받기도하고 pull방식으로 받을수도잇음..
      - pull방식은 Observer 객체에 접근해서 데이터를 가져오는방식임..(즉, 변화되었다! 정도만 받고 실제 데이터를 객체를 통해서 가져감)
      - pull 방식이 더 "옳은"것으로 간주된다함

- 데코레이터 패턴 (스타벅스!)
  - 객체에 추가적인 요건을 동적으로 첨가하는 패턴(객체를 새로운것을 추가하여 장식해준다!). 데코레이터는 서브클래스를 만드는것을 통해서 기능을 유연하게 확장가능 
  - 인터페이스 바꾸지않고 책임(기능)만 추가됨!
  - 간단한 정리
    - 무언가 계속 추가되는(기존의 것에 얹어서)것이 있다면 데코레이터 패턴을 생각하라(기존 구상 클래스가 있는것을 없애는것이 아니다.. 기존 구상클래스에 새로운 무언가가 필요해서 덧붙이는것이다)
    - 구상 구성요소를 감싸는 데코레이터가 필요
    - 데코레이터가 전달받는 구상 구성요소의 super class와 데코레이터의 super class는 동일한 인터페이스를 구상한것이다
    - 데코레이터를 구현한 클래스의 인스턴스변수에는 데코레이터의 가장 추상화된 인스턴스(혹은 추상클래스)를 생성자로 전달받는다..(당연히 그래야지 넘겨받는 구상클래스에서 했던 내용에 추가할수있겠지..)
    - 데코레이터를 통해 새로운 기능을 더하여 장식하는 개념임
    - 가장 큰 장점은 기존 소스 건드리지않고 원하는기능을 추가해줄수있음!(기존 자바IO에서 모든 문자열을 소문자로 바꾸게하는 Wrapper클래스를 만들수있다!)
    - 데코레이터 패턴을 사용하면 자잘한 객체들이 매우 많이 추가될수있고(특히 그러다보면 중간에 필수적으러 넣어야할 구상객체를 놓칠수도있음..), 데코레이터를 너무 많이 사용하면 코드가 필요이상으로 복잡해진다!
      - 이런 부분을 보완해주는것이 팩토리패턴과 빌드패턴
        - client 요청에 직접 만들어서 전달해주니깐.. 중간에 놓치는 구상객체없음

- 팩토리패턴(PIZZA)
  - 팩토리 메소드패턴
    - 서브클래스에서 어떤 클래스를 만들지 결정하게함으로써, 객체 생성을 "캡슐화" 한다!(추상메소드를 통해서 구현단에서 객체생성하는 로직을 만든다)
    - 생성을 캡슐화하는것이지 생성한뒤에 하는 행동들은 동일하니께,, 리턴타입은 인터페이스로 정의하는게 당연 좋겠지..?
    - 간단한 정리
      - ***객체를 만들기위한*** 인스턴스를 정의하는것인데, 실제적으로 객체가 만들어지는곳은 ***서브클래스(구상클래스)***
      - new 는 다 공장(factory)에서 처리한다!
      - 인터페이스 안에 추상메소드를 만들어서 추상메소드 안에서 객체생성(new)!
  - 추상 팩토리 패턴
    - 서로 연관된 일련의 제품들을 만들어야할때 즉, 제품군을 만들때 사용
    - 필요한, 연관된 객체들을 모으는 개념..?
    - 객체 생성이 팩토리 인터페이스에서 선언한 메소드들에서 구현
  - => 둘다 객체 생성을 캡슐화하기 위한 것이며, 클라이언트와 구상클래스가 서로 분리된 유연한 디자인을 구현할수 있게 해준다..(직접 new 안쓴다는 말인듯..?)  
  - 비슷한점
    - 둘다 구체적인 객체 생성 과정을 추상화한 인터페이스를 제공한다.
  - 다른점
    - 팩토리 메소드 패턴은 팩토리를 구현하는 방법 (inheritance)에 초점을 둔다.
    - 추상 팩토리 패턴은 팩토리를 사용하는 방법 (composition)에 초점을 둔다.
    - 팩토리 메소드 패턴은 구체적 객체 생성 과정을 하위 또는 구체적 클래스로 옮기는 것이 목적이다.
    - 추상 팩토리 패턴은 관련있는 여러 객체를 구체적인 클래스에 의존하지 않고 만들 수 있게 해주는 것이 목적이다.


- 싱글턴 패턴
  - 어플리케이션 내에 유일무이한 인스턴스를 만드는 패턴 + 해당 인스턴스에 전역접근이 가능
  - 인스턴스를 직접만드는게 아니라, 요청하는개념!
  - 자바에서 design pattern에서 singleton패키지 내용참고!(순차적으로 설명해놓았음)
  - DCL 사용시 volatile 사용을 필수적으로 해야하는것에 관련한 설명
    - https://yeahhappyday.tistory.com/entry/singleton-%ED%8C%A8%ED%84%B4%EA%B3%BC-volatileDCLDouble-Checking-Locking

- 커맨드 패턴 
  - 요구사항을 객체로 캡슐화 가능, 매개변수를 써서 여러 가지 다른 요구사항을 집어넣을수도있으며, 요청 내역을 큐에 저장하거나 로그로 기록할수도있으며, 작업 취소기능도 지원가능..
  - 간단한 정리
    - 인보커
      - 커맨더 인터페이스를 실행하는역할(커맨드 인터페이스를 ***구성***)
      - 커맨더를 통해서 리시버의 실행을 요청함
      - 중요한것은 커맨더로 무언가를 실행하는것은 알지만 구체적으로 무엇을 실행하는지는 인보커에서 알지못함
    - 커맨더
      - 일반적으로 execute함수만을 인터페이스로 가지며, 이를 구현하게되면 실제로 명령을 실행할 대상(리시버)을 execute함수내부에서 호출한다
  	  - 추가적인 행동들이 필요한경우(ex. undo, store, load 등) 커맨드 인터페이스에 추가적인 행동들을 명시하여 구현하도록 하는것도 있으니 잘 알아둘것!
      - 커맨드 인터페이스를 ***구현***함
    - 리시버
      - 구체적으로 실행할 대상
	<br><br>  
	- 메소드를 커맨드 객체로 캡슐화하는것!
	- 요청을 하는 객체와 그 요청을 수행하는 객체를 분리시키고 싶을때 사용하면된다!
	- 인보커를 사용해서 인보커에 구성되어있는 커맨더를실행.. 커맨더는 리시버의 특정 행동을 실행<br> 결국, 인보커는 리시버가 어떤 행동을 하는지 자세히는 알수없으나, 행동을 실행은 시켜주는놈..<br> 하나의 리시버에 여러개의 커맨더를 가질수있으며, 이러한 여러 커맨더를 통해서 리시버의 행동의변화를 추가하는데 용이함..<br> 리시버의 하나의 행동만을 분리시킬수있음.. 그래서 어디서든 이를 사용할수있음!!
	- 커맨드가 행동 하나만을 정의하니, undo메소드와같은경우 핸들링이 쉽고(이놈의상태를 확인하는 작업필요없음), 특정 명령에 일련의 행동들을 나타내야할때도 재사용이 좋음
	- 리시버에 실제적으로 수행할 여러 기능들이 있을테고, 이러한 기능들을 수행해주는 커맨더(기능별로 커맨더를 따로 만들게되겠지)가 있고, 인보커가 커맨더를 호출하여 결국 리시버의 기능들을 수행함
	- 인보커는 작업을 요청하는것.. 실제 구체적인 작업내용이 있는곳은 리시버.. 인보커가 커맨드객체에 수행요청을하면, 커맨드객체가 리시버의 작업 메서드를 호출.. 즉, 커맨드 객체가 이어주는 역할..
  	- 작업의 요청과 실제 작업하는것을 분리하는것의 장점은 결국 작업에 대한 확장이 필요할때, 작업요청하는쪽의 소스는 고치지않을수있다!
	
- 어뎁터패턴
  - 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환하는 패턴. 어댑터를 이용하면 인터페이스 호환성 문제때문에 같이 쓸수 없는 클래스들을 연결해서 사용가능
  - 클라이언트에서 필요로하는 인터페이스로 적응 시키는것이 목적!(adapter!)  
  - 간단한 정리
    - 어뎁터 클래스는 타겟인터페이스로 ***구현*** 되고, 어뎁티 인터페이스를 ***구성*** 한다.(어뎁티되는 객체를 생성자나 메소드로 받아옴. 어뎁터가 어뎁티를 감싼다고 표현) 
	- 이를 통해, 클라이언트 입장에서는 타겟 인터페이스만 보고 실행하게되므로 어뎁터 내부의 동작은 신경쓸 필요가없다! 즉, 어뎁터 클래스로 연결해주는 작업이 있을뿐 기존 소스를 건드릴 필요는없다!

- 퍼사드
  - 인터페이스를 변경하는 패턴
  - 하나 이상의 클래스의 복잡한 인터페이스를 변경(즉, 퍼사드(외관)을 신경쓰는것)
  - 클라이언트에게 복잡한 서브시스템을 간단하게 제공하기위한 목적
  - 고수준 인터페이스를 정의하는것! 서브시스템을 더쉽게 이용가능!(서브시스템에는 다양한 인터페이스들이 있음! 물론 1개일수도있고)
  - 한 서브시스템에서 여러 퍼사드를 만들어도됨
  
- 템플릿 메소드 패턴
  - 특정 메소드를 통해서 템플릿이 정해짐(템플릿이란 무언가를 만들기위해 정형화시켜놓은것인데, 이를 위한 메소드 패턴이 템플릿 메소드패턴)
  - 템플릿 메소드 안에 정의해야할 메소드들이(알고리즘의 각 단계들) 있을텐데, 이는 서브클래스에서 정의
  - 알고리즘의 골격을 정의하며, 알고리즘의 여러단계중 일부는 서브클래스에서 구현하도록 만드는 패턴
  - ***후크***를 사용할수있음
    - 후크는 기본적인 내용만 구현되어있거나 아무코드도 들어있지않은 코드임
    - 서브클래스에서 이에 대한 별도의 오버라이딩이없다면 템플릿 메소드에서제공한 디폴트로 실행됨
    - 그렇지않다면 특정 행동(메소드)을 하도록 혹은 하지 못하도록 만들수있음
    - 후크를 통해서 특정행동(메소드)을 할지말지를 결정하도록 가능(알고리즘 진행상황을 변경가능!)
    - 알고리즘의 단계에서 차이가 나는부분을 후크로 만들어도 좋을듯
  - 간단한 정리
    - 알고리즘을 정의한 메소드(템플릿메소드)는 보통 final변수로 선언하여 서브클래스에서 고칠수없도록 만들어준다
    - 코드 재사용에있어서 크게 도움이 됨
    - 템플릿 메소드가 들어있는 추상클래스에서는 구상메소드, 추상메소드, 후크를 정의할수있음
      - 구상메소드도 변경을 막아야한다면 final로 선언!
    - Arrays.sort() 또한 템플릿 메소드 패턴이나, 교과서적인 방식은 아님.. 하지만 분명한것은 strategy패턴은 아님
    - 스트레이티지패턴과 템플릿메소드 패턴 모두 알고리즘을 캡슐화하는 패턴이지만, 전자는 구성을 사용하고 후자는 상속을 사용함
    - 팩토리 메소드 패턴은 특화된 템플릿 메소드 패턴! (유사하다 싶더니만..)
    - *알고리즘이있을때 변경이 일어나는 부분을 캡슐화할때 사용하는것이 전략패턴과 탬플릿메소드패턴인데, 이들의 차이는 상속을 통해 변경되는부분을 정의하냐, 아님 구성을 통해 정의하냐의 차이다

- 이터레이터 패턴
  - 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할수 있게 해주는 방법을 제공하는 패턴
  - 간단한 정리
    - 이를 활용하면 어떤 컬렉션으로 구성되어있는지는 알 필요 없음(클라이언트에게 컬렉션을 노출하지않음) 
    - 이터레이터는 외부반복자라고 부른다
      - 외부 반복자란 클라이언트가 반복작업을 제어하는것을 의미한다
      - 반대로 내부 반복자란 클라이언트가 해야할 작업을 전달하면 알아서 내부에서 반복자를 통해서 작업을 진행하는것이다(ex. foreach)
    - 컬렉션에서 iterator()는 자신을 위한 반복자(Iterator)를 반환해준다. 물론 이것이 어떻게 구성되어있는지는 클라이언트 입장에서는 알 필요가 없다.
    - 이를 통해 컬렉션에서 반복작업하는 역할을 분리시킬수있음!

- 컴포지트 패턴 (Composite란 합성물이라는 뜻)
  - 객체들을 트리구조로 구성하여 부분과 전체를 나타내는 계층구조로 나타내는 패턴 
  - 클라이언트에서 개별객체와 다른 객체들로 구성된 복합 객체를 똑같은 방법으로 다룰수 있음
  - 간단한 정리
    - 부분과 전체를 모두 관리할수있음
    - 구성요소(Component)에는 복합객체(Composite)와 잎(leaf) 이 있는데, 복합객체는 또 다른 구성요소를 가지게된다.(재귀!)
    - Component를 보면 leaf에서 필요한 요소와 복합객체에서 필요한 요소 둘다를 가지고있게되기때문에, 복합객체 입장에서는 불필요한 메소드들이 있을수있다.(leaf도 마찬가지)
    - 이렇게 Component가 leaf의 역할도하고 복합객체의 역할도 하기때문에, 컴포지트패턴은 ***단일 역할 원칙을 깨면서 투명성을 확보***하기 위한 패턴이다
      - 투명성이란, 클라이언트 입장에서 요놈이 복합객체인지 잎인지 알수없는것을 이야기한다.(역할이 명백하지않다.) 
      - 이에반대되는게 안정성인데, 이 안정성을 위해서 instanceof 와 같은 연산자를 통해서 확인은 가능하나 투명성이 떨어지게된다.
    - 자식 노드가 부모노드에 대한 포인터를 집어넣어서 부모노드를 불러올수도있음
    - 복합구조가 너무 복잡한경우 계산결과를 캐싱하도록 구현할수도 잇음(***알고리즘 기억나면 적어놓기..***)
    - 컴포지트 패턴과 이터레이터를 잘 구현하면 여러 계층의 컴포지트 패턴에서 외부반복자를 활용하여 특정 노드를 찾아낼수도있음(stack쓰고 난리 치는데, 요거를 잘 활용하면 좋을듯)

- 스테이트 패턴
  - 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀수있는 패턴. 마치 객체의 클래스가 바뀌는것과 같은 결과를 얻을수있음 (상태값을 원시타입으로 0,1,2.. 로만 사용한다는 생각을 바꿔라!)
  - 간단한 정리
    - 특정 상태별로 행동을 진행한다면(하나의 메소드에 if문으로 상태에따라 행동정의), 스테이트 패턴을 사용하여 상태클래스 안에 행동들을 구현하는 식으로 만들수있음..!(생각을 뒤집어라..!)
    - 상태가 계속 바뀐다면 이 부분을 캡슐화하는개념! 즉, 상태가 추가되면 메소드마다 if문 추가해서 작업하는것이아닌, 상태클래스 하나를 더 추가! 이를 통해서 OCP룰을 지킨다! (if문으로 더럽히는거 방지 또한 가능)
    - 이제 상태는 원시타입이 아닌, 클래스로 가져간다!(상태가 변하는것은 0,1,2 이런식이 아니라 클래스 자체가 계속 변화되는것! 하지만 같은 인터페이스를 가지고있으니 타입은 동일하겠지!)
    - 클라이언트 입장에서는 상태객체는 몰라도 됨.. Context객체가 알아서 행동에 따라 State객체를 변경시킴. 무튼, 상태에 따라 State 객체가변경된다!(State 인터페이스를 구현한 클래스가 특정행동 이후에 변경(특정행동 이후에 상태가 변경되니깐. 상태가 변경된다는것은 당연 객체가 변경된는다는것. 상태변경시 Context객체에게 상태변경을 요청하거나 직접 변경된 상태객체를 넘겨줄수도있음))
    - ***스트레이티지 패턴과의 차이가있는데, 스트레이티지 패턴에서는 클라이언트가 전략객체를 set하게됨. 즉, 어떤 객체를 사용할것인지 분명하게 알고잇음.. 구성을 통해 원하는 행동을 정의!***
    - Context객체에서 현재상태(이는 클래스임)에게 행동을 위임

- 프록시 패턴
  - 어떤 객체에 대한 ***접근을 제어***하기 위한 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴
  - 간단한 정리
    - 대리자역할임! 클라이언트가 요청하는 작업을 proxy를 통해서 대신 호출한다(request -> proxy -> real_request)
      - 어떻게 보면 RealSubject의 메소드 호출을 중간에 가로채는것!
    - 이를 통해서 메소드 접근을 제어할수도 있고, 지연된 객체 생성 가능하고, 시간이 걸리는것은 별도 스레드를 사용하여 진행하도록 proxy에서 사용해서 어플리케이션에 중단이 없도록 만들수도있음!
    - 구조는 상당히 심플함.. subject 인터페이스를 proxy와 realSubject가 구현하고, 클라이언트는 proxy객체를 호출하는것!
      - Proxy와 RealSubject는 동일한 인터페이스를 구현하기때문에, RealSubject가 들어갈 자리라면 언제든지 Proxy를 대신 집어넣을수있음!
    - RMI에서는 원격 서버의 메소드를 대신 호출하는것이 프록시(스터브) 역할 (사이트 참고 : https://selfdevelope.tistory.com/521 , https://channelofchaos.tistory.com/93)
    - 팩토리를 사용해서 프록시를 보통 만든다함.. 타입이 똑같으므로 프록시인지 RealSubject인지 클라는 모름 ㅎ
    - ***데코레이터 패턴이랑은 다른데, 프록시는 단순히 객체를 감싸는것이 아니기 때문이다. 프록시는 진짜 객체의 생성도 늦게만들게 해주는 패턴도 있다. 객체를 감싸는것도 만들수는 있겠지만 항상 감싸는것은 아니다! 중요한것은 대리자라는것!***
    - 종류
      - 원격프록시 : 다른 JVM에 들어있는 객체를 대신 호출해줌
      - 가상프록시 : 생성하는데 많은 비용이 드는 객체를 대신하는 역할. 진짜 객체가 필요하게 되기 전까지 객체의 생성을 미루기도하고, 객체 생성전 또는 객체 생성도중에 객체를 대신하기도한다.(아직 실제 객체를 부르기전까지 프록시에서 임시로 특정 작업을 해줌..) RealSubject가 완성되면 이에대한 결과를 전달해줌 (ICON예제)
      - 방화벽 프록시 : 네트워크 자원에 대한 접근을 제어.. (기업용 방화벽 시스템에서 사용)
      - 스마트 레퍼런스 프록시 : 주 객체가 참조될때마다 추가 행동을 제공. ex) 객체에 대한 레퍼런스 개수를 센다 ()
      - 캐싱 프록시 : 비용이 많이 드는 작업의 결과를 임시로 저장. 여러 클라에게 결과를 공유하게 해줌으로써 계산시간 또는 네트워크 지연을 줄여주는 효과 (웹 서버 프록시 또는 콘텐츠 관리 및 퍼블리싱 시스템에서 주로 사용)
      - 동기화 프록시 : 여러 스레드에서 주 객체에 접근 하는 경우에 안전하게 작업을 처리할 수 있게 해줌 (자바스페이스?)
      - 복잡도 숨김 프록시 : 퍼사드 프록시라고도 불림. 복잡한 클래스의 접근을 제어하고 복잡도를 숨겨줌..
      - 지연복사 프록시 : 클라이언트에서 필요로 할 때까지 객체가 복사되는것을 지연시킴으로써 객체의 복사를 제어. 변형된 가상 프록시. (CopyOnWriteArrayList에서 볼수있다함.. 그런데 난 못찾음..)
       
    
- 부록
  - 브릿지 패턴 (리모콘을 만드는데, 리모콘을 지원하는 제품들에 대한 사용방법 변경뿐아니라, 리모콘자체도 기능추가나 변화가 필요한경우.. 즉, 리모콘을 각 제품사별로 구현할수있도록 추상화해놨는데, 리모콘 자체도 기능추가와 같은 변경이 필요한경우..)
    - 구현뿐만 아니라 추상화된 부분까지 변경시켜야하는 경우
    - 구현해야하는 대상을 인터페이스로 만들고 이를 구성으로 가져감 + 추상된부분 변경이 필요하다면 추상클래스를 상속하여 변경이 필요한 부분을 구현
      - => 두개의 계층구조(기존에 추상화된 부분 + 기존 구현부를 나타냈던 부분을 인터페이스를 사용함으로 생기는 부분)가 생기게됨! 이 둘의 관계를 브릿지 라고 부름.
    - 추상화한놈이 포함관계이있는 인터페이스로 가지고있기때문에, Client는 추상화한놈을 통해서 간접적으로 포함된 인터페이스를 실행시킬수있음..
      - 추상화한놈을 독립적으로 확장할수있고, 포함관계에 있는 인터페이스도 독립적으로 확장할수있는 형태이며 이 둘을 bridge와 같이 연결해놓았기때문에 브릿지패턴
    - 장점
      - 구현을 인터페이스에 완전히 결합시키지 않았기때문에 구현과 추상회된 부분을 분리가능(브릿지 관계)
      - 추상화된 부분과 실제 구현부분을 독립적으로 확장 가능(계층이 따로 분리되어있는 상태이므로가능)
      - 추상화된 부분을 구현한 구상 클래스를 바꿔도 클라이언트 쪽에는 영향 끼치지않음(추상화된 부분의변경 요청이 있을때 구상클래스를 통해 확장가능하며 기존 클라이언트 쪽에 영향 없음)
        - client는 추상화된 놈을 바라보고있으니.. 당연 영향 없음
    - 단점
      - 디자인 복잡해짐...
  - 빌더 패턴
    - 장점
      - 복합객체가 생성되는 과정을 캡슐화
      - 클라이언트 입장에서는 추상 인터페이스만 볼 수 있기때문에 제품을 구현한 코드를 쉽게 바꿀수있음
      - 제품의 내부구조를 클라로부터 보호가능
      - 여러 단계와 다양한 절차를 통해서 객체를 만들 수 있음  
    - 단점
      - 팩토리를 사용하는 경우에 비해 객체를 만들기 위해서 클라이언트에 대해 더 많이 알아야함
        - 빌더도 어쨋든 추가해야할 대상을 지정해야하니깐 그런듯..
  - 역할 사슬 패턴
    - 한 요청을 두개 이상의 객체에서 처리하고 싶을때 사용
    - Netty에서 파이프라인의 핸들러들이 이러한 패턴으로 구현되어잇는듯함
    - 장점
      - 요청을 보내는쪽과 받는쪽을 분리할수있음 (Netty에서는 이벤트가 발생하면(이벤트 루프에서 이벤트에대한 요청이 들어오면) 파이프라인을 타게됨)
      - 객체에서는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는 다른 객체에 대한 직접적인 레퍼런스를 가질 필요가 없음(Netty에서는 handler에 prev, next가 담겨져있음.. 핸들러 하나의 입장에서 핸들러 전체를 알 필요는 없지만 다음 혹은 이전의 핸들러를 알아서 그 다음 핸들러에게 이벤트를 전달하는 방식임)
      - 사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역할을 동적으로 추가/제거 가능 
    - 단점
      - 실행시 디버깅에대한 어려움이있음
      - 요청이 적절하게 처리가 되도록 객체가 만들어지지않았다면 사슬끝까지 갔음에도 처리못할수잇음..  
  - 미디에이터 패턴
    - 서로 관련된 객체 사이의 복잡한 통신과 제어를 한곳으로 집중시키고자 하는 경우, 미디에이터 패턴을 사용
    - 각각의 상태에 따라 특정 객체의 행동을 요청한다면, 그리고 이에대한 얽혀있는 객체가 많아진다면 이를 반드시 고려해볼것
    - 각 객체의 상태가 바뀜에 따라 미디에이터에게 알려주고, 미디에이터는 이에대한 적절한 응답을 함(필요객체에 행동요청)
    - 장점
      - 시스템하고 각 객체를 분리시킴으로써 재사용성을 획기적으로 향상
      - 제어 로직을 한군데 모아놨기 때문에 관리하기가 수월
      - 객체사이의 오가는 메시지의 종류를 확 줄이고 단순화 가능
    - 단점
      - 디자인 잘 못하면 미디에이터 객체 자체가 너무 복잡해질수 있음
---
- 용어 정리
  - 캡슐화 : 관련된 데이터와 함수들을 묶는 단위
    - 특성
      - 추상화 단위가 됨
        - 캡슐화를 하면 추상화가 된다고 볼수있는데, 캡슐화를 하게되면 관련된 데이터와 함수들을 하나의 캐슙 단위로 묶어주기 때문에 복잡한 내용들은 캡슐 내부속으로 숨어버리게 되고, 외부에는 캡슐단위의 의미 있는 단위로만 보여주기때문에 추상화 단위 또한 된다
      - 정보은닉 가능
        - 캡슐화를 통해 인터페이스를 제외한 데이터와 함수들을 캡슐속으로 숨기기 때문에 캡슐화를 통해 정보은닉 가능
        - 객체간에는 상대방의 인터페이스만을 보게되므로 실제 내부의 로직은 알수도, 알 필요도 없음!
      - 재사용성에 굿
        - 캡슐화의 단위는 클래스 단위이기때문에, 클래스를 통해 객체단위로 생성되어 움직이게됨 (함수단위보다 굿)
      
  - 추상화 : 복잡한 문제를 다루기 위해서 불필요한 부분들은 숨기고 중요한 부분만을 표현하는것을 의미
  - 정보은닉 : 데이터와 함수들을 외부에 노출시키지않고 내부에 숨기는것!( ex. private 접근자)
    - 객체의 구체적인 타입 은닉(= 상위 타입 캐스팅) **인터페이스나 추상클래스 사용하는거이야기하는듯?**
    - 객체의 필드 및 메소드 은닉(= 캡슐화) 
    - 구현 은닉(= 인터페이스 및 추상 클래스 기반의 구현)

  https://frontierdev.tistory.com/93#:~:text=%EC%BA%A1%EC%8A%90%ED%99%94%EC%99%80%20%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EC%9D%98,%EC%99%B8%EB%B6%80%EC%97%90%20%EC%88%A8%EA%B8%B0%EB%8A%94%20%EC%9E%A5%EC%B9%98%EC%9D%B4%EB%8B%A4.&text=%EC%9E%90%EB%B0%94%EC%9D%98%20%EC%BA%A1%EC%8A%90%ED%99%94%20%EA%B5%AC%ED%98%84%EC%9D%80,%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89%EC%9D%84%20%EA%B5%AC%ED%98%84%ED%95%9C%EB%8B%A4.

  https://yongdev.tistory.com/131

  - visitor 패턴
    - 방문자(Visitor)에 각 (연관이 매우 깊은)객체(Element)를 구현한대상들의 행동을 정의하고 Element가 accpet메서드(일반적으로 accept쓴다함)를 통해서 방문자를 넘겨받으면 이를 수행..  
    - 방문자에는 Element별로 수행해야할 특정기능(ex. VIP, GOLD, NORMAL 등 Member별로 point혜택이 다르게 적용.. 여기서 Member가 Element이고 혜택이 Visitor)이 정의되어있다.. 그리고 Element에는 visitor를 수행할 메서드하나만 추가(보통 accept이름을 쓰고, visitor가 파라미터)하고 해당 메서드에서는 visitor.method(this)를 수행.. 여기서 this는 Element의 구체화이기때문에 방문자에 Element별로 정의된 기능이 수행된다!! 
    - 그렇기에 Element의 특정 기능을 추가하고싶을때 visitor 하나만 더 구현해서 파라미터로 넘겨주면 되기때문에 기능추가에 용이하다.. 그러나 Element가 추가될때는 그에 맞추어 visitor도 변경이 필요하다..
    - 기존 element구조를 수정하지 않고 새로운 동작을 기존 객체에 추가할 수 있다!! => OCP
    - 언제 쓰나?
      - 적용해야 할 대상 객체가 잘 바뀌지 않고(특히 개수), 적용할 알고리즘이 추가될 가능성이 많은 상황일 때 사용을 고려해봐야 한다. 예를들면 Member 등급은 Gold, Vip, Green 으로 고정이거나 추가될 가능성이 작으면서 혜택(ex. 등급에 따른 BlackFridayBenefit)은 앞으로 계속해서 추가될 가능성이 있을 때를 말한다. 왜냐하면 Member가 추가되면 모든 Benefit 클래스를 수정해야 하기 때문이다.
      - 또한 대상 객체가 가지는 동작과 객체를 분리해 코드의 응집도를 높이고자 할 때 사용할 수 있다. 멤버별 혜택에 대한 로직을 보기 위해서는 Benefit의 구상 클래스만 보면 쉽게 파악할 수 있다. (=> Element별 특정 행동들을 응집화)
      - ConcreteVisitor를 추가하는것은 Element에 대하여 새로운 기능을 추가하는것
        - visitor는 element가 수행할기능을 집합해놓은것.. (오버로딩.. 그러나 그냥 오버로딩말고 메소드명으로 지정해도 노 상관)
      - Client는 element.accept(visitor) 를 호출해주는데, 이게 visitor에 대한 확장은 가능하고 기존소스변경이 없기때문에 OCP에 충실한것!
        - 그러나 Element가 추가 또는 삭제되면 모든 Visitor에 변경이 일어나게됨.. 그렇기에 Element가 고정 + Element의 기능추가필요할때 사용하기 좋은패턴
    - 정리굿 : https://thecodinglog.github.io/design/2019/10/29/visitor-pattern.html
      - https://velog.io/@2yeseul/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-Visitor
    - 예제
      - `BeanDefinitionVisitor`
        - chatgpt 설명
          ```md
            `BeanDefinitionVisitor` 클래스는 Spring 프레임워크의 일부로, Visitor 디자인 패턴을 기반으로 합니다. 이 클래스는 주로 Spring의 빈 정의(`BeanDefinition`)를 순회하고 조작하는 데 사용됩니다. `BeanDefinition`은 Spring 컨테이너에서 빈의 구성을 정의하는 핵심 객체입니다.
            Visitor 패턴의 특징은 객체 구조를 순회하면서 각 객체에 대한 특정 작업을 수행한다는 점입니다. `BeanDefinitionVisitor`는 이 패턴을 적용하여, 각 `BeanDefinition` 객체에 대해 필요한 작업(예: 속성 값 변경, 프로퍼티 수정)을 수행합니다. 이는 빈의 구성을 프로그래매틱하게 변경할 수 있게 해주며, 런타임에 동적으로 빈의 설정을 변경하는 고급 사용 사례에서 유용합니다.

            이 클래스는 Spring의 내부 작업에 주로 사용되며, 사용자 정의 빈 처리 로직이나 Spring 확장 기능 개발 시에 중요한 역할을 합니다. Spring 컨테이너가 빈을 생성하고 관리하는 방식을 맞춤화하려는 경우에 특히 유용할 수 있습니다.
          ```
    - https://en.wikipedia.org/wiki/Visitor_pattern#
      - 어떤 문제를 해결하기 위한 패턴?
        - 클래스(element)에 변경없이 객체의 동작을 추가할수있게해줌
      - 어떻게 구현?
        - Visitor 객체를 통해 객체(element)의 동작을 구현한다
        - Element 객체에 방문자(Visitor)객체를 전달해주면, Element 객체는 방문자 객체에 동작(Element의 행동)을 디스패치(위임) 한다. 이런 방문자(accepted visitor)객체는 element에 따른 동작을 수행하게되는데, 이를 element에 방문(visit)했다고 표현하는듯 (visitor객체가 element의 값을 사용하고 동작을 수행하니 방문이라는 말이 괜찮은듯)
          - Clients traverse the object structure and call a dispatching operation accept (visitor) on an element — that "dispatches" (delegates) the request to the "accepted visitor object". The visitor object then performs the operation on the element ("visits the element").