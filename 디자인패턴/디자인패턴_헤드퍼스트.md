- 디자인원칙
  - 달라지는 부분과 달리지지않는 부분을 분리한다!
    - 달라지는 부분은 나머지에 영향을 주지않도록 "캡슐화"를 한다.
      - 이를 통해 나중에 바뀌지않는 부분에 영향을 미치지않고 변경되는부분만 고칠수있다!
  - 구현이 아닌, 인터페이스에 맞춰서 프로그래밍한다!
  - 상속보다는 구성을 활용한다
    - 구성이란 인스턴스변수에서 사용되는것..
    - 캡슐화가능(인터페이스화)
      - 그로인해 runtime간 동적으로 행동변경도 가능
      - 이는 기존 소스를 건드리지않기때문에 기존 코드에서 버그가 생기거나 의도치않은 부작용을 원천봉쇄할수있다
  - 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야한다  
    - 이래야 유연하고 변화에강하다!
  - OCP(Opne Close Principle) : 클래스는 확장에는 열려있고, 코드 변경에는 닫혀있어야한다 
    - 모든 부분에 이렇게 사용가능하지는않다! 그리고 이것을 적용하려하면 소스코드만 복잡해질뿐이다. 최대한 바뀔확률이 높은 부분을 중점적으로 살펴보고 원칙을 적용하는것이 좋다!
  - 의존성 뒤집기 원칙(Dependcy Inversion Principle)
    - 구상클래스에 의존하는것이 아닌(new 범벅..), 추상화된것에 의존하도록 만들기!  

- 스트레이티지 패턴 (DUCK)
  - 알고리즘군을 정의하고 이를 캡슐화하여 원하는 알고리즘(알고리즘군을 구성하는)을 교체할수있도록(동적으로도가능) 만들어주는 패턴
  - 간단한 정리
    - 변경이 자주 일어나는부분을 인터페이스화
    - 해당 인터페이스를 인스턴스 변수에 정의
    - 이를 구성하고 있는 추상클래스는 해당 인터페이스에 정의되어있는 함수를 실행해줌
    - 또한 동적으로 인스턴스를 변경할수있도록 setter 메소드를 활용
    - => 핵심은 "쉽게 확장/변경 가능하도록 캡슐화", "동적으로 확장/변경 가능"


- 옵저버 패턴 (기상정보 화면에 보여주기)
  - 한 객체(SUBJECT)의 상태가 바뀌면 해당 객체에 의존하는(Observer) 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식의 일대다 의존성을 정의하는 패턴
  - 간단한 정리
    - Subject를 Observer가 구독하는 개념
    - 즉, Subject 인터페이스의 구현부에는 Observer 인터페이스들을 가지고있어서, 특정 상태변화시 Observer들에게(이때, Observer가 구체적으로 어떤 놈인지는 모르는게 핵심) 특정 값을 전달해준다..
    - Observer는 구체적으로 어떤 놈인지 모르는데, 그렇기때문에 느슨한 결합이라할수있으며, 데이터를 noti받아서 Observer 구현부에서 각자의 행동에 맡게 데이터를 처리하면됨
    - Observer가 변경된다해서 Subejct가 변경이 필요하지않음!
  - Observable이라는 클래스가 자바에서는 제공되는데, 이를 통해서도 옵저버 패턴을 구현할수있다.
    - 그러나 이는 클래스를 상속받아서 진행되어야하므로(서브클래스가됨) 재사용하기에 어려움이있음
    - Observable은 상태변화를 지속적으로 Observable측에서 해줘야함..(noti하고나면 상태값이 false가 됨. setChanged 라는 메소드를 noti전에 호출해줘야함.. 이게 필요한 이유는 너무 자주 반복적으로 noti를 주는것을 막기위함이라함)
    - Observer가 Observable에게 데이터를 noti받으면 해당 데이터를 push방식으로 받기도하고 pull방식으로 받을수도잇음..
      - pull방식은 Observer 객체에 접근해서 데이터를 가져오는방식임..(즉, 변화되었다! 정도만 받고 실제 데이터를 객체를 통해서 가져감)
      - pull 방식이 더 "옳은"것으로 간주된다함

- 데코레이터 패턴 (스타벅스!)
  - 객체에 추가적인 요건을 동적으로 첨가하는 패턴(객체를 새로운것을 추가하여 장식해준다!). 데코레이터는 서브클래스를 만드는것을 통해서 기능을 유연하게 확장가능 
  - 인터페이스 바꾸지않고 책임(기능)만 추가됨!
  - 간단한 정리
    - 무언가 계속 추가되는(기존의 것에 얹어서)것이 있다면 데코레이터 패턴을 생각하라(기존 구상 클래스가 있는것을 없애는것이 아니다.. 기존 구상클래스에 새로운 무언가가 필요해서 덧붙이는것이다)
    - 구상 구성요소를 감싸는 데코레이터가 필요
    - 데코레이터가 전달받는 구상 구성요소의 super class와 데코레이터의 super class는 동일한 인터페이스를 구상한것이다
    - 데코레이터를 구현한 클래스의 인스턴스변수에는 데코레이터의 가장 추상화된 인스턴스(혹은 추상클래스)를 생성자로 전달받는다..(당연히 그래야지 넘겨받는 구상클래스에서 했던 내용에 추가할수있겠지..)
    - 데코레이터를 통해 새로운 기능을 더하여 장식하는 개념임
    - 가장 큰 장점은 기존 소스 건드리지않고 원하는기능을 추가해줄수있음!(기존 자바IO에서 모든 문자열을 소문자로 바꾸게하는 Wrapper클래스를 만들수있다!)
    - 데코레이터 패턴을 사용하면 자잘한 객체들이 매우 많이 추가될수있고(특히 그러다보면 중간에 필수적으러 넣어야할 구상객체를 놓칠수도있음..), 데코레이터를 너무 많이 사용하면 코드가 필요이상으로 복잡해진다!
      - 이런 부분을 보완해주는것이 팩토리패턴과 빌드패턴

- 팩토리패턴(PIZZA)
  - 팩토리 메소드패턴
    - 서브클래스에서 어떤 클래스를 만들지 결정하게함으로써, 객체 생성을 "캡슐화" 한다!(추상메소드를 통해서 구현단에서 객체생성하는 로직을 만든다)
    - 생성을 캡슐화하는것이지 생성한뒤에 하는 행동들은 동일하니께,, 리턴타입은 인터페이스로 정의하는게 당연 좋겠지..?
    - 간단한 정리
      - ***객체를 만들기위한*** 인스턴스를 정의하는것인데, 실제적으로 객체가 만들어지는곳은 ***서브클래스(구상클래스)***
      - new 는 다 공장(factory)에서 처리한다!
      - 인터페이스 안에 추상메소드를 만들어서 추상메소드 안에서 객체생성(new)!
  - 추상 팩토리 패턴
    - 서로 연관된 일련의 제품들을 만들어야할때 즉, 제품군을 만들때 사용
    - 필요한, 연관된 객체들을 모으는 개념..?
    - 객체 생성이 팩토리 인터페이스에서 선언한 메소드들에서 구현
  - => 둘다 객체 생성을 캡슐화하기 위한 것이며, 클라이언트와 구상클래스가 서로 분리된 유연한 디자인을 구현할수 있게 해준다..(직접 new 안쓴다는 말인듯..?)  


- 싱글턴 패턴
  - 어플리케이션 내에 유일무이한 인스턴스를 만드는 패턴 + 해당 인스턴스에 전역접근이 가능
  - 인스턴스를 직접만드는게 아니라, 요청하는개념!
  - 자바에서 design pattern에서 singleton패키지 내용참고!(순차적으로 설명해놓았음)
  - DCL 사용시 volatile 사용을 필수적으로 해야하는것에 관련한 설명
    - https://yeahhappyday.tistory.com/entry/singleton-%ED%8C%A8%ED%84%B4%EA%B3%BC-volatileDCLDouble-Checking-Locking

- 커맨드 패턴 (netty에서 겁나 많이쓰이는것 같음..)
  - 요구사항을 객체로 캡슐화 가능, 매개변수를 써서 여러 가지 다른 요구사항을 집어넣을수도있으며, 요청 내역을 큐에 저장하거나 로그로 기록할수도있으며, 작업 취소기능도 지원가능..
  - 간단한 정리
    - 인보커
      - 커맨더 인터페이스를 실행하는역할(커맨드 인터페이스를 ***구성***)
      - 커맨더를 통해서 리시버의 실행을 요청함
      - 중요한것은 커맨더로 무언가를 실행하는것은 알지만 구체적으로 무엇을 실행하는지는 인보커에서 알지못함
    - 커맨더
      - 일반적으로 execute함수만을 인터페이스로 가지며, 이를 구현하게되면 실제로 명령을 실행할 대상(리시버)을 execute함수내부에서 호출한다
	  - 추가적인 행동들이 필요한경우(ex. undo, store, load 등) 커맨드 인터페이스에 추가적인 행동들을 명시하여 구현하도록 하는것도 있으니 잘 알아둘것!
    - 리시버
      - 구체적으로 실행할 대상
	  - 커맨드 인터페이스를 ***구현***함
	- 메소드를 커맨드 객체로 캡슐화하는것!
	- 요청을 하는 객체와 그 요청을 수행하는 객체를 분리시키고 싶을때 사용하면된다!
	
- 어뎁터패턴
  - 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환하는 패턴. 어댑터를 이용하면 인터페이스 호환성 문제때문에 같이 쓸수 없는 클래스들을 연결해서 사용가능
  - 클라이언트에서 필요로하는 인터페이스로 적응 시키는것이 목적!(adapter!)  
  - 간단한 정리
    - 어뎁터 클래스는 타겟인터페이스로 ***구현*** 되고, 어뎁티 인터페이스를 ***구성*** 한다.(어뎁티되는 객체를 생성자나 메소드로 받아옴. 어뎁터가 어뎁티를 감싼다고 표현) 
	- 이를 통해, 클라이언트 입장에서는 타겟 인터페이스만 보고 실행하게되므로 어뎁터 내부의 동작은 신경쓸 필요가없다! 즉, 어뎁터 클래스로 연결해주는 작업이 있을뿐 기존 소스를 건드릴 필요는없다!

- 퍼사드
  - 인터페이스를 변경하는 패턴
  - 하나 이상의 클래스의 복잡한 인터페이스를 변경(즉, 퍼사드(외관)을 신경쓰는것)
  - 클라이언트에게 복잡한 서브시스템을 간단하게 제공하기위한 목적