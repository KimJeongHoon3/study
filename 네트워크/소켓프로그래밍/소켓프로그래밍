전제 : c언어, 리눅스


chapter02 - 소켓의 타입과 프로토콜의 설정

-프로토콜 : 데이터 송수신을 위한 약속!
-소켓생성시 3가지 파라미터를 넘겨줌 int socket(int domain, int type, int protocol)
	1번 파라미터) 소켓이 사용할 프로토콜 체계(protocol family) 정보전달
		-프로토콜의 상위개념(상위카테고리)으로 프로토콜 체계안에서 여러 프로토콜이 정의됨..
		-IPv6 인터넷 프로토콜체계, IPv4인터넷 프로토콜체계, 로컬통신을 위한 Unix프로토콜 체계, Low level소켓을 위한 프로토콜체계, IPX 노벨 프로토콜 체계 등
	2번 파라미터) 소켓타입 : 소켓의 데이터 전송방식을 의미
		-프로토콜체계안에 둘 이상의 데이터 전송방식을 지닌다..
		-IPv4인터넷 프로토콜체계의 데이터전송방식
			-연결지향형소켓 : 데이터를 잃지않는다.. 순서를 보장한다.. 데이터 송수신시 데이터 경계가없다..
				=> 신뢰성있는 순차적인 바이트 기반의 연결지향 데이터 전송방식의 소켓
				=> TCP 프로토콜로 연결되며 최종적으로 TCP 소켓이 생성(즉, 이후 3번째 파라미터는 1,2번 파라미터가 이렇게 정해져있다면 한개밖에없음)
			-비연결지향형소켓 : 데이터를 잃을수있다.. 순서 보장안한다.. 데이터 전달하는데 제한이있다..(아무래도 빨리 전달하는것이 목적이므로) 한번 write하면 해당 내용을 연결되거나 합쳐지지않고 그대로 read됨(데이터 송수신에 경계가있음!)
				=> 신뢰성과 순차적 데이터 전송을 보장하지않는, 고속의 데이터 전송을 목적으로 하는 소켓
				=> UDP 프로토콜로 연결되며 최종적으로 UDP 소켓이 생성(즉, 이후 3번째 파라미터는 1,2번 파라미터가 이렇게 정해져있다면 한개밖에없음)
	3번 파라미터) 프로토콜 : 최종적으로 소켓이 사용하게될 프로토콜을 정의..
	
chapter03 - 주소체계와 데이터 정렬


-port : 컴퓨터의 프로그램상에서 소켓을 구분하기위해 사용(16비트)
	-서버에서 반드시 하나만 사용이됨
	-TCP랑 UDP는 구분되어있음.. 즉, TCP에서 9000포트사용해도 UDP에 9000포트 사용가능
-인터넷 주소
	-IPv4 : 4바이트 주소체계.. 
		-네트워크주소 + 호스트주소
			-클래스A : 1byte의 네트워크ID + 3byte의 hostID (첫번재 비트가 항상 0으로 시작)
			-클래스B : 2byte의 네트워크ID + 2byte의 hostID (첫번째 비트가 10으로 시작)
			-클래스C : 3byte의 네트워크ID + 1byte의 hostID (첫번째 비트가 110으로 시작)
			-클래스D : 4바이트의 멀티캐스트 IP주소
			-클래스E : 예약되어있는 주소체계
			=> 네트워크ID를 먼저찾고(라우터), 라우터에서 hostID를 찾아줌.. 즉, 그냥 우리가 생각하는IP는 네트워크ID+hostID임
			*라우터는 외부로부터 데이터를 송수신하기위한 물리적장치.. 스위치랑 기능이 비슷한데 스위치는 라우터보다 제공하는 기능이 더 적은것뿐..
			
	-IPv6 : 16바이트 주소체계.. IPv4가 부족할까봐..
-CPU가 데이터를 메모리에 저장하는방식
	-빅 엔디안 : 작은 번지부터 큰 번지로 데이터를 순차적으로 저장
		-네트워크 바이트 순서로 지정
	-리틀 엔디안 : 큰 번지부터 작은번지로 데이터를 저장
		-AMD,인텔 CPU를 사용하면 리틀엔디안!
	*호스트 바이트 순서 : CPU의 데이터 저장방식을 의미
	*네트워크 바이트 순서 : 데이터를 전송할때 통일된 기준으로 데이터를 전송하기로 약속한것
	=> 빅 엔디안을 기본으로 사용한다면 굳이 순서를 변경할 필요가 없겠지만, 리틀 엔디안이라면 네트워크바이트순서인 빅 엔디안으로 정렬방식을 변경해주어야함..
	

chapter04 - TCP 기반 서버/클라이언트 1

OSI 7계층 / 인터넷계층(4계층)

(오른쪽으로 갈수록 하위 계층..)
Application계층 -> TCP/UDP계층(Transport계층) -> IP계층 -> Link 계층

이런계층이 생긴이유? : 인터넷을 토한 효율적인 데이터의 송수신을 위해서는 표준이 필요했다..! 그래서 개방형시스템(Open System)을 설계하여 표준화하였고, 이로인해 교체나 유지보수가 용이하다! 발전도 더 잘되고!

-Link 계층 : 데이터를 보내기 위한 물리적계층
-IP계층 : 데이터를 보내기위한 경로를 셋팅(Internet Protocol)
	-IP 자체는 비 연결지향적, 신뢰할수없는 프로토콜임..
-TCP/UDP 계층(Transport계층) : 데이터의 실제 송수신담당 계층,, 신뢰성, 비신뢰성을 결정
	-TCP: 신뢰성없는 IP에 신뢰성을 보장,, 여러 패킷이 들어오는것을 하나씩 확인해서 못받으면 재요청
	-UDP:
-Application 계층 : 사용자가 application사용을 위한 cli <-> server간의 약속을 정의해놓은 계층(이전 계층의 작업은 소켓이 알아서 책이져줌..ㅎ)

-server socket
	-socket -> bind -> listen ->  accept -> read/write
	-서버 소켓(client를 받는 문지기)을 통해서 accept(연결) 되면 해당주소를 가진 socket을 내부적으로 만들어주고, 이를 통해서 데이터를 송수신한다..
-client socket
	-socket -> connect -> read/write
	-소켓을 생성할때는 바드시 IP와 Port가 필요한데(어느놈한테 보내야할지를 알아야하니깐..) client소켓에는 별도로 지정하는 부분이 없다.. 이는 커널에서 알아서 ip와 port를 바인딩 해주기때문이다!!!
	
chapter05 - TCP 기반 서버/클라이언트 2
-TCP의 이론적인 이야기
	-입출력버퍼
		-write시 출력버퍼에 저장되고, read시 입력버퍼에 저장된것을 읽어온다.. 즉, 데이터 송수신시 출력버퍼에 있는 데이터를 상대방의 입력버퍼로, 상대방의 출력버퍼에있는것을 나의 입력버퍼로 전달되는것이다!
			-30바이트를 보냈는데, 10바이트씩 받았다면 처음 10바이트 받았을때 나머지 20바이트는 입력버퍼에 저장되어있음!
			-그래서 java에서는 write하고 flush를 해줘야 출력버퍼에있는 데이터가 넘어간다..
		-입출력 버퍼는 TCP 소켓 각각에 대해 별도로 존재..
		-입출력 버퍼는 소켓 생성시 자동 생성
		-소켓을 닫아도 출력버퍼는 남아있는데이터 다 보냄..
		-소켓 닫으면 입력버퍼 데이터 날아감
		-TCP에는 '슬라이딩 윈도우' 라는 프로토콜이 있어서 이를 통해서 내 입력버퍼가 얼마나 받을수있는지를 상대방과 지속되는 통신을 통해 전달하므로 버퍼에 차고넘치는 데이터를 받아서 없어지는 경우가 없다!
	-상대 소켓과의 연결시 이뤄지는 동작
		-three way handshaking : 3단계의 과정으로 이루어짐
			1) sync ( A (CLOSED) -> B (LISTEN) )  ex. SEQ:1000, ACK: -    => A가 B에게 자신의 SEQ를 SYNC하도록함 (ACK로 1001보내달라는것)
			2) sync + ack ( A (ESTABLISHED) <- B (SYNC_RCV) )  ex. SEQ:2000, ACK:1001   => B는 A에게 동기화되었다는 응답으로 1001을 보내고, 나도 동기화해달라고 SEQ에 2000을 보냄
			3) ack ( A (ESTABLISHED) -> B (ESTABLISHED) )  ex. SEQ:1001, ACK:2001   => A는 B에게 동기화되었다는 응답으로 2001을 보냄.. SEQ는 1001을 보내는데, 이는 앞서 보낸 1000보다 1증가한것.. (메세지 하나 새로 보낼때마다 적어도 하나씩은 증가하는듯)
	-상대 소켓과의 데이터 송수신시 이뤄지는 동작
		-ACK번호 -> SEQ번호+전송된바이트크기+1
			ex) A -> B - SEQ:1200, 100 byte data
			 A <- B - ACK:1301
			 A -> B - SEQ:1301, 100 byte data
			 A <- B - ACK:1402
			 
			 (ACK가 다음 보낼 SEQ를 보냄으로써 온전히 데이터를 신뢰성있게 잘 받았는지 확인해주는듯함)
			 
		-만일 ACK가 일정시간안에 없으면 timeout이 발생하고 다시 재요청을 진행한다
	-상대 소켓과의 연결종료시 이뤄지는 동작
		-상호간의 FIN메세지를 주고받고 종료가됨
		-four way handshaking : 4단계의 과정으로 이루어짐
			ex) A,B 모두 ESTABLISHED 상태 -> 이거 다시 정리해야할듯!?
				A(FIN_WAIT_1) -> B : FIN - SEQ 5000, ACK -
				A(FIN_WAIT_2) <- B(CLOSE_WAIT) : ACK - SEQ 7500, ACK 5001
				A(TIMEWAIT~~) <- B(LAST_ACK) : FIN - SEQ 7501, ACK 5001 (B가 응답한뒤에 FIN 메세지또한 보낸다)
				A(CLOSED) -> B(CLOSED - 얘가 먼저 closed 상태가 됨) : ACK - SEQ 5001, ACK 7502
		-ESTABLISHED인 클라이언트가 closesocket()를 호출하면 서버에 FIN패킷을 전송한다. 그리고 클라는 FIN_WAIT1상태가 된다. 
        ESTABLISHED인 서버가 FIN패킷을 받으면 클라에게 종료 요청 받았다는 ACK를 전송하면서 CLOSE_WAIT 상태가 된다. 
        CLOSE_WAIT상태가 된 서버는 종료에 필요한 처리를 진행하고, closesocket()을 호출하여 클라에 FIN을 전송한다. 서버는 LAST_ACK상태가 된다. 
        FIN_WAIT2인 클라가 FIN패킷을 받으면, 이에대한 ACK를 송신하고 세션종료를 준비하는 TIME_WAIT상태로 전환한다. 
        이 일반적인 종료과정이 4번의 데이터 송수신을 거쳐 진행되기 때문에 4-ways-handshake라고 불리기도 한다. 
        클라이언트 세션이 바로 종료하지 않고 TIME_WAIT상태에 돌입하여 잠시 대기하는 이유는 서버가 "FIN을 보내기 전에 전송한 패킷이 아직 도착하지 않은 경우에 대비"하기 위한 것이다. 
        네트워크 패킷이 전송순서대로 도착하지 않기 때문에 충분히 일어날 수 있는 경우이다. 이 경우에 바로 종료시켜 버린다면, 이 패킷의 데이터는 바로 유실된다. 
        유실을 막기 위하여 서버로 부터 FIN수신 이후에 일정시간동안 세션을 남겨서 잉여 패킷을 기다리는 단계가 TIME_WAIT 상태이다. 
        TIME_WAIT는 처음 종료 요청을 한 클라이언트가 종료하기 위해서 반드시 거쳐야하는 단계이다. 그리고 양쪽에서 종료처리를 하고 FIN을 전송해야 TIME_WAIT에 진입할 수 있다.
        - 4 way hand shake를 거치지않고 갑작스레 종료시(랜선이 끊키다던가..), 서버와 클라 모두 Recv나 Send 중이였다면, 상대의 ACK를 기다리고 Timeout되어 재전송 또는 재전송 요청을 반복하고있게된다..
            - 이에대한 해결책은 소켓의 tcp_keepalive 의 heartbeat 옵션을 주어 체크.. 그냥 어플리케이션단에서 heartbeat를 하는것도 좋을듯..
        - 설명 매우굿 : https://ozt88.tistory.com/m/19 
        - TIME-WAIT을 없애는 방법에 관련 설명 매우굿.. 논란정리도해줌 : https://sunyzero.tistory.com/m/198
        - LINGER 관련내용(https://velog.io/@jyongk/TCP-%EC%86%8C%EC%BC%93-%EC%98%B5%EC%85%98-SOLINGER)
            -l_onoff : Linger 옵션을 활성화 할것인지 비 활성화 할것인지에 대한 플래그
            -l_linger : Linger 옵션이 활성화 되었을 때 기다리는 시간
            -위 두개의 멤버변수의 값에 따라 다음 세 가지 close 방식이 결정되어집니다.
                l_onoff == 0 : 이것은 Linger를 비활성화 하겠다는 것으로 소켓의 default 값이다. 소켓버퍼에 남아있는 모든 데이터를 전송하는 일반적인 소켓의 정상 종료가 이루어집니다.
                l_onoff > 0 이고 l_linger == 0 : close가 즉시 리턴을 해서 상태가 종료 되고 소켓 버퍼에 남아있는 데이터를 버리는 비정상 종료가 이루어집니다. 만약 TCP 연결 상태일 경우에는 상대편 호스트에 리셋을 위한 RST 패킷을 보냅니다.
                l_onoff > 0 이고 l_linger > 0 : 지정한 시간동안 대기하고 버퍼에 남아있는 데이터를 모두 보냅니다. 지정된 시간 내에 데이터를 모두 보냈다면 정상적으로 리턴이 되고 시간이 초과되었다면 에러와 함께 리턴이 되는 방식으로 특정 조건에 따라 비정상 종료 혹은 정상 종료가 이루어집니다.
*****************************************
Q.TIME-WAIT은 왜 필요한가?
- 상대방측에서 아직 못받은 패킷을 받기위해 대기하기위함
- 최종 ACK를 상대방이 받지못하였을때, 다시 보낼수있도록 하기위함(만약, ACK를 받지못하고 끊어졌다가 내가 다시 해당 서버로 붙는다면, 해당 서버는 LAST-ACK 상태이기때문에, SYN를 보낼때 RST를 리턴해줌.. 연결안됨..)

Q.서버가 connection이 이루어질떄마다 로컬 포트를 따로 사용하는가?
- 서버가 할당하는 것은 포트가 아닌 "소켓"이며 서버의 포트는 최초 bind()시 하나만 사용한다. 로컬 포트를 할당하는 것은 클라이언트이며, 클라이언트가 connect()시 로컬 포트를 임의로(ephemeral port) 바인딩하면서 서버의 소켓과 연결된다.
    -소켓의 수는 설정된 리눅스 파일 디스크립터만큼 생성할 수 있다.

Q. 클라이언트에 TIME_WAIT 상태가 남아 있으며, 클라이언트의 로컬 포트가 고갈되고, 서버의 다른 포트에 접속할 경우, 연결이 가능한가?
- 3번은 문제가 없다. 앞서 언급했듯 소켓은 5개 유니크 값이며 맨 마지막이 <dest port> 이다. 이 말은 포트가 다를 경우 다시 그만큼의 새로운 소켓 쌍을 만들어낼 수 있음을 뜻한다. 재사용이 필요 없다.
    -동일한 로컬 포트에 하나는 TIME_WAIT, 하나는 ESTABLISHED 상태가 가능하다. 상대방 포트는 다르기 때문에 이렇게 동일한 로컬 포트를 함께 쓰는게 가능하다. 같은 원리로 서버도 하나의 포트에 여러개의 소켓이 할당된다.(클라에서 하는 작업은 동일하겠지..)

수 많은 잘못된 정보들 사이에서 아래와 같은 올바른 정보를 반드시 기억해두길 바란다.
1. TIME_WAIT의 타임아웃은 60초로 하드 코딩되어 있다. 설정할 수 없다.
2. 다수의 TIME_WAIT이 서버 성능을 저하시킨다는 논문5은 1997년에 출판됐다. 지금은 2016년이다. 20년이 지났다.
3. 클라이언트가 서버 투 서버로 한 서버에 요청이 많을 경우 tcp_tw_reuse 옵션을 설정해 TIME_WAIT을 재사용하도록 한다. 서버는 해당 사항이 없다.
4. 오래된 서버인 경우 클라이언트가 서버 투 서버 통신을 많이 한다면 빈 포트 스캔으로 성능 저하가 발생하므로 마찬가지로 tcp_tw_reuse 옵션을 설정한다.
5. tcp_tw_reuse와 SO_REUSEADDR는 서로 다른 소켓에 적용되는 옵션이다.
6. 서버/클라이언트 모두 tcp_timestamps가 기본값인 켜져 있어야 하며, 끄면 안되고 끌 필요도 없다.
7. net.ipv4.tcp_fin_timeout은 90 정도로 설정한다.
8. FIN_WAIT1은 상대방 OS에 문제가 있는 경우다.
9. FIN_WAIT2는 상대방 어플리케이션에 문제가 있는 경우다.
10. FIN_WAIT2는 TIME_WAIT의 역할을 대행한다.
11. 특수한 경우가 아니면 링거 옵션은 사용하지 않는다.
12. 서버가 클라이언트를 accept() 할때 할당하는 것은 소켓이다. 포트가 아니다.
13. 소켓의 최대 갯수는 65,535개가 아니다. 소켓은 <protocol>, <src addr>, <src port>, <dest addr>, <dest port> 5개의 값으로 유니크하게 구성되며, 서버 포트 또는 클라이언트의 IP가 추가될 경우 그 만큼의 새로운 쌍을 생성할 수 있다.

-서버가 클라이언트를 관리하는 방식은 크게 4가지로 구분할 수 있다. 
1.요청 당 프로세스 할당, fork()로 자식 프로세스를 만들어 클라이언트를 담당한다. 전통적인 blocking I/O 방식이다.
2.요청 당 쓰레드 할당. 위 예제에서 사용한 방식으로 pthread_create()를 통해 쓰레드를 생성, 클라이언트를. 담당한다. 마찬가지로 blocking I/O 방식이다.
3.쓰레드풀을 구성해 각각의 쓰레드가 여러 커넥션을 asynchronous I/O 방식으로 담당한다.
4.쓰레드풀을 구성해 각각의 쓰레드가 여러 커넥션을 select(), poll(), nonblocking I/O 같은 이벤트 기반 방식으로 담당한다.
이 중 대용량 처리에 3, 4번이 우세하며 특히 4번이 대세이다.

위에 대한 출처 - 상당히 신뢰도 높은정보 : https://docs.likejazz.com/time-wait/#:~:text=TIME_WAIT%20%EC%83%81%ED%83%9C%EA%B0%80%20%EC%99%9C%20%ED%95%84%EC%9A%94,%ED%95%B4%20%EB%AC%B8%EC%A0%9C%EA%B0%80%20%EB%B0%9C%EC%83%9D%ED%95%9C%EB%8B%A4.
	
*****************************************

chapter06 - UDP 기반 서버/클라이언트
-UDP특성
	-흐름제어x => 신뢰성 떨어짐 ,, 그러나 생각만큼 데이터 손실 많지않음
		-흐름제어를 별도로 하지않는다는것은 데이터 송신하고 더이상 신경안쓴다는것... SEQ나 이런것도 신경안씀..
	-데이터의 경계가 있음
	-일반적으로 TCP보다 속도가 빠르나, TCP또한 송수신하는 데이터의 양이 크면 클수록 속도가 UDP 못지않다
	-편지와같음!
		-우체통하나로 편지를 보내기도하고 편지를 받기도함.. 편지를 보낼때 수신자가 완전히 받았는지는 확인이안됨..
-UDP동작의 원리
	-IP로 위치를 파악했다면 해당 UDP 소켓으로 전송하기위해서 해당 Port로 연결시켜주는것은 UDP의 역할이다.. 
-UDP의 효율적 사용
	-데이터 양이 적고 잦은 연결이 필요하다면 사용하는것이좋음
		-잦은연결시 TCP사용하게되면, 많은 비용이발생(연결,해제시의 흐름제어..)
	-압축파일과같은 하나라도 손실되어서는 안되는것이 아닌, 스트리밍같은것은 좋음
-UDP에서는 서버건 클라이언트건 하나의 소켓만 있으면된다!
-UDP소켓은 연결상태를 유지하지않는다
	-데이터를 전송할때 목적지 주소를 항상같이 넘겨줌.. 
-UDP소켓을 열때 포트번호를 bind하지않으면, 데이터를 보낼때(sendto함수 호출시) 사용하지않는 port를 알아서 할당해줌..
-UDP는 데이터 경계가 있기때문에 sendto한 횟수와 recvFrom 한 횟수와 동일해야함.. 
-unconnected udp소켓
	-sendto 함수 호출시 아래와 같은 순서로 동작
		-1단계 : UDP 소켓에 목적지의 IP와 PORT번호 등록
		-2단계 : 데이터 전송 
		-3단계 : UDP 소켓에 등록된 목적지 정보 삭제
-connected udp소켓
	-목적지에 대한 정보를 등록(connect함수)
		-여기서 connect는 연결설정과정을 거치는것이아니라, 그냥 목적지의 IP와 PORT가 등록되는것일뿐!
	-sendto 함수나 recvFrom을 사용하지않고 write와 read함수를 사용(목적지를 등록해놨기때문에 계속 파라미터로 주소 안넘겨도되니깐)
	-unconnected의 1,3단계를 pass,, 1/3정도 속도 증가!

chapter07 - 소켓의 우아한 연결종료
-소켓이 연결되면 두개의 스트림(일방적으로 흐르는 흐름)이 생기게된다. 입력버퍼에 데이터를 전달받는 스트림, 출력버퍼의 데이터를 전달하는 스트림
-half-close
	-두개의 스트림을 모두 끊는것이아닌 하나만(절반만) 끊는것
	-소켓을 그냥 close하게되면 두개의 스트림이 바로 끊어지게된다.. 그래서 우아한종료를 위해 half-close가 필요!
	
chapter08 - 도메인 이름과 인터넷 주소
-IP주소와 도메인 이름 사이에서의 변환을 수행하는 시스템이 DNS(Domain name system)이다.
-모든 컴퓨터에는 디폴트 DNS 서버의 주소가 등록되어있고, 도메인으로 요청하면 디폴트 DNS서버가 IP주소를 찾아서 연결해줌!
	-만약 디폴트 DNS서버에 IP를 찾을수없다면 상위의 DNS Server로 계속 올라가면서 IP주소를 찾는다! 즉, DNS는 계층적으로 관리되는 일종의 분산 데이터베이스 시스템이다
-하나의 DNS에는 여러개의 IP주소가 있을수 있다.. 이는 서버분산을 위해서 사용된다!



chapter 09 소켓의 다양한 옵션
    -소켓 타입(TCP or UDP)은 한번 지정하면 바꿀수없다!
    -운영체제가 핸들링하는 입출력 버퍼는 사용자가 요청한 값대로 정확히 변경안될수있다!! 입출력버퍼는 상당히 중요한 영역이기 때문에 내부적으로 알아서 처리해주는 부분이 있다! 우리가 요청하는것은 요구사항을 전달하는것이고 이를 반영하여 내부적으로 처리한다 보면됨!!
    -REUSEADDR
        -서버가 문제가 생겨서 갑작스레 종료되었을때 TIME-WAIT 상태가되면 포트가 이미 점유되어있기때문에 재실행이 불가능! 이를 해결하기위한 옵션이다!(재사용하겠따!)
            -클라이언트쪽에는 문제가안되는게,, 포트를 지정해서 연결하지않기때문!
        *TIME-WAIT : 소켓 종료시 four-way-handshake를 거치게 되는데, 먼저 종료를 실행한 쪽에 TIME-WAIT이 생긴다. 왜냐하면 상대방의 FIN메세지에 응답하기 위해서이다..! 만약 상대방의 FIN메세지를 받지 못해서 응답을 못했을때 상대방은 다시 FIN을 보낼것이다.. 그러면서 계속 ACK를 하염없이 기다릴것이다. 이를 막기위해서 일정시간 기다림을(time wait) 통해서 마지막 ACK를 해주기위함이다
        
        참고사이트 : TCP의 TIME_WAIT를 없애는 법 - https://sunyzero.tistory.com/m/198

        -참고로 리눅스에서 net.ipv4.tcp_timestamps가 켜져있어야 REUSEADDR 옵션이 먹힘..
    -TCP_NODELAY
        -Nagle 알고리즘 : ACK메세지 받아야 다음데이터 보낸느것
            -이를 사용하지않으면, 출력버퍼에서 들어오자마자 바로바로 보내기 떄문에 이에 따르는 헤더의 비용(수십바이트)이 발생함,, 그로인해 트래픽에 대한 부하가 있다
            -용량이 큰 파일의 데이터 전송에 있어서는 출력버퍼를 빠르게 채워서 한꺼번에 전송하기 때문에 알고리즘 적용안하는게 유리!!


chapter 10 멀티프로세스 기반의 서버구현
    -멀티프로세스 기반 : 다수의 프로세스를 생성하는 방식으로 서비스제공
    -멀티 플렉싱 기반 : 입출력 대상을 묶어서 관리하는 방식으로 서비스제공
    -멀티 쓰레딩 기반 : 클라이언트의 수만큼 스레드를 생성하는 방식으로 서비스제공

    -프로세스 : 메모리 공간을 차지한 상태에서 실행중인 프로그램
        -하나의 프로그램 실행에 여러 프로세스가 생성되기도함. 

chapter 11 프로세스간 통신(Inter Process Communication)
    -운영체제가 제공해주는 "파이프"라는것을 통해서 통신가능

chapter 12 IO 멀티플렉싱
    -다중 클라이언트 접속시 멀티 프로세스방법으로 IPC가 필요한 상황을 해결하기위해 대안으로 사용..
    -하나의 프로세스를 가지고 여러 클라이언트와 데이터 송수신 가능!
    -멀티플렉싱 서버는 클라이언트 소켓이 이벤트발생하면 처리하는방식..
    -select
        -감시해야할 파일디스크립터(소켓)를 select 함수를 통하여 등록하여(Os에 등록하는거겠지..?) 소켓에 이벤트가 발생하면 디스크립터를 하나하나씩 확인해나가면서 이벤트 발생한것을 찾아서 처리한다.. (read이벤트, write이벤트, error이벤트,, 이렇게 3가지 등록가능)
        -이벤트발생하면 바로 어떤 소켓이 무슨 이벤트 변화가 나타났는지 알아차리는것이아니라 다 일일이 루프를 돌면서 찾아서 일한다.. 그러니깐 당연히 성능떨어지겟지..
            => 이에 대한 해결책은 추후 다시 나오니 그때 발견하면 정리하자..
            

chapter 13 다양한 입출력 함수들
    -데이터를 읽을때 버퍼에 메세지를 그대로 남겨둘수도있고(MSG_PEEK 옵션), 이에 더해 데이터가 없을떄 블럭되지않도록(MSG_DONTWAIT 옵션) 을 같이 사용한다
    -출력버퍼에 데이터를 쓸때나 입력버퍼에서 데이터를 읽을때 어느정도 채워서 보낼수도있다.. 이렇게 데이터를 모아서 쓴다면 nagle 알고리즘을 사용하지 않는것이 유리!!
    *offset : 기본이 되는 위치를 바탕으로 상대적 위치를 표현하는 것이 오프셋..

chapter 14 멀티캐스트 & 브로드캐스트
    -멀티 캐스트
        -UDP 기반
        -멀티캐스트 그룹을 대상으로 데이터를 전송하면 멀티캐스트 그룹에 속한 대상은 다 받게됨
        -멀티캐스트 그룹의 수는 IP주소 범위 내에서 얼마든지 추가가능
        -멀티캐스트 그룹은 클래스D에 속하는 IP주소(224.0.0.0~239.255.255.255)
        -하나의 데이터를 라우터가 복사해서 멀티캐스트 그룹에 속해잇는 클라에게 뿌려줌
        -기존에 클라이언트에게 1:1로 전달해주는것보단 특정 라우터 그룹에 속해잇는 클라에게 전송하는것이 트래픽 측면에서 확실히 장점은 잇으나, 라우터가 멀티캐스트 그룹에 속해잇는 클라만큼 복사를 하기때문에 트래픽상에서 부담이 있는것은 사실..! 그래서 의도적으로 라우터에 멀티캐스트 안되게 막아놓기도한다함..
        -TTL 이라는것을 설정해주어야함
            *TTL(Time to live) : 패킷을 얼마나 멀리 전달할것인지를 설정하는것으로, 라우터를 거칠때마다 1씩 감소한다.. 끙까.. 만약 멀리 보내야한다면 TTL의 숫자가 커야겟지만 너무 커지면 트래픽에 좋지못한 영향을 줄수있다...
    -브로드 캐스트
        -UDP 기반
        -서로 다른 네트워크 상이라도해도 멀티캐슽느 그룹에 가입만 되어잇으면 데이터 송수신이 가능한 멀티캐스트와 달리, 브로드 캐스트는 동일한 네트워크로 연결되어있는 호스트로만 전송할수있음..(한마디로 같은 네트워크 상에 있는 놈들한테만 보낼수있다!)
        -direct 브로드캐스트 : 특정 네트워크에 브로드캐스트 x.x.x.255
        -local 브로드캐스트 : 내가 속한 네트워크에 브로드캐스트 255.255.255.255
    
****** 리눅스 기반 프로그래밍 ******
chapter 15 소켓과 표준입출력
    -표준입출력 함수 : C에서 제공해주는, 모든 운영체제에서 지원하는 함수 (표준입출력함수를 통해서 OS영역에 속하는 입출력 소켓 버퍼에 direct로 접근x => 입출력소켓버퍼에 다이렉트로 접근하는것은 시스템함수를 사용!)
        -이식성이 좋음
        -버퍼링을 통한 성능향상에 도움이됨
            - 서버 <=> 입출력함수 버퍼 <=> 소켓버퍼 <=> 클라
                -입출력함수버퍼는 "성능향상"을 목적
                    -어떻게 성능향상? => 이는 지속적으로 한 바이트씩 쪼개서 보내는것보다 한꺼번에 보내는것이 속도와 트래픽측면에서 훨씬이득! 동일한 양의 데이터를 10번왓다갓다리하는것보다 한번이 당연 낫겟지!
                -소켓버퍼는 "TCP사용"을 목적

chapter 16 입출력 스트림의 분리에 대한 나머지 이야기

chapter 17 select 보다 나은 epoll
    -전통적인 IO 멀티플렉싱 방법으로 select가 있으나, 성능적인 아쉬움으로 리눅스 epoll, BSD의 kqueue, 솔라리스의 /dev/poll, 윈도우의 IOCP 가 대안이되었다!
    -기존 select 같은경우는 select함수호출할때마다 ""운영체제에 관찰대상을 전달""해주어야했다.. 이것이 성능에 큰 영향을 미쳤다.. 이를 해결하기위해서 epoll을 도입!
    -epoll은 운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려주고 관찰대상의 범위, 또는 내용 변경이 있을때 변경사항만 알려준다!
        -이로인해 전체 파일 디스크립터를 대상으로 어떤놈이 변경이 일어났는지 루프돌면서 확인하는 작업 필요업슴
        -관찰대상의 정보를 매번 보낼필요도없음!
    -epoll 동작방식
        1. epoll_create
            -관찰대상인 파일디스크립터를 저장할 저장소 생성(epoll 인스턴스라함.. 운영체제에 요청)
        2. Epoll-ctl
            -관찰대상인 파일디스크립터를 추가/삭제
        3. epoll_wait
	    -파일디스크립터의 변화를 전달받는 함수
            -해당 함수를 호출할때 epoll_event라는 구조체를 인자로 넘겨주는데, 여기에 상태변화가 발생한 파일디스크립터만 묶여서 전달됨 
    -이벤트 발생시점에 따른 방식
        -레벨트리거 : 입력버퍼에 데이터 남아있으면 계속 이벤트 발생
        -엣지트리거 : 입력버퍼에 데이터 남아있어도 딱 한번만 이벤트 발생
            -소켓nonblocking & errno전역변수셋팅 필요!!
            -이벤트가 한번발생하기때문에 이벤트발생했으면 데이터를 다 읽을때까지 read함수를 계속 호출해줘야한다..
            -그리고 read함수 호출했을때 block이되면 더이상 진행안되므로 nonblock으로 되어야하고
            -errno가 eagain이면 더이상 읽을 데이터가 없다는것이기때문에 read하는 루프에서 빠져나와 다시 epoll_wait 호출하러 가야한다
                -EAGAIN은 상수값이며, errorno는 error.h 헤더파일을 포함시켜서 접근할수잇는 변수이다.. (errorno는 리눅스에서 에러발생시 추가적인 정보제공을 해줌..)
        => 엣지트리거가 데이터의 수신과 데이터가 처리되는 시점을 분리하기에 좋다! 그리고 성능상에서도 소켓에 데이터 남아있다해서 이벤트를 계속 받는것이아니라 한번만 받고 루프에서 처리하기때문에 속도도 좀더 빠를수있다..(항상그렇진않을수있다.. 데이터 양에따라..?)
            -동시에 A,B,C 소켓으로부터 전달받은 데이터를 다른 한명의 client에게 전달해야한다고할때, A로부터 받은 데이터, B로부터받은 데이터, C로부터받은 데이터들을 온전히 하나씩 전달해줄수있다.. 엣지트리거는 소켓에서 데이터를 읽어올때, 입력버퍼에 데이터가 얼마 남아있던지 상관없이 딱 한번만 이벤트가 발생하기에 위의 설명대로 해당 소켓의 데이터를 루프를 통해 계속 읽어내려간다. 반면, 레벨트리거는 소켓의 입력버퍼를 다 읽지않아도 이벤트가 다시 등록되어서 계속읽게되니 A,B,C 소켓으로부터 온전한 데이터를 보내지않고 짜잘하게 섞여서 client에게로 데이터를 보낼수있다..(즉, 레벨트리거로는 데이터의 수신과 처리를 분리하기가 어렵다..)
            
            

chapter 18 멀티스레드 기반의 서버구현
    -프로세스 : 운영체제 관점에서 별도의 실행흐름을 구성하는 단위
    -스레드 : 프로세스 관점에서 별도의 실행흐름을 구성하는 단위
        -join 함수 : 스레드 종료시 까지 기다리도록함(block 되어있음)
        -임계영역에 대한 처리가 필요 
            *임계영역 : 둘 이상의 스레드가 접근하면 문제가 일어날수잇는 영역
            => 스레드 안전에 유의하라!
            => CPU에서 정의한 처리가 아주 이상적으 다 끝나기 전에 다른 스레드가 실행될수있음,, 그렇기때문에 공유되는 영역에서 예상한 결과값이 안나올수있음..
            => 동기화!
        -동기화
            -동기화가 필요한 상황
                -동일한 메모리 영역으로서의 동시접근이 발생하는 상황
                -동일한 메모리 영역에 접근하는 쓰레드의 실행순서를 지정해야하는 상황
            -동기화기법
                -뮤텍스 : lock을 호출하였을때 이미 lock이 되어있다면 unlock이 될때까지 기다렸다가 unlock이 호출되면 실행
                -세마포어 : 0과 1을 왓다갓다함.. 0이면 block, 1이면 진행


    -멀티 프로세스의 문제점을 해결하기 위해서 멀티스레드 사용

        -멀티 프로세스의 문제점
            -프로세스 생성이라는 부담스러운 작업과정
            -두 프로세스 사이에서의 데이터 교환을 위해서는 별도의 IPC 기법을 적용해야함
            -초당 적게는 수십번에서 많게는 수천번까지 일어나는 '컨텍스트 스위칭' (이게 젤 문제)
            *컨텍스트 스위칭 : 메인메모리에서 프로세스를 바꾸는것!(자세한것은 "multiProcess_multiThread_contextSwitchin" 참고)
            -데이터 영역, 힙 영역, 스택영역이 모두 복사가된다.. 컨텍스트스위칭때 그만큼 비용이 많이듬..
        -멀티 스레드의 장점
            -스레드의 생성 및 컨텍스트 스위칭은 프로세스의 생성 및 컨텍스트 스위칭보다 빠르다
            -스레드 사이에서의 데이터 교환에는 특별한 기법이 필요없다
            -데이터 영역, 힙영역은 공유하고 스택영역만 생성하므로 컨텍스트 스위칭시 데이터 영역과 힙영역 올릴필요없음
            -공유 하는 데이터영역과 힙영역을 사용하여 데이터를 교환 가능
        

****** 윈도우 기반 프로그래밍 ******

chapter 19 windows에서의 쓰레드 사용 
    -커널 오브젝트 : 프로세스, 스레드, 파일, 세마포어, 뮤텍스 등등 운영체제가 만드는것들(프로그래머의 호출에 의해)은 운영체제의 관리를 목적으로 정보를 기록하기 위해 내부적으로 데이터 블럭을 생허나는데, 이것이 커널 오브젝트! 운영체제가 소유함!! 유형에 따라 커널 오브젝트가 다르다!
        -소유가 운영체제라는것은 생성,관리, 소멸시점 모두가 운영체제 몫이라는것!
        -커널 오브젝트를 구분하는 Handle이 있다.(handle은 정수형태)
        -커널 오브젝트는 리소스의 성격에 따라 많은 정보가 담기는데, 그중에 "상태"라는것이 중요하다
            -종료된 상태를 가리켜 signaled 상태 ,, 이벤트가 발생했을때를 이야기하기도함
            -종료되지않은 상태를 가리켜 non-signaled 상태 ,, 처음 생성되어 초기상태라 이야기하기도함
            => 커널 오브젝트가 어떤 상태인지를 물어서 signaled상태가 된것을 자동으로 nonsignaled 상태로 전환(auto-reset모드라함) 하기도하고 반대로 수동으로 non-signaled 상태로 전환하기도함(manual-reset모드) 

chapter 20 windows에서의 쓰레드 동기화
    -윈도우 운영체제의 연산방식(프로그램 실행방식)을 가리켜 이중모드 연산방식이라함.. 왜냐하면 윈도우에는 두가지 모드가 존재하기때문
        -유저모드 : 응용프로그램이 실행되는 기본모드,, 물리적인 영역으로의 접근이 허용되지않으며, 접근할 수 있는 메모리 영역에도 제한이 따름 => 응용프로그램의 실행모드
        -커널모드 : 운영체제가 실행될 떄의 모드로, 메모리뿐만 아니라, 하드웨어의 접근에도 제한이 따르지않는다.. => 운영체제의 실행모드
        -유저모드와 커널모드를 오가며 실행하게된다! 예를들어 스레드의 생성요청은 프로그램상의 함수(유저모드)에서 실행되지만, 실제로 스레드를 생성하는것은 운영체제이다(커널모드)
            -왜이리 두가지로정의?
                => 안정성을위해! 커널모드에서 작용하는것은 유저모드에서 다 가능하게 되엇을때 실수로 잘못건들면 운영체제에 심각한 문제가 생길수있기때문에!!
            -이렇게 모드가 변환되는것을 모드 스위칭이라함!
                -컨텍스트 스위칭을 하기위해서는 모드 스위칭이 반드시 수반된다! 왜냐면 컨텍스트 스위칭하는곳이 커널쪽에서 진행하기때문이다! 

                참고 : https://daehee87.tistory.com/473
    
    -유저모드 동기화 : 운영체제의 도움없이 응용프로그램상에서 진행되기때문에 속도가 빠르다.. but 기능은제한적..
        -CRITICAL_SECTION 오브젝트라는것을 생성해서 동기화(mutex랑 사용방법동일)
    -커널모드 동기화 : 제공하는 기능이 겁나많음! 서로 다른 프로세스에 포함되어있는 두 쓰레드간의 동기화도 가능! but 커널모드에서 다시 유저모드로의 빈번한 변환이 불가피..
        -Event(manual-reset,auto-reset 선택가능), 세마포어(autu-reset), 뮤텍스(auto-reset)

chapter 21 Aysnchronous Notification IO 모델
    -동기 : 함수 콜하고 콜한 목적에 맞추어 Return 값을 받을때까지 한없이 기다림
    -비동기 : 함수콜하고 바로 Return, 완료되엇는지는 완료되었을때 알수있음.. 비동기는 block되지않으니 cpu를 효율적으로 사용가능
    -대표적인 synchronous notification io는 select 이다 (IO의 상태변화알리는것!)
        -notification io란 IO관련해서 특정 상황이 발생했음을 알리는것을 이야기한다.(데이터가 입력버퍼에 들어왔으니 읽어라! Or 출력버퍼에 데이터를 모두 썼으니 데이터 전송할수있다!)
        -select은 관찰대상의 상태변화가 있으면(ex.데이터수신) 움직인다!(그렇지 않으면 block!)
        -select는 동기방식이기에, 비동기용이 나오게되었는데, 그것이 WSAEventSelect
        -asynchronous notification io는 그니깐 관찰대상을 OS에게 지정한뒤에, 내 할일하다가 관찰대상의 상태변화가 잇었는지 확인하는 방식이다! 그래서 함수도 나눠줘있다!(관찰대상지정 / 관찰대상상태확인)
    -WSAEventSelect
        -운영체제에 소켓정보가 등록되기때문에 기존 select과 다르게 함수의 재호출필요없음
        -소켓과 eventobject를 연결하여(이게 운영체제에 등록되는것) eventObject가 어떤 상태가되었는지를 확인하면서 로직을처리!


chapter 22 Overlapped IO 모델
    -해당 챕터는 비동기 notification이 아닌, IO를 비동기로 처리하는것!
    -하나의 스레드 내에서 동시에 둘 이상의 영역으로 데이터를 전송(또는 수신)함으로 인해서, 입출력이 중첩되는 상황을 가리켜 IO 중첩이라한다!
    -이에 대한 핵심은 비동기IO! =>호출되는 입출력 함수는 non-blocking이어야함!
    -overlapped IO == 비동기 IO
        -비동기 IO + 입출력 완료의 확인(callbackt사용)까지!

chapter 23 IOCP(Input Output Completion Port) 
    => IOCP는 서버소켓이 클라를 받는것과, 받은 클라들의 IO결과들을 가지고 처리하는 로직을 분리할수 있다.. 그리고 모든 구간이 비동기로 이루어지기때문에 지체구간이없어서 상당히 빠른 속도를 보일수있다!
    1) CP(Completion Port) 오브젝트 생성 (해당 소켓을 기반으로 진행되는 IO의 완료상황을 등록해주는곳)
    2) CP 오브젝트와 소켓 연결     
    3) CP 오브젝트의 결과를 확인하는 함수호출을 통해서 소켓의정보, 입출력 데이터 & rwmode (이는 구조체에서 만들어줘야함) 들을 가져올수있다
    
    *select 모델과 비교했을때 차이점
        -넌블로킹 방식IO 이기 때문에 IO작업으로인한 시간의 지연이 발생하지않는다
        -IO가 완료된 핸들을 찾기위해 반복문 구성 x
        -IO의 진행대상인 소켓의 핸들을 배열에 저장해놓고, 관리할 필요없음
        -IO의 처리를 위한 스레드의 수를 조절가능!(IO처리에 대한 더 빠른 속도보장..  + serversocket이 클라이언트 연결하는 스레드와 IO처리하는 스레드를 분리)
        
