도메인 주도설계 철저입문
- 1장 도메인주도설계란?
  - 도메인 지식에 초점을 맞춘 설계 기법
    - 도메인 : 프로그램이 쓰이는 대상이 되는 분야 (영역)
    - 지식 : 소프트웨어 이용자의 문제 이해
  - 도메인 모델링?
    - 도메인 모델을 만드는 과정
      - 모델 : 현실에서 일어나는 사건이나 개념을 추상화한것
        - 추상 : 공통적인것을 뽑아 파악하는것 (현실의 모든것 반영 X)
      - 즉, 프로그램으로 쓰는 대상에서 일어나는 사건과 개념들 중에 공통적인 것을 뽑아내는것인데, 프로그래밍화 하기위해서는 필요한 정보로 한정해야한다
  - 도메인 객체?
    - 도메인 모델을 소프트웨어 형태의 동작하는 모듈로 나타낸것
    - 도메인 객체의 중요한 점은 진정 이 모델이 이용자 문제해결을 가능하게해주는, 그래서 객체로 만들 필요가 있는지 분별해야한다!
    - 도메인 개념 <-> 도메인 모델 <-> 도메인객체
      - 이렇게 서로 상호작용하며 피드백을 한다
  - 도메인 주도설계에서 패턴이란?
    - 도메인 지식을 설명하기위한것
      - 값 객체
      - 엔티티
      - 도메인 서비스
      - 애그리게이트
      - 명세
    - 어플리케이션을 구성하기위한것     
      - 리포지토리
      - 애플리케이션 서비스
      - 팩토리
- 2장 시스템 특유의 값을 나타내기 위한 값 객체
  - 값 객체?
    - 객체이지만, 원시타입처럼 여겨져야한다..
    - 불변객체!  
    - 값의 성질
      - 변하지않는다
        - 장점
          - 병렬처리에서 유리
            - 값이 변하는 상황을 고려하지않아도됨
          - 불변이니 캐싱해서 사용하여 접근성이나 메모리 관리에 이점
        - 단점
          - 일부 값만 바꾸고 싶을때 객체를 아예 새로 생성해야함..
          - 그렇기때문에 특정부분은 상태를 바꿀수있는 전략도 씀
      - 주고받을 수 있다
      - 등가성을 비교할 수 있다.
        - 객체의 속성을 통해 비교한다..(equals 나 hashcode 오버라이딩)
  - 이런 점을 고려하였을때 *불변객체* 기반으로 만들자
  - 값 객체가 되기 위한 기준?
    - 규칙이 존재하는가?
    - 낱개로 다루어야하는가?
    - ex) 성명 이라는 도메인에는 성과 이름이 속성으로 구성될때, 성명은 규칙이 존재하며, 낱개로 다루어야하니깐 값객체가 맞지만, 성명이라는 도메인의 성과 이름은 규칙이 존재한다고 보기 쉽지않고 낱개로 다룰 필요가 없기에(물론, 요구사항에 따라 다를 순 있지만..) 원시타입(String)으로 할수있다
      - 이 책의 필자는 c#을 쓰고있는데, string이 원시타입인듯.. (물론 자바도 String은 원시타입처럼 사용됨..)
  - 값 객체는 *독자적인 행위를 정의할 수 있다*
    - 값 객체는.. 단순한 데이터 구조체가 아니다
    - 객체이므로 행동이 정의가능하고.. 그렇기에 데이터(속성)에 대한 규칙과 같은 행동을 정의할 수 있다
    - 이를 통해서 데이터에 대한 행동을 한곳에 모아두고, 자신만의 규칙을 갖는 도메인 객체가 된다
    - 그리고 값 객체(도메인 객체)에 정의된 내용을 보고 이 도메인 객체가 어떤일을 할 수 있고, 어떤일을 할 수 없는 놈인지도 파악이 가능하다
  - 값 객체를 도입했을때 장점
    - *표현력증가*
      - 무얼하는놈인지에대한 정보를 제공
      - 코드 자체가 문서의 역할
    - 무결성 유지 (integrity 이상한 데이터 들어오는거 막음)
      - 값 객체를 통해서 제약사항을 정의할수있음
      - ex) 이름에 3글자 이상은 에러 
    - 잘못된 대입을 방지
      - 값 객체를 사용하기에 타입검증가능(컴파일러가 잡아줌 - java)
      - ex) User라는 도메인 모델에 UserId와 UserName이 속성으로 가지고있다면, 그냥 String이 아닌, UserId나 UserName 타입을 전달해줘야하니.. 실수줄일수있음
    - 로직이 코드 이곳저곳 흩어지는것을 방지
      - 중복코드를 방지할수있음
      - ex) User의 userName의 3글자 이상으로 정의해야하는 제약사항이 있을때, 도메인 객체에서 이를 정의해놓으면 해당 제약사항의 변경이 있을때 도메인 객체만 고치면된다.. 여기저기 제약사항 로직 만들어놓아서 고칠때 개고생하는 불상사를 막을수있다!

  - 기타 팁
    - 값 객체의 속성을 또 값 객체로 정의할 만한 가치가 있다(혹은 값 객체로 정의할 만한 가치가 잇는 개념)고 구현중에 발견했다면, 그 개념은 도메인 모델로 피드백해야한다!

- 3장 생애주기를 갖는 객체, 엔티티
  - 도메인 객체 중에도 속성이 달라지더라도 같은 대상으로 판단해야하는것들이 있는데, 이때 사용되는것이 엔티티이며, 이 엔티티는 식별자를 통해서 구별된다(식별자가 비교대상)
  - 엔티티와 값 객체 모두 도메인모델을 구현한 도메인 객체이지만, 성질에서 차이가 있다
  - 엔티티의 성질
    - 가변
      - 엔티티는 속성 변화를 위해 객체를 교환하지않는다(속성 변화를 위해 객체를 교환(새로만듦) 하는것은 값 객체)
      - 즉, 속성 변화가능
      - 그러나 필요에 따라 속성을 가변으로 만들 수 있는 객체일뿐이지, 가능한 한 객체는 불변객체로 만드는것이 좋다!
    - 속성이 같아도 구분가능 (속성이 같으면 같은 객체로 보는것이 값 객체! 속성을 통해 구분)
      - 식별자를 통해 가능
    - 동일성(identity)을 통해 구분
      
      - 동일성을 판단할 수단이 필요한데, 이에 식별자가 사용됨
  - 엔티티 판단기준
    - 생애주기를 가지거나 연속성을 가진다면 엔티티로 놓자.
      - 생애주기를 갖는다는것은 객체가 생성해서 없어질때까지 변화를 겪을 수 있는 대상이라는 것이다.
    - 생애주기가 무의미한 객체라면, 불변 객체로 가져가자! 그래야 다루기 복잡해지지않는다..
  - 같은 대상이라도 어떤 환경에 있느냐에따라 값 객체가 될 수 있고, 엔티티가 될 수도있다.
    - ex) 타이어는, 자동차를 구성하는 한 부품으로 다룰때는 값 객체로 다룰수있지만, 타이어 공장에서는 타이어가 언제 만들어졌고 어떤 공정에 있는지 등 엔티티로 다루어야할 대상이다
  - 도메인 객체(값 객체, 엔티티)를 정의할때의 장점
    - 유지보수 시점에 빛을 발함
    - 자기 서술적인 코드
      - 코드를 통해 사용되고있는 도메인의 역할 파악가능 
    - 도메인에 변경사항이 있을 시 코드에 반영하기 쉬움
      - 도메인 객체에 행동이나 규칙을 코드로 작성해두기때문에(응집성 굿), 도메인 모델로 전달된 도메인의 변화를 쉽게 객체까지 전달가능하다
  - 기타 팁
    - 도메인 객체의 유효성 검증은 필요하다. 그러나, 이 도메인 객체를 사용하는 클라이언트도 도메인 객체에 접근하기전에 검증이 필요하다!
    - *다양한 행동이 기술된 객체는 해당 소프트웨어가 어떤 도메인에 관심이있는지, 그 지식을 어떻게 식별하는지를 보여준다.. 그렇기에 개발자들에게 도메인을 이해하는데 좋은 힌트를 준다*
    - 구현시에 애매모호함을 느꼈다면, 도메인 모델링을 다시하자!
    
- 4장 부자연스러움을 해결하는 도메인 서비스
  - 엔티티와 값 객체로만 표현하기 애매한부분(이런 도메인 객체의 메소드에 정의하는게 겁나 이상한 느낌..)을 도메인 서비스를 통해서 해결하자.
  - 서비스란?
    - 소프트웨어 개발에서는 클라이언트를 위해 무언가를 해주는 객체
    - 도메인주도설계에서는 두가지로 나뉨
      - 도메인을 위한 서비스 => 도메인서비스
      - 애플리케이션을 위한 서비스 => 애플리케이션 서비스
  - 도메인서비스
    - 도메인서비스는 값 객체나 엔티티로 구현하기 어색한 행동을 해결해주는 객체
      - 객체의 책임을 명확하게 할 수 있도록 도와주는 역할 같음..
      - 여러개의 도메인 객체를 가로질러 이뤄지는 처리인 경우 사용하기좋음
      - ex) User 클래스에 사용자 이름의 중복을 체크하는것을 User 클래스에 넣어버리면..? 매우 이상.. UserService.exist를 만들어서해결하자..
        - 그런데, 이런 도메인서비스에서 또한 중요한것은 도메인 모델이 나타내고자하는 본질적인내용(ex. 사용자명중복체크, 사용자생성, 사용자 저장)을 다루어야하지, 특정 DB를 다루는 내용이 들어가면안된다! 그렇게되면, 해당 로직을 보고 무슨 역할을 하는지 파악해야하는 시간이 필요하며, 무엇보다 로직이 길어지면 명확하게 알기가 어렵다..(이를 repository를 통해 해결가능)
    - 도메인서비스는 자신의 행동을 바꿀수있는 인스턴스만의 값을 갖지않는다
      - 문장이 정확하게 이해는안감.. 메서드가아닌, 함수라는것인가..?(인풋이 같으면 아웃풋이 항상 같은..?)
  - 도메인 서비스를 남용하면?
    - 도메인 서비스는 *부자연스러운 처리에만 한정*해야한다!
    - 도메인 서비스를 남용하면, 도메인 객체는 자신의 정보(지식)를 전달해줄수 없게된다 (getter, setter만 있음..)
      - 이를 *빈혈 도메인 모델*이라고 한다..
    - 또한 로직이 분리되어서 중복코드가 많이 나타날수있게되고, 이에따라 유지보수에 어려움이 있을 수 있다
    - 일단 애매하면, 도메인객체(엔티티, 값 객체)에 최대한 넣어보자!
  - 도메인서비스 명명 규칙
    - 도메인개념
    - 도메인개념+Service
    - 도메인개념+DomainService
    - ex) 사용자 중복확인과 같이 특정 도메인 객체와 밀접하게 연관된 서비스는 UserService로 정의해놓은 서비스 도메인에 처리를 모아놓을수있다.. 또는, 사용자명 중복을 확인하는일을 별도의 서비스로 독립시켜야한다면, CheckDuplicateUserService와 같이 만들 수도있다.

- 5장 데이터와 관계된 처리를 분리하자 - 리포지토리
  - 왜 필요?
    - 엔티티는 생애주기를 갖는 객체인데, 프로그램의 종료와 함께 객체가 사라지면 안된다. (메모리에 당연 사라지긴하지만, 논리적으로 없어지면 안됨..)
    - 그래서 데이터를 저장하고 복원하는 처리가 필요한데, 이런부분을 추상화한 객체가 리포지토리이다
    - 영속성(퍼시스턴시)을 위해서 필요하다!
  - 리포지토리 책임?
    - 도메인 객체를 저장하고 복원하는 퍼시스턴시
    - 이게 없으면 퍼시스턴시 관련 구현 내용을 세부적으로 살펴보아야하는데, 이렇게 되었을때 뭐를 select해오고 insert하는것 등 세부 쿼리들을 보아야하므로 비지니스 로직을 빠르게 파악하기가 쉽지않다.. 이를 해결하기위해 추상화를 진행하여 리포지토리를 만든다..!
    - 객체의 퍼시스턴시와 관련된 처리를 리포지토리에 맡기면 비지니스 로직을 더욱 순수하게 유지가능
  - 리포지토리는 ***인터페이스로 정의***
    - 리포지토리에서 파라미터나 리턴값에 사용하는 객체들은 도메인객체!!
  - 테스트하기좋다!
    - 리포지토리 테스트용 구현체를 만들어서, Map 과 같은 메모리에 올려놓을 수 있는 객체를 활용하면 DB 셋팅하고, DB 연결하고 등등 테스트하기 버거운게아닌 간단하게 테스트 가능하다..
      - 테스트는.. 너무 수고스러우면 잘 안하게된다..
  - 리포지토리에 정의되는 행동
    - 객체의 저장과 관계된 행위
      - 저장
        - 객체를 저장하기위해서는 저장 대상 객체를 인자로 전달받아야한다! (변경도 포함..)
        - 객체의 식별자 및 수정항목을 인자로 받게 메서드를 정의하지말자..
          - ex. `void updateName(UserId id, UserName name);` 옳지못함..
          - 이렇게 되면 수많은 수정 관련 메서드가 생김..
      - 삭제
    - 저장된 객체의 복원과 관계된 행위
      - 식별자로 검색을 수행하는 메서드
      - 모든 객체를 받아와야하는 메서드
        - 복원되는 객체의 숫자에 따라 컴퓨터 리소스가 바닥날수있으니.. 페이징처리라던지 적절한 조건이 포함되어있는지(인덱스) 확인이 필요
  - 기타 팁
    - 퍼시스턴시를 생각하면 관계형 데이터베이스만 생각하는데, nosql이라든지 하다못해 파일저장도 퍼시스턴시이다.. 그렇기에 리포지토리를 만들때 rdb 관련 기술에 의존해서 만들면 안된다!
    - *리포지토리의 책임은 객체의 퍼시스턴시까지..!*
      - 사용자명 중복확인과 같은 도메인 규칙은 리포지토리 책임에 벗어난다..! 즉, 리포지토리 인터페이스에 `boolean exist(User user)` 이런거 만들지마라..
        - 리포지토리 구현에 따라 동작이 달라질수있는것도 문제..
        - 절대 안되는건 아니지만.. 도메인 규칙이라면 도메인쪽으로 가는게 좋을듯..!
      - *리포지토리에 도메인의 책임을 주면, 도메인을 통해 지식(정보)을 얻을 수 없다..!* 
    - `Optional` 타입은 null이 될수도 잇는 놈이니 null처리해라는것을 알려주는 것!
      - 이를 남용해서 null이 되면 안되는곳에도 optional을 쓰진말자..
    - 참고사항
      - 해당 책에서는 C# ORM을 사용하는데, 해당 ORM 프레임워크에서 사용하는 엔티티는 도메인객체의 엔티티(XXXDataModel 로 명명)와 다르게 적용한다 (spring data jpa는 도메인 객체의 엔티티와 jpa에서의 엔티티는 동일하게 처리된다)    
  
---

- 6장 유스케이스를 구현하기 위한 애플리케이션 서비스
  - 애플리케이션 서비스는 유스케이스를 구현하기 위한 객체
    - 유스케이스?
      - 직역하면 사용 사례
      - 시스템 사용에 대한 시나리오의 집합
      - ex. 시스템에서 사용자 기능을 구현하기위해서는 "사용자 등록하기" 유스케이스와 "사용자 정보 수정하기" 유스케이스가 필요..
    - 도메인 객체를 조합해 실행되는 스크립트와 같다..
    - 도메인 객체는 도메인을 코드로 옮긴것인데, 이를 이용자의 목적에 맞추기위해(애플리케이션의 존재 목적) 도메인 객체의 힘을 하나로 엮어서 제공해주어야하는데, 이를 애플리케이션 서비스가 담당한다(client가 사용할 서비스)
  - 애플리케이션 서비스에서 도메인 객체를 client에게 바로 전달한다면?
    - 
  - 기타 팁
    - 엔티티, 값 객체, 도메인 서비스 등 도메인 객체를 통해서 해당 프로그램이 사용할 도메인에 대한 관심과 지식을 살펴 볼 수 있고, 어플리케이션 서비스를 통해서 이런 도메인들을 어떻게 사용해서 사용자의 요구를 들어줄지(비지니스 로직)를 알 수 있다
      - 즉, 어플리케이션 서비스는 유스케이스를 코드로 구현한 것