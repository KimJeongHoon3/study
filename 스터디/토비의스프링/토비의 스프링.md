토비의 스프링(이에 대한 스터디는 최대한 어떻게 객체지향을 풀어나가는지에 집중할것!)
- 스프링이란?
  - 어플리케이션 개발을 빠르고 효율적으로 할수있도록 도와주는 애플리케이션 프레임워크
  - 이를 위해 애플리케이션의 기본틀, 공통 프로그래밍 모델, 기술 API를 제공
    - 애플리케이션의 기본틀(스프링 컨테이너) 
      - 애플리케이션 컨텍스트라고도 부르는 런타임 엔진을 제공
      - 설정 정보를 참고해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리
      - 독립적으로도 동작할수있지만, 보통 웹 모듈에서 동작하는 서비스나 서블릿으로 등록해서 사용(서블릿에 해당 컨테이너를 등록한다는 말인듯..?)
    - 공통 프로그래밍 모델(IoC/DI, 서비스 추상화, AOP)]
      - IoC/DI
        - 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델
        - 컨테이너에 등록해야지만 스프링이 제공해주는 가치를 누릴수있음!!!
      - 서비스 추상화
        - 구체적인 기술과 환경에 종속되지않도록 유연한 추상계층으로 개발
      - AOP
        - 부가적인 기능을 독립적으로 모듈화함
    - 기술 API
      - 다양한 영역에 바로 활용할수있는 방대한 양의 기술 API를 제공
      - 스프링에서 제공하는 API와 지원기술은 스프링의 프로그래밍 모델에 따라 작성되어있기때문에 스프링모델을 코드에 잘 녹여낼수있음!
  - => 스프링을 사용한다는것은 위를 활용하여 애플리케이션을 개발한다는것이다!
  - 스프링의 장점
    - 단순함 : 복잡한 기술 프레임워크가 아닌, 객체지향적 개발모델인 POJO 프로그래밍!
    - 유연성(+확장성) : 상당히 많은 서드파티를 지원해주고, 프레임워크에 프레임워크를 더하는 확장성이 매우 뛰어남!
    - 객체지향설계를 지향함으로써, 오브젝트를 어떻게 효과적으로 설계하고, 구현하고, 사용하고, 이를 개선해나갈지에 대한 기준을 마련해준다!! 이를 잘 할수있도록 프레임워크 또한 제공해준다!! 그렇게 만들어져잇는 프레임워크가 그렇게 개발할수있도록 도와주기도한다!! 

- 1장 오브젝트와 의존관계
  - 관심사의 분리
    - 객체를 설계할때 가장 염두해두어야할 사항은 미래의 변화를 어떻게 대비할것인가 이다.
    - 객체 지향설계는 변화에 효과적으로 대응할수있도록 해준다
      - 실 실계를 최대한 가깝게 모델링을하기때문에, 실 세계의 반영한 가상의 추상세계를 구성하여, 편리하게 변경, 발전, 확장 시킬수있다.(실 세계에서 변화되면 가상에서도 변화되도록)
    - 변화의 폭을 줄이는 방법은 분리와 확장을 고려한 설계이다
      - 관심사의 분리 : 관심이 같은것 끼리는 하나의 객체안으로 또는 친한 객체로 모이게하고, 관심이 다른것은 가능한 한 따로 떨어져서 서로 영향을 주지않도록 분리하는것!
    - 리팩토링 : 외부의 동작방식에는 변화없이, 내부구조를 변경해서 재구성하는 작업또는 기술.. 이를통해서 유지보수용이, 유연한 제품 개발, 코드의 품질높여줌 => 생산성향상
      - 메소드 추출 : 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는것
      - 
  - 용어정리
    - 자바빈 : 디폴트생성자 + getter / setter
      - 디폴트 생성자는 프레임워크에서 해당 객체를 생성할때(리플렉션) 파라미터가 없는 생성자가 필요하기때문


  - 관계 설정 책임의 분리 : 한 클래스 내에 해당 클래스 본연의 관심사 외에 다른 관심사가 함께 있다면 관계적으로 제대로 분리되지않은것! 여기서 다른 관심사라는것은 자신의 역할외에 다른 역할을 수행하는 클래스를 직접 책임지고 만드는것(new) 등을 이야기함.. 그렇기 때문에 이를 분리하기위해서는 인터페이스를 사용하여, 해당 인터페이스가 제공하는 함수만 사용하면되는것이지, 이 인터페이스가 어떤 구체적인 오브젝트로 만들어져있는지 신경쓰지않도록 하는것! 
    - ex) 토비의 스프링 예제상 UserDao의 역할은 데이터베이스에 접근하여 데이터를 핸들링하는 역할인데, ConnectionMaker(데이터베이스의 연결을 정의한 인터페이스)가 어떻게 구체적으로 만들어지는것인지는 신경쓰지않고 제공된 인터페이스를 사용하는것이 관계 설정 책임을 분리하는 핵심이다(인터페이스가 실제 오브젝트와 오브젝트사이의 관계를 엮어주는 역할!)
   
  - 원칙과 패턴
    - 개방폐쇄원칙 : 클래스나 모듈은 확장에는 열려있고, 변경에는 닫혀있어야한다
      - UserDao에서는 DB 연결방법이라는 기능을 확장하는데에는 열려있으나, UserDao의 핵심기능을 구현한 코드(데이터 select, add, update 등)는 변화에 영향을 받지않는것!
   
      * 객체지향설계원칙(SOLID) : 객체지향의 특징을 잘 살릴수있는설계의 특징을 이야기함.. 디자인패턴은 이 원칙을 지켜서 만들어진것. 즉, 객체지향설계원칙이 크고 일반적인 개념
         - SRP(The Single Responsibilty Principle) : 단일책임의 원칙
         - OCP(The Open Closed Principle) : 개발폐쇄원칙 
         - LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙 
         - ISP(The Interface Segregation Principle) : 인터페이스분리원칙
         - DIP(The Dependency Inversion Principle) : 의존관계 역전 원칙 
         
      * 디자인 패턴 : 특별한 상황에서 발생하는 문제에 대한 구체적인 솔루션
   - 높은 응집도와 낮은 결합도
      - 응집도 : 응집도가 높다는것은 하나의 책임과 관심사에 집중되어있다는것! 이를 잘 지킨다면, 고쳐야할 부분이 생겼을때 딱 그 부분만 고치면 된다. 즉, 다른곳에 연쇄적으로 수정이 일어날 곳이 준다. 테스트할때도 변경된 부분만 테스트가 가능하다. 기능과 기능간에 분리되어있으므로(단일 책임) 다른 기능들과 굳이 연결해서 테스트할 필요가없으니 이에 대한 부담도 줄음
      - 결합도 : 낮은 결합도라는것은 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공(인터페이스활용)하여, 서로 독립적이고 구체적인것을 알 필요가 없도록 만들어주는것이다. 이를 통해 오브젝트의 변경에 다른 오브젝트가 미치는 영향은 매우 줄게된다. 즉, 결합도라는것은 하나의 오브젝트가 변경이 일어날때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도라고 할수있다.

   - 전략패턴
      - 기능 맥락(context)에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 사용하여 외부로 분리시키고, 해당 인터페이스를 구현한 구체적인 클래스를 필요에 따라 변경해서 사용할수 있게끔하는 디자인 패턴.
      - 클라이언트가 사용할 전략을 선택하여 컨택스트가 진행
      - 특정 기능에 변경이 많다면 인터페이스를 사용하여 요구사항에 맞는 기능을 구현하여 그에 맞는 전략을 가져가는것이다 

  - 제어의 역전(IoC)
    - 오브젝트 팩토리 
      - 팩토리 : "객체 생성방법 결정 + 만들어진 객체를 반환" 하는 역할
         - 오브젝트를 사용하는쪽과, 오브젝트를 생성하는쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용!
         - 팩토리 메소드 패턴이나 추상팩토리 패턴과는 다름!
      - 설계도로서의 팩토리
         - 설계도 : 컴포넌트의 구조와 관계를 정의. 즉, 오브젝트들간에 관계를 정의!
            - 클라이언트가 UserDao를 사용하겠다고 요청하면, ConnectionMaker의 구체적인 오브젝트를 연결하여 UserDao를 넘겨준다.
               - ConnectionMaker의 구체적인 오브젝트가 추가되거나 변경되어도 UserDao는 영향받지않는다!
            - 이를 활용하면 UserDao뿐아니라, AccountDao, MessageDao 등과 같이 확장하여 사용가능하다.
     - 제어권 이전을 통한 제어관계의 역전
        - 제어의 역전은 "수동적"이 되었다는것!
        - 능동적으로 모든 것을 직접 만들어서 컨트롤하는것이 아닌, 실제적인 구현은 다른 곳에서 만들고 만들어진 것을 수동적으로 사용하겠다!
        - 템플릿 메소드 패턴에서도 제어의 역전을 볼수있는데, 템플릿 메소드를 통해서 해당 메소드는 상위클래스에서 사용되어지지만, 실제적인 구현은 하위클래스에서 이루어진다. 하위클래스에서 제어권을 가지는것이 아닌, 하위클래스에서는 정의만 할뿐, 실제적인 제어권은 상위클래스에서 가지고있기때문에 상위클래스에서 호출되었을때(수동적) 제어가 역전된것!
        - 라이브러리랑 프레임워크의 차이점에서도 제어권이전에 대한 개념을 알 수 있음
           - 라이브러리 : 코드상에서 능동적으로 필요할때 사용! 제어의역전x
           - 프레임워크 : 코드상에서 수동적으로 움직임(내가 만든 코드가 프레임워크에 의해 호출됨) 제어의역전o
        - 프레임워크나 컨테이너의 역할은 컴포넌트간의 관계를 정의, 사용, 생명주기를 관리하는것이다. 그로인해, 각각의 오브젝트들이 서로를 제어하거나 관리하지않게된다!


  - 스프링의 IoC
    - 오브젝트 팩토리를 이용한 스프링 IoC
      - 스프링 빈 : 스프링 컨테이너가 생성, 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트 (메소드에 @bean을 통해서 등록할때 메소드이름이 빈 이름이다)
      - 어플리케이션 컨텍스트 : 설정 정보를 가져와서 이를 기반으로 빈 생성, 관계 설정등의 제어를 해줌
        - BeanFactory를 구현했기때문에 빈 팩토리로 라고 부를수도있고 또는 IoC 컨테이너, 스프링컨테이너 라고 부르기도한다.
      - 어플리케이션 컨텍스트 동작방식
        1. @Configuration 이 있는 클래스(설정정보)로 ApplicationContext에 bean을 등록    
        2. client가 원하는 bean을 요청
        3. ApplicationContext에 등록된 bean목록에서 클라이언트가 요청한 bean을 찾아서 반환
      - 어플리케이션 컨텍스트 장점
        - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
          - 필요한 오브젝트를 가져오려면 어떤 팩토리 클래스를 사용해야할지를 알아야하고, 팩토리 오브젝트를 생성했어야하는데, applicationContext를 사용함으로써 팩토리가 아무리 많아져도 이를 알아야하거나 직접 사용할 필요가 없다.
        - 애플리케이션 컨텍스트는 종합 IoC서비스를 제공
          - 오브젝트간의 관계설정, 오브젝트가 만들어지는 방식, 자동생성, 오브젝트에 대한 후처리, 정보의조합, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공 
        - 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공.
    - 스프링 IoC 용어정리
      - 빈 : 스프링이 직접 그 생성과 제어를 담당하는 오브젝트를 빈
      - 빈 팩토리 : 스프링의 IoC를 담당하는 핵심 컨테이너. 빈을 등록, 생성, 조회하고 돌려주는것, 빈 관리 등
      - 어플리케이션 컨텍스트 : 빈 펙토리를 확장한 IoC 컨테이너. 빈 펙토리 이상의 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것
      - 설정정보/설정 메타정보 : IoC 적용을 위해 사용하는 메타정보
      - 컨테이너 또는 IoC 컨테이너 
      - 스프링 프레임워크

  - 싱글톤 레지스트리와 오브젝트 스코프 
    - 오브젝트의 동일성 & 동등성
      - 동일성 : 오브젝트가 진짜 완전 똑같아야함. 참조변수만 여러개 있는것일뿐, 같은 오브젝트를 바라보는 상태 
      - 동등성 : equals 메소드를 가지고 비교함. 즉, equals에 특정 조건만 만족하면 오브젝트가 다르다 할지라도 같다고 봐주는것. default값(equals 오버라이딩 안되어있으면)은 동일성 비교와 같음
    - 싱글톤 레지스트리로서의 애플리케이션 컨텍스트 
      - 애플리케이션 컨텍스트는 기본적으로 싱글톤을 저장하고 관리하는 싱글톤 레지스트리 이다. 싱글톤 레지스트리를 통해서 싱글톤으로 만들어준다!
      - spring은 서버에서 사용될 목적으로 만들어졌기에, 서버에서 요청마다 새로운 오브젝트를 만드는것은 너무 많은 부하를 주기때문에, 한번만 생성해서 공유하는 싱글톤이 디폴트이다!
      - 싱글톤을 우리가 직접 구현하게되면, 생성자를 private으로 놓기때문에 상속이나 다형성 활용이 불가하다. 테스트 코드시 mock으로 빼기도 어렵게된다. 그로 인해 스프링은 싱글톤 레지스트리를 통해서 일반 클래스를 빈으로 등록하면, 싱글톤으로 만들어지게되고, 이것이 상속이나 다형성, 테스트코드시 mock을 사용할수있게해준다
      - 그러나 싱글톤으로 만들게 되었을때 여러 스레드가 동시에 접근하게되면 이에 따른 동기처리를 해주어야하고, 무상태 방식으로 만들어주어야한다. 이에따라 요청에 대한 정보를 전달해줄때 파라미터나 리턴값을 잘 활용해야한다
    - 스코프는 싱글톤, 프로토타입, HTTP 요청이 생길때마다 생성하는 요청스코프, 웹의 세션과 스코프가 유사한 세션스코프도 있음

  - 의존관계 주입(DI)
    - 오브젝트가 인터페이스를 의존하는 것이 변화에 영향을 덜 받고 결합도를 낮춰준다. 그리고 이에 따라 실제 인터페이스를 구현한 오브젝트를 연결시켜주어야 하는데(런타임시에), 이 구체적인 오브젝트를 연결해 주는것을 DI(의존관계 주입) 이라하며, 이 역할을 스프링 컨테이너가 수행한다!
    - 의존관계 주입이란 아래 3가지를 충족
      - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야한다.(코드상에서는 구체적인 오브젝트의 의존관계가 드러나면안된다는뜻..)
      - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정
      - 의존관계를 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.(팩토리 클래스, 스프링에서는 스프링 컨테이너(빈 팩토리))

  - 정리
    - 스프링이란 어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크. 스프링의 주된관심은 오브젝트와 그 관계!
    - 객체 지향적으로 개발을 해나가는데 좋은 tool을 제공해주는게 스프링!
    - 특힌, 객체간의 관계를 설정하는데 도움을 줌으로써 높은 응집도와 낮은결합도가 가능하도록 도와준다!
     
   

- 2장 테스트
  - 테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것
  - 단위 테스트는 항상 일관성 있는 결과가 보장돼야한다. DB에 남아있는 데이터와 같은 외부환경에 영향을 받지 말아야하는것은 물론, 테스트를 실행하는 순서를바꿔도 동일한 결과가 보장되도록 만들어야한다.
  - 테스트는 항상 포괄적으로, 꼼꼼하게 진행되어야한다! 어정쩡하게 몇개만 테스트하고 넘어가면안됨!! 충분한 검증을하자!!!
  - 작은 단위로 테스트하는게 유리!
  - 예외조건에 대한 테스트를 잊지말것!
    - 예외테스트를 통해서 어떤 예외처리를 어디서, 어떻게 진행할것인지를 파악 할수있음!
  - @Test 실행될때마다 새로운 오브젝트가 생성된다!! 한번 만들어진 테스트 클래스의 오베즉트는 하나의 테스트 메소드를 사용하고 나면 버려진다!
  - 테스트도 리팩토링한다! 중복되는코드는 함수로 빼던지, @Before이나 @After를 사용하여 공통 준비작업과 정리를 처리할수있도록하자
  - 스프링 테스트는 어떻게?
    - 스프링을 활용하기위해서는 applicationContext를 생성해주어야하는데, 이를 사용하기위해서 지속적으로 테스트마다 만드는것은 부담! 이를 해결하기 위해 아래 두가지 사용
      1. @BeforeClass 를 통해서 테스트간 static으로 가지고있음
      2. @RunWith(SpringJUnit4ClassRunner.class) : 스프링에서 제공해주는 확장클래스(for junit) 이를 사용하면 applicationContext를 주입받을수있는데, 이는 테스트용으로 쓸수 있도록 해주는데, @ContextConfiguration(locations="application.properties 경로")를 통해서 가져오는 설정파일이 동일하다면 @Test시 딱 한번만 applicationContext를 생성!(테스트 클래스에서 모두 공유)
        - 이를 주입받을수 있다는것은, applicationContext를 통해서 bean들을 주입받을수 있다는것!
    - 스프링 컨테이너없어 테스트 할 수 있는 방법을 우선적으로 고려할것! 그래야 신속하고 빠르게 진행가능!
    - 복잡한 의존관계가 엮여져 있는 오브젝트는 스프링 DI 컨테이너를 잘 활용할것!
    - 테스트 전용 설정 파일을 작성하는것이 좋음!
        
  - 학습테스트 
    - 학습테스트 장점
      - 다양한 조건에 따른 기능을 손쉽게 확인 가능
      - 학습한 테스트 코드를 개발중에 참고가능
      - 프레임워크나 제품을 업그레이드할때 호환성 검증을 도와줌
      - 테스트 작성에 좋은 훈련이됨
    - 버그 테스트 : 코드에 오류가 있을때 그 오류를 가장 잘 드러내 줄 수 있는 테스트. 일단 버그테스트는 실패하도록 만들어야함!
      - 장점
        - 테스트의 완성도를 높임
        - 버그의 내용을 명확하게 분석
          - 동등분할 : 같은 결과를 내는 값의 범위를 구분해서 각 대표값으로 테스트를 하는 방법. 작업의 결과의 종류가 true, false 또는 예외발생이라면 각 결과를 내는 입력값이나 상황의 조합을 만ㄷ르어 모둔 경우에 대한 테스트를 해보는게 좋다!
          - 경계값 분석 : 경계의 근처에 있는 값을 이용해 테스트하는것. 숫자의 입력값인 경우 0이나 그 주변값 도는 정수의 최댓값, 최솟값 등으로 테스트하는것!