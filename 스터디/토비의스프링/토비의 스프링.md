토비의 스프링(이에 대한 스터디는 최대한 어떻게 객체지향을 풀어나가는지에 집중할것!)
- 스프링이란?
  - 어플리케이션 개발을 빠르고 효율적으로 할수있도록 도와주는 애플리케이션 프레임워크
  - 이를 위해 애플리케이션의 기본틀, 공통 프로그래밍 모델, 기술 API를 제공
    - 애플리케이션의 기본틀(스프링 컨테이너) 
      - 애플리케이션 컨텍스트라고도 부르는 런타임 엔진을 제공
      - 설정 정보를 참고해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리
      - 독립적으로도 동작할수있지만, 보통 웹 모듈에서 동작하는 서비스나 서블릿으로 등록해서 사용(서블릿에 해당 컨테이너를 등록한다는 말인듯..?)
    - 공통 프로그래밍 모델(IoC/DI, 서비스 추상화, AOP)]
      - IoC/DI
        - 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델
        - 컨테이너에 등록해야지만 스프링이 제공해주는 가치를 누릴수있음!!!
      - 서비스 추상화
        - 구체적인 기술과 환경에 종속되지않도록 유연한 추상계층으로 개발
      - AOP
        - 부가적인 기능을 독립적으로 모듈화함
    - 기술 API
      - 다양한 영역에 바로 활용할수있는 방대한 양의 기술 API를 제공
      - 스프링에서 제공하는 API와 지원기술은 스프링의 프로그래밍 모델에 따라 작성되어있기때문에 스프링모델을 코드에 잘 녹여낼수있음!
  - => 스프링을 사용한다는것은 위를 활용하여 애플리케이션을 개발한다는것이다!
  - 스프링의 장점
    - 단순함 : 복잡한 기술 프레임워크가 아닌, 객체지향적 개발모델인 POJO 프로그래밍!
    - 유연성(+확장성) : 상당히 많은 서드파티를 지원해주고, 프레임워크에 프레임워크를 더하는 확장성이 매우 뛰어남!
    - 객체지향설계를 지향함으로써, 오브젝트를 어떻게 효과적으로 설계하고, 구현하고, 사용하고, 이를 개선해나갈지에 대한 기준을 마련해준다!! 이를 잘 할수있도록 프레임워크 또한 제공해준다!! 그렇게 만들어져잇는 프레임워크가 그렇게 개발할수있도록 도와주기도한다!! 

- 1장 오브젝트와 의존관계
  - 관심사의 분리
    - 객체를 설계할때 가장 염두해두어야할 사항은 미래의 변화를 어떻게 대비할것인가 이다.
    - 객체 지향설계는 변화에 효과적으로 대응할수있도록 해준다
      - 실 실계를 최대한 가깝게 모델링을하기때문에, 실 세계의 반영한 가상의 추상세계를 구성하여, 편리하게 변경, 발전, 확장 시킬수있다.(실 세계에서 변화되면 가상에서도 변화되도록)
    - 변화의 폭을 줄이는 방법은 분리와 확장을 고려한 설계이다
      - 관심사의 분리 : 관심이 같은것 끼리는 하나의 객체안으로 또는 친한 객체로 모이게하고, 관심이 다른것은 가능한 한 따로 떨어져서 서로 영향을 주지않도록 분리하는것!
    - 리팩토링 : 외부의 동작방식에는 변화없이, 내부구조를 변경해서 재구성하는 작업또는 기술.. 이를통해서 유지보수용이, 유연한 제품 개발, 코드의 품질높여줌 => 생산성향상
      - 메소드 추출 : 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는것
      - 
  - 용어정리
    - 자바빈 : 디폴트생성자 + getter / setter
      - 디폴트 생성자는 프레임워크에서 해당 객체를 생성할때(리플렉션) 파라미터가 없는 생성자가 필요하기때문


  - 관계 설정 책임의 분리 : 한 클래스 내에 해당 클래스 본연의 관심사 외에 다른 관심사가 함께 있다면 관계적으로 제대로 분리되지않은것! 여기서 다른 관심사라는것은 자신의 역할외에 다른 역할을 수행하는 클래스를 직접 책임지고 만드는것(new) 등을 이야기함.. 그렇기 때문에 이를 분리하기위해서는 인터페이스를 사용하여, 해당 인터페이스가 제공하는 함수만 사용하면되는것이지, 이 인터페이스가 어떤 구체적인 오브젝트로 만들어져있는지 신경쓰지않도록 하는것! 
    - ex) 토비의 스프링 예제상 UserDao의 역할은 데이터베이스에 접근하여 데이터를 핸들링하는 역할인데, ConnectionMaker(데이터베이스의 연결을 정의한 인터페이스)가 어떻게 구체적으로 만들어지는것인지는 신경쓰지않고 제공된 인터페이스를 사용하는것이 관계 설정 책임을 분리하는 핵심이다(인터페이스가 실제 오브젝트와 오브젝트사이의 관계를 엮어주는 역할!)
   
  - 원칙과 패턴
    - 개방폐쇄원칙 : 클래스나 모듈은 확장에는 열려있고, 변경에는 닫혀있어야한다
      - UserDao에서는 DB 연결방법이라는 기능을 확장하는데에는 열려있으나, UserDao의 핵심기능을 구현한 코드(데이터 select, add, update 등)는 변화에 영향을 받지않는것!
   
      * 객체지향설계원칙(SOLID) : 객체지향의 특징을 잘 살릴수있는설계의 특징을 이야기함.. 디자인패턴은 이 원칙을 지켜서 만들어진것. 즉, 객체지향설계원칙이 크고 일반적인 개념
         - SRP(The Single Responsibilty Principle) : 단일책임의 원칙
         - OCP(The Open Closed Principle) : 개발폐쇄원칙 
         - LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙 
         - ISP(The Interface Segregation Principle) : 인터페이스분리원칙
         - DIP(The Dependency Inversion Principle) : 의존관계 역전 원칙 
         
      * 디자인 패턴 : 특별한 상황에서 발생하는 문제에 대한 구체적인 솔루션
   - 높은 응집도와 낮은 결합도
      - 응집도 : 응집도가 높다는것은 하나의 책임과 관심사에 집중되어있다는것! 이를 잘 지킨다면, 고쳐야할 부분이 생겼을때 딱 그 부분만 고치면 된다. 즉, 다른곳에 연쇄적으로 수정이 일어날 곳이 준다. 테스트할때도 변경된 부분만 테스트가 가능하다. 기능과 기능간에 분리되어있으므로(단일 책임) 다른 기능들과 굳이 연결해서 테스트할 필요가없으니 이에 대한 부담도 줄음
      - 결합도 : 낮은 결합도라는것은 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공(인터페이스활용)하여, 서로 독립적이고 구체적인것을 알 필요가 없도록 만들어주는것이다. 이를 통해 오브젝트의 변경에 다른 오브젝트가 미치는 영향은 매우 줄게된다. 즉, 결합도라는것은 하나의 오브젝트가 변경이 일어날때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도라고 할수있다.

   - 전략패턴
      - 기능 맥락(context)에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 사용하여 외부로 분리시키고, 해당 인터페이스를 구현한 구체적인 클래스를 필요에 따라 변경해서 사용할수 있게끔하는 디자인 패턴.
      - 클라이언트가 사용할 전략을 선택하여 컨택스트가 진행
      - 특정 기능에 변경이 많다면 인터페이스를 사용하여 요구사항에 맞는 기능을 구현하여 그에 맞는 전략을 가져가는것이다 

  - 제어의 역전(IoC)
    - 오브젝트 팩토리 
      - 팩토리 : "객체 생성방법 결정 + 만들어진 객체를 반환" 하는 역할
         - 오브젝트를 사용하는쪽과, 오브젝트를 생성하는쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용!
         - 팩토리 메소드 패턴이나 추상팩토리 패턴과는 다름!
      - 설계도로서의 팩토리
         - 설계도 : 컴포넌트의 구조와 관계를 정의. 즉, 오브젝트들간에 관계를 정의!
            - 클라이언트가 UserDao를 사용하겠다고 요청하면, ConnectionMaker의 구체적인 오브젝트를 연결하여 UserDao를 넘겨준다.
               - ConnectionMaker의 구체적인 오브젝트가 추가되거나 변경되어도 UserDao는 영향받지않는다!
            - 이를 활용하면 UserDao뿐아니라, AccountDao, MessageDao 등과 같이 확장하여 사용가능하다.
     - 제어권 이전을 통한 제어관계의 역전
        - 제어의 역전은 "수동적"이 되었다는것!
        - 능동적으로 모든 것을 직접 만들어서 컨트롤하는것이 아닌, 실제적인 구현은 다른 곳에서 만들고 만들어진 것을 수동적으로 사용하겠다!
        - 템플릿 메소드 패턴에서도 제어의 역전을 볼수있는데, 템플릿 메소드를 통해서 해당 메소드는 상위클래스에서 사용되어지지만, 실제적인 구현은 하위클래스에서 이루어진다. 하위클래스에서 제어권을 가지는것이 아닌, 하위클래스에서는 정의만 할뿐, 실제적인 제어권은 상위클래스에서 가지고있기때문에 상위클래스에서 호출되었을때(수동적) 제어가 역전된것!
        - 라이브러리랑 프레임워크의 차이점에서도 제어권이전에 대한 개념을 알 수 있음
           - 라이브러리 : 코드상에서 능동적으로 필요할때 사용! 제어의역전x
           - 프레임워크 : 코드상에서 수동적으로 움직임(내가 만든 코드가 프레임워크에 의해 호출됨) 제어의역전o
        - 프레임워크나 컨테이너의 역할은 컴포넌트간의 관계를 정의, 사용, 생명주기를 관리하는것이다. 그로인해, 각각의 오브젝트들이 서로를 제어하거나 관리하지않게된다!


  - 스프링의 IoC
    - 오브젝트 팩토리를 이용한 스프링 IoC
      - 스프링 빈 : 스프링 컨테이너가 생성, 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트 (메소드에 @bean을 통해서 등록할때 메소드이름이 빈 이름이다)
      - 어플리케이션 컨텍스트 : 설정 정보를 가져와서 이를 기반으로 빈 생성, 관계 설정등의 제어를 해줌
        - BeanFactory를 구현했기때문에 빈 팩토리로 라고 부를수도있고 또는 IoC 컨테이너, 스프링컨테이너 라고 부르기도한다.
      - 어플리케이션 컨텍스트 동작방식
        1. @Configuration 이 있는 클래스(설정정보)로 ApplicationContext에 bean을 등록    
        2. client가 원하는 bean을 요청
        3. ApplicationContext에 등록된 bean목록에서 클라이언트가 요청한 bean을 찾아서 반환
      - 어플리케이션 컨텍스트 장점
        - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
          - 필요한 오브젝트를 가져오려면 어떤 팩토리 클래스를 사용해야할지를 알아야하고, 팩토리 오브젝트를 생성했어야하는데, applicationContext를 사용함으로써 팩토리가 아무리 많아져도 이를 알아야하거나 직접 사용할 필요가 없다.
        - 애플리케이션 컨텍스트는 종합 IoC서비스를 제공
          - 오브젝트간의 관계설정, 오브젝트가 만들어지는 방식, 자동생성, 오브젝트에 대한 후처리, 정보의조합, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공 
        - 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공.
    - 스프링 IoC 용어정리
      - 빈 : 스프링이 직접 그 생성과 제어를 담당하는 오브젝트를 빈
      - 빈 팩토리 : 스프링의 IoC를 담당하는 핵심 컨테이너. 빈을 등록, 생성, 조회하고 돌려주는것, 빈 관리 등
      - 어플리케이션 컨텍스트 : 빈 펙토리를 확장한 IoC 컨테이너. 빈 펙토리 이상의 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것
      - 설정정보/설정 메타정보 : IoC 적용을 위해 사용하는 메타정보
      - 컨테이너 또는 IoC 컨테이너 
      - 스프링 프레임워크

  - 싱글톤 레지스트리와 오브젝트 스코프 
    - 오브젝트의 동일성 & 동등성
      - 동일성 : 오브젝트가 진짜 완전 똑같아야함. 참조변수만 여러개 있는것일뿐, 같은 오브젝트를 바라보는 상태 
      - 동등성 : equals 메소드를 가지고 비교함. 즉, equals에 특정 조건만 만족하면 오브젝트가 다르다 할지라도 같다고 봐주는것. default값(equals 오버라이딩 안되어있으면)은 동일성 비교와 같음
    - 싱글톤 레지스트리로서의 애플리케이션 컨텍스트 
      - 애플리케이션 컨텍스트는 기본적으로 싱글톤을 저장하고 관리하는 싱글톤 레지스트리 이다. 싱글톤 레지스트리를 통해서 싱글톤으로 만들어준다!
      - spring은 서버에서 사용될 목적으로 만들어졌기에, 서버에서 요청마다 새로운 오브젝트를 만드는것은 너무 많은 부하를 주기때문에, 한번만 생성해서 공유하는 싱글톤이 디폴트이다!
      - 싱글톤을 우리가 직접 구현하게되면, 생성자를 private으로 놓기때문에 상속이나 다형성 활용이 불가하다. 테스트 코드시 mock으로 빼기도 어렵게된다. 그로 인해 스프링은 싱글톤 레지스트리를 통해서 일반 클래스를 빈으로 등록하면, 싱글톤으로 만들어지게되고, 이것이 상속이나 다형성, 테스트코드시 mock을 사용할수있게해준다
      - 그러나 싱글톤으로 만들게 되었을때 여러 스레드가 동시에 접근하게되면 이에 따른 동기처리를 해주어야하고, 무상태 방식으로 만들어주어야한다. 이에따라 요청에 대한 정보를 전달해줄때 파라미터나 리턴값을 잘 활용해야한다
    - 스코프는 싱글톤, 프로토타입, HTTP 요청이 생길때마다 생성하는 요청스코프, 웹의 세션과 스코프가 유사한 세션스코프도 있음

  - 의존관계 주입(DI)
    - 오브젝트가 인터페이스를 의존하는 것이 변화에 영향을 덜 받고 결합도를 낮춰준다. 그리고 이에 따라 실제 인터페이스를 구현한 오브젝트를 연결시켜주어야 하는데(런타임시에), 이 구체적인 오브젝트를 연결해 주는것을 DI(의존관계 주입) 이라하며, 이 역할을 스프링 컨테이너가 수행한다!
    - 의존관계 주입이란 아래 3가지를 충족
      - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야한다.(코드상에서는 구체적인 오브젝트의 의존관계가 드러나면안된다는뜻..)
      - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정
      - 의존관계를 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.(팩토리 클래스, 스프링에서는 스프링 컨테이너(빈 팩토리))

  - 정리
    - 스프링이란 어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크. 스프링의 주된관심은 오브젝트와 그 관계!
    - 객체 지향적으로 개발을 해나가는데 좋은 tool을 제공해주는게 스프링!
    - 특힌, 객체간의 관계를 설정하는데 도움을 줌으로써 높은 응집도와 낮은결합도가 가능하도록 도와준다!
     
   

- 2장 테스트
  - 테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것
  - 단위 테스트는 항상 일관성 있는 결과가 보장돼야한다. DB에 남아있는 데이터와 같은 외부환경에 영향을 받지 말아야하는것은 물론, 테스트를 실행하는 순서를바꿔도 동일한 결과가 보장되도록 만들어야한다.
  - 테스트는 항상 포괄적으로, 꼼꼼하게 진행되어야한다! 어정쩡하게 몇개만 테스트하고 넘어가면안됨!! 충분한 검증을하자!!!
  - 작은 단위로 테스트하는게 유리!
  - 예외조건에 대한 테스트를 잊지말것!
    - 예외테스트를 통해서 어떤 예외처리를 어디서, 어떻게 진행할것인지를 파악 할수있음!
  - @Test 실행될때마다 새로운 오브젝트가 생성된다!! 한번 만들어진 테스트 클래스의 오베즉트는 하나의 테스트 메소드를 사용하고 나면 버려진다!
  - 테스트도 리팩토링한다! 중복되는코드는 함수로 빼던지, @Before이나 @After를 사용하여 공통 준비작업과 정리를 처리할수있도록하자
  - 스프링 테스트는 어떻게?
    - 스프링을 활용하기위해서는 applicationContext를 생성해주어야하는데, 이를 사용하기위해서 지속적으로 테스트마다 만드는것은 부담! 이를 해결하기 위해 아래 두가지 사용
      1. @BeforeClass 를 통해서 테스트간 static으로 가지고있음
      2. @RunWith(SpringJUnit4ClassRunner.class) : 스프링에서 제공해주는 확장클래스(for junit) 이를 사용하면 applicationContext를 주입받을수있는데, 이는 테스트용으로 쓸수 있도록 해주는데, @ContextConfiguration(locations="application.properties 경로")를 통해서 가져오는 설정파일이 동일하다면 @Test시 딱 한번만 applicationContext를 생성!(테스트 클래스에서 모두 공유)
        - 이를 주입받을수 있다는것은, applicationContext를 통해서 bean들을 주입받을수 있다는것!
    - 스프링 컨테이너없어 테스트 할 수 있는 방법을 우선적으로 고려할것! 그래야 신속하고 빠르게 진행가능!
    - 복잡한 의존관계가 엮여져 있는 오브젝트는 스프링 DI 컨테이너를 잘 활용할것!
    - 테스트 전용 설정 파일을 작성하는것이 좋음!
        
  - 학습테스트 
    - 학습테스트 장점
      - 다양한 조건에 따른 기능을 손쉽게 확인 가능
      - 학습한 테스트 코드를 개발중에 참고가능
      - 프레임워크나 제품을 업그레이드할때 호환성 검증을 도와줌
      - 테스트 작성에 좋은 훈련이됨
    - 버그 테스트 : 코드에 오류가 있을때 그 오류를 가장 잘 드러내 줄 수 있는 테스트. 일단 버그테스트는 실패하도록 만들어야함!
      - 장점
        - 테스트의 완성도를 높임
        - 버그의 내용을 명확하게 분석
          - 동등분할 : 같은 결과를 내는 값의 범위를 구분해서 각 대표값으로 테스트를 하는 방법. 작업의 결과의 종류가 true, false 또는 예외발생이라면 각 결과를 내는 입력값이나 상황의 조합을 만ㄷ르어 모둔 경우에 대한 테스트를 해보는게 좋다!
          - 경계값 분석 : 경계의 근처에 있는 값을 이용해 테스트하는것. 숫자의 입력값인 경우 0이나 그 주변값 도는 정수의 최댓값, 최솟값 등으로 테스트하는것!


- 3장 템플릿
  - 템플릿이란 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며, 일정한 패턴으로 유지되는 특성을 가진 부분을, 자유롭게 변경되느 ㄴ성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할수 있도록 하는방법! (즉, 변하는곳과 변하지않는곳을 분리/독립시키는 패턴)
  - 템플릿 메소드 패턴 : 변하는 부분은 하위클래스에서, 변하지않는부분은 상위클래스에서 정의. 즉, 하위클래스에서 오버라이딩한 메소드(변경이 일어나는..)를 상위클래스에서 호출함 => 이는 변할때마다 클래스가 새로 생성되어야함
  - 이에대한 개선으로 전략패턴의 최적화를 생각할수있음. 변하는 부분을 전략패턴으로 사용. 변화되는부분을 메소드의 파리미터로 전달받음(전략객체)으로써 지속적으로 클래스 생성하는것을 막을수있으며, 소스도 더 직관적으로 볼 수 있음. - 템플릿/콜백 패턴 (전략객체를 위한 인터페이스는 보통은 하나의 메소드를 사용하며 이러한 전략객체를 메소드로 전달할때 익명클래스로 생성하여 전달해줌 - 마이크로 DI)
    - 마이크로DI : 일반적으로 DI는 의존관계에 있는 두개의 오브젝트와 이 관계를 다이내믹하게 설정해주는 오브젝트 팩토리(DI 컨테이너), 이를 사용하는 클라이언트라는 4개의 객체에서 일어난다. 이러한 DI가 하나의 메소드안에서 객체를 생성하고 전달하여 의존관계를 셋팅하여 매우 작은 단위의 코드와 메소드 사이에서 일어나기도 하는데, 이를 마이크로 DI라고 한다.

  - 템플릿/콜백 패턴 : 전략패턴의 컨텍스트를 템플릿이라 부르고, 익명 내부클래스로 만들어지는 오브젝트를 콜백이라고 부른다.
    - 템플릿 : 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀. 고정된 틀 안에서 바꾸ㅡㄹ수 있는 부분을 넣어서 사용하는 경우에 템플릿이라함
    - 콜백 : 실행되는 것을 목적으로, 다른 오브젝트의 메소드에 전달되는 오브젝트(callbackObj). 즉, 템플릿안에서 실행될 목적으로 전달되는 객체임! 보통은 단일 메소드를 사용하고 특정 기능을 위한 한번 호출하는게 일반적
      - obj.method(callbackObj)
    - 특징 
      - 메소드 단위로 사용할 오브젝트를 매번 새롭게 전달
      - 클라이언트 메소드 내의 정보를 직접 참조! (클라이언트가 템플릿 메소드 호출시 오브젝트를 익명내부 클래스로 만들기때문에 그때의 클라이언트에 담긴 정보를 참조가능! 강력하게 결합되어있음!)
      - 컨텍스트 호출과 동시에 전략DI(익명내부클래스)를 수행하는것!
      - 템플릿은 한번에 하나 이상의 콜배긍ㄹ 사용할수도있고, 하나의 콜백을 여러번 호출할수도 있다!

  - 3장을 통한 기타 팁
    - 중복된 코드는 먼저 메소드로 분리 => 그 중 일부 작업을 필요에 따라 바꾸어 사용해야 한다면 인터페이스를 사이에 두고 분리해서 전략패턴을 적용 & DI로 의존관계 관리 => 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어 질수 있다면 템플릿/콜백패턴을 적용
    - 테스트 작성시 네거티브를 먼저 생각해보자!

- 4장 예외
  - 예외는 두가지 처리를 염두해야함
    - 복구
    - 중단
  - 예외의 종류와 특징
    - java.lang.Error
      - 시스템에 비정상적인 상황발생하였을때. 에플리케이션 코드에서 못잡음
      - 애플리케이션에서는 해당 레벨에 대한 에러는 신경쓸필요없음
    - java.lang.Exception
      - 언체크예외
        - RuntimeException or RuntimeException 서브클래스
        - 예외처리 할수는 있으나 반드시처리해주어야하는것은 아님(컴파일 에러 안남)
        - 복구할 가능성이 없는것은 언체크 예외로처리하고 일괄적으로 handling 하는게 좋음(메일이 간다든가..)
      - 체크 예외
        - Excpetion or Exception클래스의 서브클래스 (Not RuntimeException)
        - 예외처리 반드시 해주어야함(컴파일 에러남)
        - 복구할 가능성이 있는 경우에 사용. 적절한 처리로직 필요
        - 어플리케이션 예외는 체크예외를 해주는게 좋음
          - 비지니스 로직상에서 복구가 필요한 에러들..(엄밀히 말하면 이 또한 기술적으로는 시스템에러가 아니니깐 정상로직이나, 일반적인 flow에서 예외상황이라고 생각하면 좋을듯) ex) 인출시 잔고없을때 진행하는 로직
  - 예외처리 방법
    - 복구
      - 보통은 체크예외에서 사용
    - 회피
      - 바로던지기
      - 한번 catch에서 잡고 던지기(catch문에서 무언가 실행할게 있을 것)
    - 전환
      - catch에서 잡고 예외전환한뒤 던짐
      - 좀더 세부적이고 구체적인 에러를 전달하고자할때도 사용 (+ 추상화된 예외)
        - 예를들어, 단순이 Dao에서 SQLException이 아닌, DuplicateUserIdException과 같이 특정 상황에 좀더 세부적으로 전달.
        - Dao에서 적절한 예외로 전달해서 던져주면, 이에 대한 복구잡업은 service에서! 
      - 예외를 전활할때는 기존발생한 예외를 담아서 던지는 중첩예외로 만드는것이 좋음
      - 또한 체크예외를 언체크 예외로 변경하여 던져주기도함(반대일 경우도 있겠지)
        - try catch로 계속 잡아주거나 던져줄 필요없이!
  - DataAccessException
    - 스프링에서 제공하는 SQLException(JDBC)을 대체할수잇는 런타임예외(각 DBMS별로 너무 다름..ㅡㅡ)
    - 각 DBMS의 드라이버나 메타정보를 참고해서 DataAccessException의 하위클래스를(좀 더 에러의 의미를 명확하게 하기위해) 만들어주기때문에, 각 DBMS에 의존적이고 통일이 어려운 JDBC를의 한계를 보완
    - 한걸음 더 나아가, 자바의 다양한 데이터 엑세스 기술을 사용할때 발생하는 예외들을 추상화해서 DataAccessException 계층구조 안에 정리해놓았음
      - JDBC,JDO,JPA, 하이버네이트 등 데이터 엑세스 기술들에 대한 각각의 에러들에대해서 추상화시켜놓았으니 데이터 엑세스 기술들이 변해도 소스변화를 최소화 시킬수있겠지
      - ***어느정도 추상화된 공통 예외로 변환해주긴 하지만, 근본적인 한계가 있기때문에 사용에 매우 주의를 기울여야함! 미리 학습테스트를 만들어서 실제로 전환되는 예외를 꼭 확인할것!***
    - 이를 사용하면 Dao 인터페이스를 만들때 특정 데이터엑세스기술에 종속되어있는 메소드(예외 던질때 특정 엑세스기술의 Exception)가 아닌 통일 시켜줄수있음!

  - 4장을 통한 기타 팁
    - 예외안에 의미있는 정보들을 넣어주면 좋을듯!
      - 예를들어, 잔고 관련하여 에러가 났다면, 현재 남은 금액이 얼마인지도 에러클래스 내부적으로 담고있다가 전달해주면 좋을듯

- 5장 서비스 추상화
  - 데이터 엑세스 기술이 변경된다고해서 비지니스로직이 있는 계층(service)이 변경되어서는 안된다!
    - 그래서 dao는 인터페이스로! dao인터페이스도 exception 같은 경우, 데이터 엑세스 기술에 영향받지않도록 RuntimeException을 사용하고, 스프링에서 이미 추상화되어있는 데이터 엑세스 오브젝트를 활용하자!
    - 비지니스로직 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메소드로 정리되어야한다!
  - 이를 해결하기위해 서비스 계층을 스프링은 제공해준다
  - 각 오브젝트와 메소드가 자기 몫의 책임을 맡아 일을 하는 구조여야함!
    - ***객체 지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신, 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다.(당연히 책임이 있는 오브젝트에게 요청!) 오브젝트에게 데이터를 요구하지말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이다.***
  - 트랜잭션 서비스 추상화
    - 트랜잭션 : 쪼갤수 없는 논리 단위. 그래서 문제일어나면 아예 안되어야한다!(All or Nothing!)
    - 트랜잭션을 적용하려면 jdbc기준 동일한 connection을 사용해야하므로 보통 service 계층에서 적용을 하게된다. 그러나, 그렇게 된다면 다른 데이터 엑세스 기술을 사용하게되면, 데이터 엑세스 기술별로 service를 만들어야한다. 이를 막기위해서 스프링은 PlatfromTransactionManager라는 추상화된 서비스를 제공해준다.
      - 즉, DI만 특정 데이터 엑세스 기술에 맞춰서 해준다면, 서비스 계층의 코드는 전혀 고칠 필요가 없다!
  - 단일책임의 원칙
    - 스프링은 DAO와 SERVICE와 같은 수평적인 관계(로직의종류)에서도, DAO와 Datasource 같은 수직적인관계(로직과 기술)에서도 모두 결합도가 낮게 설계할수있도록 도와준다. 이는 DI로 인하여 가능하다!
    - DI는 관심, 책임, 성격이 다른 코드를 깔끔하게 분리해준다.
    - 단일 책임원칙은 하나의 모듈에는 한가지 책임이 있어야한다는것이다. 즉, 모듈이 변경되어야할 이유도 하나여야 된다는것이다!
    - 이런 단일책임원칙을 잘 지켜졌을때, 수정해야할 부분이 명확해지며, 수정해야할곳도 최소한으로 줄게된다
  - 테스트와 서비스 추상화
    - 로우레벨의 다양한 기술(하는 역할은 동일)에 대해 인터페이스를 활용하여 일관성 있는 접근 방법을 제공할수잇다. 이를 통해서 확장 불가능한 API도 서비스 추상화를 통해서 손쉽게 테스트가 가능하다
    - 특히나 외부리소스 연동에는 서비스 추상화를 통해서 더욱 손쉽게 원하는 오브젝트에만 집중하여 테스트가 가능하다
      - 예를들어, 서비스계층에서 특정기능 수행시 확인 메일발송 기능이 있을때, 메일발송은 주된로직이 아니므로 이를 추상화해놓는다면(mock객체 생성) 빠르게 서비스의 주 기능을 테스트 해볼수있다
    - 테스트 대상으로부터 전달받은 정보를 검증할수있도록 설계된것을 목 오브젝트라한다
      - 스텁 + 테스트 결과 및 테스트 대상 오브젝트와 이와 연계된 의존오브젝트간에 일어나는일을 검증
      - *스텁 : 테스트 코드가 정상적으로 수행하는것을 도움
      - 그냥 Mock은 가짜 객체로 이해하는게 좋을듯함..
  - 5장을 통한 기타 팁
    - ENUM을 잘 활용하자!
      - 타입에 안전!
      - ENUM을 사용하여 다양하게 활용이 가능하니 잘 익혀둘것!
        ```java
        public enum Level {
            GOLD(3,null),SILVER(2,GOLD),BASIC(1,SILVER);

            private final int value;
            private final Level nextLevel;

            Level(int value,Level nextLevel){
                this.value = value;
                this.nextLevel=nextLevel;
            }

            public int intValue() {
                return value;
            }

            public Level nextLevel(){
                return nextLevel;
            }

            public static Level valueOf(int value){
                switch (value){
                    case 1 : return BASIC;
                    case 2 : return SILVER;
                    case 3 : return GOLD;
                    default : throw new UnsupportedOperationException("not defined type : "+value);
                }
            }

        }
        ```
    - update시에 where 조건이 정상적으로 먹지 않아 모두 update되는 불상사를 막기위해 항상 update요청한데이터, 그렇지않은 데이터 2개의 로우를 테스트할것
    - 테스트 진행시에는 경우의 수를 잘 따져가면서 해야한다! 대충 한두개 됐다고 넘어가면안됨!!
    - 테스트 데이터는 변경이 일어나는 경계가 되는값의 전후를 잘 활용하라!
    - 코드개선시 항상 숙지할것!
      - 코드에 중복된 부분은 없는지
      - 코드가 무엇을 하는것인지 이해하는데 불편함은 없는지
      - 코드가 자신이 있어야할 자리에 잇는지
      - 앞으로 변경이 일어나면 무엇이 있을수 있고, 그 변화에 쉽게 대응할수잇도록 작성이 되어있는지
    - 도메인 클래스에 비지니스 로직이 들어가면 테스트소스만들어라! 
    - 비지니스 로직 처리시 중간에 에러를 일부러 내야한다면, 그런 에러를 낼수있는 서비스 클래스를 새로 만들어라!(되도록이면 테스트 클래스 내부에서!)
