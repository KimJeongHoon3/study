# 토비의 스프링 vol2

- 1장 IoC 컨테이너와 DI
  - 왜 IoC?
    - 컨테이너가 오브젝트에 대한 제어권을 갖고있어서 IoC (코드가 오브젝트를 제어하지않음!)
  - IoC 컨테이너 = 어플리케이션 컨텍스트 = 빈 팩토리
    - 어플리케이션 컨텍스트 (빈 팩토리를 상속받고있음..)
      - 엔터프라이즈 애플리케이션 개발하는데 필요한 여러가지 기능 + 빈 팩토리
    - 빈 팩토리
      - 오브젝트 사이의 관계 설정
  - IoC 컨테이너 사용을 위해서는 메타정보가 필요하다. 여기서 메타정보는 빈을 어떻게만들지, 어떻게 동작하게할지를 정의한 정보다
  - 스프링 애플리케이션이란, POJO클래스와 설정메타정보를 이용해 IoC 컨테이너가 만들어주는 오브젝트의 조합이라고 할수있다!
    - <img src="Ioc_make.jpeg"/>
      - 리더만 잘 만들면 어떤 형태로도 빈 설정 메타정보를 작성할 수 있다!
  - IoC컨테이너는 오브젝트 단위로 관리함!
    - 클래스 하나에 여러 오브젝트를 만들수 있고, 이 오브젝트들을 IoC컨테이너가 관리하기 때문에 클래스단위가 아니라 오브젝트 단위로 관리된다.
  - IoC컨테이너 종류
    - StaticApplicationContext, GenericApplicationContext, GenericXmlApplicationContext, WebApplicationContext...
      - WebApplicationContext
        - 서블릿 컨테이너 : 요청을 받아서 서블릿을 동작시켜줌
          - 서블릿 : IoC 컨테이너에서 필요한 빈을 받아놓고 요청이 들어오면 해당 요청에 맞는 적절한 빈을 호출(web에서는 DispatcherServlet이 해당역할)
  - IoC 컨테이너 계층 구조
    - 트리모양의 계층구조를 사용하여 IoC 컨테이너는 하나 이상을 만들수 있다
    - 검색순서는 항상 자신이먼저! 그 다음이 직계부모(자신이 부모꺼 오버라이딩했다면 부모꺼 당연안불러온다~)
    - 웹 어플리케이션의 IoC 컨테이너 구성(p76참고)
      - 루트 applicationContext + 서블릿 컨텍스트(이거는 여러개될수있음. 부모컨텍스트가 루트 application context)
      - 꼭 반드시 두개이상을 사용해야하는것은 아님..
        - 스프링 웹기술을 사용하지않는다면 루트 애플리케이션 컨텍스트만 등록하면됨
        - 서블릿 컨텍스트 단일구조로 사용하기도함

  - 1장을 통한 기타팁
    - /WEB-INF/**/*Context.xml (web.xml)
      - WEB-INF 폴더 밑의 모든 서브폴더에 Context.xml로 끝나는 모든 파일을 찾는다
    - 스테레오타입 애노테이션 : 디폴트 필터에 적용되는 애노테이션
      - 종류
        - @Component 
        - @Service : 서비스계층에서 사용
        - @Controller : MVC 컨트롤러에 사용. 스프링 웹 서블릿에 의해 웹 요청을 처리하는 컨트롤러 빈으로 선정됨
        - @Repository : 데이터 엑세스 계층의 DAO 또는 repository 클래스에 사용. DataAccessException 자동변환과 같은 AOP 적용 대상을 선정하기 위해서도 사용
    - @Configuration 클래스에 @Bean으로 생성한 빈 오브젝트들을 @Bean으로 등록한 함수로 호출하게되면, 몇번을 호출하던 싱글톤으로 동일한 빈을 전달해준다.(프록시 적용! CGLib..) 그러나, @Component 클래스에 @Bean으로 생성된 오브젝트를 함수로 호출하게되면, 호출할때마다 새로운 오브젝트가 등록이된다!
    - component-scan 태그는 애노테이션 의존관계 설정을 지원한다(의존관계 설정도하고 필요에따라 빈도 등록하고..)
      - annotation-config 태그는 이미 등록된 빈의 메타정보에 프로퍼티 항목을 추가해주는 작업! 새로운 빈을 등록해주지는않음!
    - @Resource는 빈의 이름을 이용해서 빈을 찾음
    - @Autowired는 빈의 타입을 이용해서 빈을 찾음
      - @Inject는 JSR-300(DIJ) 에서 제공해주는데, 이는 Autowired 와 같은기능!
      - 생성자에서도 사용할수있는데, 생성자 여러개 있을때 어떤것을 Autowired 사용할 것인지 명시해주어야 에러가 안난다
      - 꼭 생성자를 이용해서 DI 방식을 사용하는것이 정답은아님!
        - 디폴트 값을 주고 선택적으로 DI할수있또록 만들어야할때는 수정자메소드 주입이 더 좋겟지?
      - 동일한 타입이 여러개 빈으로 등록록되어있으면, Set, List로 가져올수있다
        - Map<String,Object>로도 가져올수있는데 key에는 bean 이름이 들어감
      - @Qulifier
        - 기본적으로 bean으로 등록된 놈이 qulifier(한정자) 를 가지고있는지 찾고, 없으면 빈 이름으로 찾는다. 즉, @Qualifer는 빈 생성시 전달한다.. "Autowired를 사용했을때 특정 한정자에 의해 한정을 시킨다!" 로 qualifer를 이해하자..
          ``` java
          @Component
          @Qulifier("abc")
          class Kkk{
              ...    
          }
          ```
        - 빈에 부가적인 속성을 지정해주는효과있음
        - 스프링은 @Qualifier를 메타애노테이션으로 갖는 애노테이션도 @Qualifier 취급을 해준다!
        - Qualifer(한정자) 사용해서 주입하려하는데, 적절한 Qualifier를 사용해서 등록된 빈이 없다면, 그냥 빈 이름으로 찾아줌
      - 꼭반드시 bean이 주입되어야하는게 아니면 @Autowired의 required 엘리먼트를 false로! 
        ```java
            @Autowired(required=false) Printer printer;
        ```
      - @Bean 을 통해서 빈을 등록할떄, 선언한 메소드는 자동주입되므로 @Autowired와 동일하게 동작한다(@Bean이 @Autowired를 포함한다고 보면됨!)
    - @Value는 필드, 수정자메소드, 메소드파라미터에서 사용가능