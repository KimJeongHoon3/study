# 토비의 스프링 vol2

- 1장 IoC 컨테이너와 DI
  - 왜 IoC?
    - 컨테이너가 오브젝트에 대한 제어권을 갖고있어서 IoC (코드가 오브젝트를 제어하지않음!)
  - IoC 컨테이너 = 어플리케이션 컨텍스트 = 빈 팩토리
    - 어플리케이션 컨텍스트 (빈 팩토리를 상속받고있음..)
      - 엔터프라이즈 애플리케이션 개발하는데 필요한 여러가지 기능 + 빈 팩토리
    - 빈 팩토리
      - 오브젝트 사이의 관계 설정
  - IoC 컨테이너 사용을 위해서는 메타정보가 필요하다. 여기서 메타정보는 빈을 어떻게만들지, 어떻게 동작하게할지를 정의한 정보다
  - 스프링 애플리케이션이란, POJO클래스와 설정메타정보를 이용해 IoC 컨테이너가 만들어주는 오브젝트의 조합이라고 할수있다!
    - <img src="Ioc_make.jpeg"/>
      - 리더만 잘 만들면 어떤 형태로도 빈 설정 메타정보를 작성할 수 있다!
  - IoC컨테이너는 오브젝트 단위로 관리함!
    - 클래스 하나에 여러 오브젝트를 만들수 있고, 이 오브젝트들을 IoC컨테이너가 관리하기 때문에 클래스단위가 아니라 오브젝트 단위로 관리된다.
  - IoC컨테이너 종류
    - StaticApplicationContext, GenericApplicationContext, GenericXmlApplicationContext, WebApplicationContext...
      - WebApplicationContext
        - 서블릿 컨테이너 : 요청을 받아서 서블릿을 동작시켜줌
          - 서블릿 : IoC 컨테이너에서 필요한 빈을 받아놓고 요청이 들어오면 해당 요청에 맞는 적절한 빈을 호출(web에서는 DispatcherServlet이 해당역할)
  - IoC 컨테이너 계층 구조
    - 트리모양의 계층구조를 사용하여 IoC 컨테이너는 하나 이상을 만들수 있다
    - 검색순서는 항상 자신이먼저! 그 다음이 직계부모(자신이 부모꺼 오버라이딩했다면 부모꺼 당연안불러온다~)
    - 웹 어플리케이션의 IoC 컨테이너 구성(p76참고)
      - 루트 applicationContext + 서블릿 컨텍스트(이거는 여러개될수있음. 부모컨텍스트가 루트 application context)
      - 꼭 반드시 두개이상을 사용해야하는것은 아님..
        - 스프링 웹기술을 사용하지않는다면 루트 애플리케이션 컨텍스트만 등록하면됨
        - 서블릿 컨텍스트 단일구조로 사용하기도함
  - 컨테이너가 자동등록하는 빈
    - ApplicationContext
    - BeanFactory
      - ApplicationContext도 BeanFactory를 상속받고있지만, 내부적으로 빈 팩토리 오브젝트를 별도로 만들어놓고 위임하는 방식으로 돌아가기때문에, BeanFactory를 직접적으로 주입받는객체랑 ApplicationContext의 BeanFactory 객체는 다르다!
    - ResourceLoader
      - 리소스 로드 가능
      - applicationContext가 상속받고있음
    - ApplicationEventPublisher
      - 컨테이너 안의 빈 오브젝트간에 이벤트 발생 & 전달받을수있는기능
      - 굳이 컨테이너에 의존적인 방법 사용할 필요가 없기에 거의 사용안함(필요하면 빈 사이에 독자적인 이벤트/리스터 구성을 사용하면됨)
    - systemProperties
      - JVM관련 설정값들
      - ```System.getProperty("")``` 와 같이 쓰는것이 좋음 (Property로 구현되어있기에, 타입으로 가져오기가좀.. 굳이 가져오려면 @Resource Properties systemProperties)
      - 해당 빈 이름은 사용하지말것! (systemProperties 는 빈이름등록금지)
    - sysetmEnvironement
      - 시스템 환경변수관련 (OS 종류나 서버환경 설정에 따라 달라질수있음)
      - ``` @Value(#{systemEnvironment['Path']}) String path; ```와 같이 사용가능
      - 해당 빈 이름은 사용하지말것! (sysetmEnvironement 는 빈이름등록금지)
  - 프로토타입과 스코프
    - 프로토타입
      - 생명주기 
        - 컨테이너가 생성은 해주지만, 그 이후의 관리는 주입받은 빈이 알아서 해야함
      - 용도
        - new 키워드로 ***매번 새롭게 생성***해 주어야할때, 컨테이너에 등록된 ***빈을 주입받아야 한다***면 프로토타입을 사용하자!
      - 사용방법
        - DI
          - @Scope에 proxyMode를 설정해줌
            - proxymode를 사용하면 보통 DI처럼 사용가능하며, 주입된 객체는 프록시패턴을 통해 만들어진 오브젝트이다. 이 오브젝트가 스코프에 적절히 맞추어 객체를 연결시켜준다
              - 겉으로만 봐서는 프록시 객체를 사용한것인지 당연 알수없음.. 하지만 내부적으로는 proxymode에 정의된대로 오브젝트를 연결해줌
              - *proxyMode 종류
                - ScopedProxyMode.INTERFACES : 프록시 빈이 인터페이스를 구현하고있고, 클라이언트에서 인터페이스로 DI받을때 사용 (jdk dynamic proxy 사용)
                - ScopedProxyMode.TARGET_CLASS : 프록시 빈 클래스를 직접 DI 할때 사용 (cglib 사용)
                  - 위 둘 차이 설명 : https://stackoverflow.com/questions/21759684/interfaces-or-target-class-which-proxymode-should-i-choose
                  - 결론은 인터페이스를 사용하고있으면 INTERFACES를, 그렇지않으면 TARGET_CLASS를 사용하면됨
        - DL(dependency lookup)
          - Provider\<T\> 사용
            - JSR-330(DIJ) 에 추가된 표준인터페이스
            - @Autowired로 주입받고 get()으로 가져오면 끝
  - 싱글톤, 프로토타입 외 스코프 (웹 환경에서만 의미가 있음)
    - 프로토 타입과는 달리 스프링이 초기화에서부터 ***제거***까지 모두 관리
    - 사용방법 : 프로토타입과 동일
    - 종류
      - 요청 스코프
        - 요청별로 독립적인 빈이 만들어짐.
        - 상태값을 저장해둬도 안전
      - 세션 스코프
        - Http 세션과 같은 존재 범위를 갖는 빈
        - 세션 타임이 종료될때까지유지되므로 로그인 정보나 사용자별 선택옵션 등을 저장해두기에 좋음
      - 애플리케이션
        - 서블릿 컨텍스트에 저장되는 빈 오브젝트
        - 컨텍스트가 존재하는 동안 유지되는 싱글톤 스코프와 비슷한 존재범위를 가짐
        - 멀티스레드에 주의할것
  - 빈 생명주기 메소드
    - 초기화 메소드
      - 빈 오브젝트 생성 + DI 완료된 이후 진행
      - @PostConstruct
    - 제거메소드
      - 컨테이너가 종료될때 호출. 빈이 사용한 리소스 반환하거나 종료전에 진행
      - @PreDestory
  - 빈의 종류
    - 애플리케이션 로직 빈 : 비지니스 로직, 서비스 오브젝트 , DAO..
    - 애플리케이션 인프라 빈 : 대개 스프링에서 제공하는 추상화 되어있는 빈.. 직접 로직작성은 안하고 애플리케이션 로직 빈에 영향을 주는 빈. 기술API도 여기 속함 ex) 트랜잭션, DataSource
    - 컨테이너 인프라 빈 : 스프링 컨테이너 기능을 확장해서 빈의 등록과 생성, 관계설정, 초기화 등의 작업에 참여하는 빈 ex) AOP
      - 빈 후처리기 구현체들이 여기에 속하겠지.. (ex. \<context:component-scan\> 설정했을때 생성되는 빈들)
  - 런타임환경과 프로파일
    - 환경에 따라 설정파일 외에도 등록하는 빈이 달라져야 할때가 있는데, 지정한 프로파일에 따라 빈이 생성될수 있도록 가능!
    - 런타임 환경은 애플리케이션 컨테스트에 새롭게 도입된 개념!
    - 컨텍스트 내부에 Environment 인터페이스를 구현한 런타임 환경 오브젝트가 만들어져서 빈을 생성하거나 의존관계를 주입할때 사용한다
      - 런타임 환경은 "프로파일"과 "프로퍼티 소스" 로 구성되는데, 환경에 따라 프로파일과 프로퍼티 소스가 다르게 설정된 Environment 오브젝트가 사용
      - 프로파일안에 환경에 따라 각기 구성되는 빈들을 정의해놓으면, 애플리케이션 컨택스트가 시작될때 지정된 프로파일을 실행시킴으로써 환경에 필요한 빈을 만드는개념이다!
        - @Profile("dev") 로 선언하면 spring.active.profile이 dev일때만 실행된다.. (활성 프로파일은 prod로 해놓으면 당연실행안됨)
        - 아무것도 지정하지않으면 어떤 프로파일이던 상관없이 실행
        - @Profile("dev","prod") 이렇게 여러개도 지정가능
  - 프로퍼티 소스
    - 스프링에서 사용되는 프로퍼티 종류
      - 환경변수
        - OS의 환경변수. OS 레벨에서 동일한 값을 전달해야할때 사용
        - System.getEnv()
      - 시스템 프로퍼티
        - JVM 레벨
        - System.getProperties()
      - JNDI
        - 웹 어플리케이션 레벨
      - 서블릿컨텍스트 파라미터
        - 웹 어플리케이션 레벨. JNDI값을 설정하기 번거로울때
        - web.xml에 서블릿 컨텍스트 초기 파라미터를 프로퍼티로 사용가능
        - \<content-param\> 
        - @Autowired ServletConetxt servletContext
      - 서블릿 config 파라미터
        - 해당 서블릿의 서블릿 컨텍스트에만 영향. 즉, 위의 종류중에 범위가 제일 좁음
        - \<init-param\>
        - @Autowired ServletConfig servletConfig
    - 프로파일의 통합과 추상화(Environment)
      - 프로퍼티의 종류와 그에 따라 달라지는 접근 방법을 프로퍼티 소스라는 개념으로 추상화
      - 이를 통해 일관된방식으로 접근. 동일한 이름이 있을 경우에 우선순위에 따라 정해짐!
      - 사용방법
        - Environment.getProperty()
        ```java
          @Autowired
          Environment env
          ..
          env.getProperty("os.name");
        ```
        - PropertySourceConfigurerPlaceholder 빈 등록 & @Value
        ```java
          @Value("${db.username}")
          private String userName;
        ```
      - @PropertySource("classpath:/database.properties")
        - 이렇게 가져올수있음
        - 컨텍스트에 기본적으로 등록되는 프로퍼티 소스보다 우선순위 낮음
          - 우선적용하고 싶은 프로퍼티있거나 기타 프로퍼티 관련한 내용은 아래 래퍼런스 참고할것!

      - 스프링부트에서 프로퍼티 활용하는 레퍼런스
        - https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config

           
  - 1장을 통한 기타팁
    - /WEB-INF/**/*Context.xml (web.xml)
      - WEB-INF 폴더 밑의 모든 서브폴더에 Context.xml로 끝나는 모든 파일을 찾는다
    - 스테레오타입 애노테이션 : 디폴트 필터에 적용되는 애노테이션
      - 종류
        - @Component 
        - @Service : 서비스계층에서 사용
        - @Controller : MVC 컨트롤러에 사용. 스프링 웹 서블릿에 의해 웹 요청을 처리하는 컨트롤러 빈으로 선정됨
        - @Repository : 데이터 엑세스 계층의 DAO 또는 repository 클래스에 사용. DataAccessException 자동변환과 같은 AOP 적용 대상을 선정하기 위해서도 사용
    - @Configuration 클래스에 @Bean으로 생성한 빈 오브젝트들을 @Bean으로 등록한 함수로 호출하게되면, 몇번을 호출하던 싱글톤으로 동일한 빈을 전달해준다.(프록시 적용! CGLib..) 그러나, @Component 클래스에 @Bean으로 생성된 오브젝트를 함수로 호출하게되면, 호출할때마다 새로운 오브젝트가 등록이된다!
    - component-scan 태그는 애노테이션 의존관계 설정을 지원한다(의존관계 설정도하고 필요에따라 빈도 등록하고..)
      - annotation-config 태그는 이미 등록된 빈의 메타정보에 프로퍼티 항목을 추가해주는 작업! 새로운 빈을 등록해주지는않음!
    - @Resource는 빈의 이름을 이용해서 빈을 찾음
    - @Autowired는 빈의 타입을 이용해서 빈을 찾음
      - @Inject는 JSR-300(DIJ) 에서 제공해주는데, 이는 Autowired 와 같은기능!
      - 생성자에서도 사용할수있는데, 생성자 여러개 있을때 어떤것을 Autowired 사용할 것인지 명시해주어야 에러가 안난다
      - 꼭 생성자를 이용해서 DI 방식을 사용하는것이 정답은아님!
        - 디폴트 값을 주고 선택적으로 DI할수있또록 만들어야할때는 수정자메소드 주입이 더 좋겟지?
      - 동일한 타입이 여러개 빈으로 등록록되어있으면, Set, List로 가져올수있다
        - Map<String,Object>로도 가져올수있는데 key에는 bean 이름이 들어감
      - @Qulifier
        - 기본적으로 bean으로 등록된 놈이 qulifier(한정자) 를 가지고있는지 찾고, 없으면 빈 이름으로 찾는다. 즉, @Qualifer는 빈 생성시 전달한다.. "Autowired를 사용했을때 특정 한정자에 의해 한정을 시킨다!" 로 qualifer를 이해하자..
          ``` java
          @Component
          @Qulifier("abc")
          class Kkk{
              ...    
          }
          ```
        - 빈에 부가적인 속성을 지정해주는효과있음
        - 스프링은 @Qualifier를 메타애노테이션으로 갖는 애노테이션도 @Qualifier 취급을 해준다!
        - Qualifer(한정자) 사용해서 주입하려하는데, 적절한 Qualifier를 사용해서 등록된 빈이 없다면, 그냥 빈 이름으로 찾아줌
      - 꼭반드시 bean이 주입되어야하는게 아니면 @Autowired의 required 엘리먼트를 false로! 
        ```java
            @Autowired(required=false) Printer printer;
        ```
      - @Bean 을 통해서 빈을 등록할떄, 선언한 메소드는 자동주입되므로 @Autowired와 동일하게 동작한다(@Bean이 @Autowired를 포함한다고 보면됨!)
    - @Value는 필드, 수정자메소드, 메소드파라미터에서 사용가능
    - 프로퍼티 파일을 이용한 값 설정
      - 수동변환(PropertyPlaceHolderConfigurer)
        - 프로퍼티 치환자(placeholder)를 사용
        - 빈 팩토리 후처리기에서 실행됨(빈 후처리기가 아님)
          - 빈 후처리기는 매 빈 오브젝트가 만들어진 직후에 오브젝트의 내용이나 오브젝트 자체를 변경할때 사용하고, 빈 팩토리 후처리기는 빈 설정 메타정보가 모두 준비됐을대 빈 메타정보 자체를 조작하기 위해 사용
          - property 파일을 읽어서 메타정보의 값 정보에서 치환자(${}) 를 후처리기 시점에 찾아서 적절한 value로 바꿔준다!
          - 빈 팩토리 후처리기가 빈 후처리기보다 앞서서 있는듯함
            - 필드에 @Value로 셋팅하였을때, 생성자 호출하는 시점에는 값이 주입되어있지않은데, 메소드 수정자 주입시에는 값이 주입되어있었음.. (더 확실히 알기위해서 좀더 찾아봐야할듯)
      - 능동변환(SpEL)
        - #{} 사용
        - 표현식을 사용해 다른 빈 오브젝트에 직접 접근할수도있음
          - ex) #{hello.name} (hello라는 빈 이름의 name 프로퍼티) 
    - 프레젠테이션 계층의 입력방식에 따라서 비지니스 로직을 담당하는 코드가 휘둘리지않고 독립적으로 존재하기 위해서는 최대한 도메인객체를 참조하도록 해야한다(도메인 객체만 잘 만들어져있다면...)
      - 컨트롤러에서 요청받은 데이터를 오브젝트에 담았을때, 해당 오브젝트에 도메인 객체를 담고있다면, 이는 컨트롤러에서 요청하는 데이터가 변경된다할지라도 서비스 계층에서 데이터를 사용하는데에 있어서 큰 변경이 없을것이다!
      - 그리고 여기에서 컨트롤러에서 요청시 데이터를 오브젝트에 담을때 새롭게 객체를 생성할텐데, 도메인 객체에 데이터를 셋팅하기위해서 DAO를 통해서 데이터를 select해 올 필요가 있을수있다. 이때 오브젝트는 요청마다 새롭게 생성되고, 컨테이너 등록된 빈(dao)을 사용해야하므로 프로토타입으로 사용하는것이 좋다!
    - @Import
      - @Configuration 클래스 가져온다! @Enable.. 클래스에서 많이 사용된다함
    - @Configuration은 각각 하나의 XML과 같다고 볼수있다! 설정의 성격에 따라서 잘 분리하자!! 
    - @EnableTransactionnManagement
      - 트랜잭션 사용할때 사용.. @Transactional 사용하기 위한 AOP 관련 빈들을 등록해줌
      - 스프링부트에서도 반드시 써야하는것인지 확인필요(어떤 의존성을 불러오면 자동으로 등록되는것같긴한데.. 확인필요하다!)
    - 프로퍼티 파일은 저장소에 올리지 말자! 그냥 sample properties만 올릴것!
    - 롤백 테스트는 내장형 DB로 확인하는것도 좋다!
    - -D 옵션은 JVM 옵션 (-Dspring.profile.active=prod)
    - 팩토리 빈을 통해서 빈을 등록하는 방법 정리(자세한 factory bean 관련 내용은 toby Spring vol 1을 참고할것!) : https://live-everyday.tistory.com/224

- 2장 데이터 엑세스 기술 (해당 기술의 자세한 내용은 필요할때 다시 참고하면 좋을듯)
  - DAO 패턴
    - 도메인 오브젝트만을 사용하는 인터페이스를 통해서 데이터 엑세스 기술을 외부에 노출하지않도록 만드는것! => POJO => 기술에 영향x, 단위테스트 용이
    - 예외도 checked error 나 특정 기술에 종속되어있는 에러x.. 또한 되도록 런타임에러로뺄것!
      - 런타임 에러로빼는이유는 데이터 엑세스 중에 발생하는 예외는 대부분 복구할수 없기때문!
  - JDBC
    - 스프링의 JDBC 접근방법
      - JdbcTemplate(Datasource)
        - 파라미터 소스
          - 쿼리에서 값이 매번 달라지는 경우, 치환자를 만들어서 바인딩하는 방법을 사용하는게 좋은데, 바인딩을 위해 넘겨주는 값을 파라미터 소스라고 한다
          - ex) INSERT INTO MEMBER(ID,NAME,POINT) VALUES(:id,:name,:point); 라면, :id, :name, :point에 값을 바인딩해줌
          - 종류
            - Map/MapSqlParameterSource : key, value 값으로 전달해주고, key값으로 바인딩함 ex) key가 id,name,point 이렇게 들어가있어야함
            - BeanPropertySqlParamenterSource : 자바빈 스타일의 오브젝트를 전달해주면 해당 필드 이름으로 바인딩함
        - RowMapper
          - 데이터를 읽어올때 BeanPropertyRowMapper를 넘겨주면, BeanPropertyRowMapper를 생성할때 넘겨준 클래스를 바탕으로 데이터를 바인딩하여 해당 객체를 리턴해줌
      - SimpleJdbcInsert
        - DB메타정보 활용하여 db에 insert하는데 용이하게 해줌
        - insert 할때 일일이 컬럼 일일이 추가해서 쿼리만들 필요없음! 어떤 테이블에 insert할건지만 명시해주면 해당 테이블의 메타정보를 가져와서 셋팅
        - 이를 통해서 자동증가 컬럼은 제외할수도잇으며, 자동증가 컬럼의 현재값도 가져올수있다!
      - SimpleJdbcCall
        - 프로시저나 함수 콜
    - 스프링 JDBC가 해주는 작업
      - connection 열기와 닫기
        - connection 열고 닫는 시점은 스프링 트랜잭션 기능과 맞물려서 결정
      - statement(preparedstatement) 준비와 닫기
      - statement 실행
      - resultset 루프
      - 예외처리와 변환
        - 런타임예외로 변경
        - 일관된 DataAccessException 계층구조내의 예외로 전환
      - 트랜잭션 처리
      - *개발자가 해야할작업 : SQL, SQL에 넘겨줄 파라미터, 실행결과를 어떤 오브젝트에서 받을것인지, DB 커넥션 가져올 DataSource 정의
    - 스프링 JDBC DAO
      - 도메인 오브젝트 or 테이블 단위로 DAO 생성! => DAO는 여러개
  - ORM
    - 스터디필요
  - 트랜잭션
    - 트랜잭션 추상화와 동기화
      - 트랜잭션 추상화 
        - 트랜잭션 서비스의 종류나 환경이 바뀌더라도 트랜잭션 사용하는 코드는 그대로유지!
        - PlatformTransactionManager(구현체로는 jdbc, jpa, hibernate 등이있음)
          - 구현체
            - DataSourceTranactionManager
            - JpaTransactionManager
            - HibernateTransactionManager
            - JtaTransactionManager
              - 여러개 DB를 사용할때, 꼭 DB뿐 아니라 JMS와 DB 등 짬뽕된 트랜잭션이 필요할때, 여러대 서버에서 분산되어 진행되는 작업 등 트랜잭션으로 연결이 필요할때 사용!
              - 이를 지원하는 WAS를 사용하거나, 독립적으로 사용할수있도록 해주는 프레임워크가 필요함
          - 만약 Datasource가 다르고 각 Datasource에 대한 트랜잭션을 사용해야한다면 당연히, 각 Datasource를 가지고 트랜잭션매니저를 등록하면됨. 즉, 2개 등록..
            - @Tranactional 에서 사용해야할 트랜잭션 매니저를 지정하면됨
      - 트랜잭션 동기화
        - 트랜잭션을 일정 범위 안에서 유지해주고, 어디서든 자유롭게 접근할수있게 만들어줌!(이로 인해 전파(propagation) 옵션을 활용가능)
    - 트랜잭션 경계설정 방법
      - 코드로짜기
        - PlatformTasactionManager를 직접사용해도되나, try catch 블록을 써야하므로 TransactionTemplate을 이용하면 좋음
        - TransactionTemplate(PlatformTrasactionManager)
        - 트랜잭션 관련 ***디버깅할때는 PlatformTasactionManager***를 사용하는것이 좋은데, 해당 객체에서 getTransaction()으로 전달받은 ***TransactionStatus*** 객체를 이용하면 현재 트랜잭션이 새로 시작된것인지 기존 트랜잭션에 참여한것인지 또는 종료된 것인지 모두 확인가능!
      - 선언적 트랜잭션 경계설정
        - 선언적 트랜잭션 경계썰정은 트랜잭션 프록시빈(빈 후처리기에서 프록시 오브젝트를 반환) 덕분에 가능!
        - 방법
          - xml 설정파일에 pointcut, advice 정의 
            - pointcut은 기본적으로 ***인터페이스***에 적용!
              - 스프링AOP의 동작원리인 JDK 다이내믹 프록시는 인터페이스를 이용하여 프록시를 만들기떄문!
              - 그러나, 인터페이스없이 프록시를 만들수도있긴함...
              - *특정 클래스로 지정해서 aop를 적용하면, 트랜잭션 적용과 상관없는 메소드도 포인트 컷의 선정대상이된다.. 불필요한 리소스 소모.. 인터페이스 분리 원칙에 따라 클라이언트가 필요한(실제적으로 DB의 데이터를 핸들링하는 기능)것만 나타나있고, 바로 그 기능들이 트랜잭션 적용대상들이여야하므로 인터페이스를 기준으로 적용하는것이좋음!(하지만 이게 또 어노테이션 쓸때는 꼭 인터페이스에 적용하는게 좋지않음..)
          - 어노테이션(@Transactional)
          - 참고사항
            - 프록시 모드 (JDK 다이내믹 프록시 vs CGLIB)
              - CGLIB 사용 
                - 보통 인터페이스를 사용하지않을때, 클래스 레벨의 프록시를 사용하도록해줌(런타임 바이트 코드 생성기법을 이용해서 적용함)
                - 상속해서 프록시를 만드는 개념이기때문에, final로 선언된 클래스는 안됨
                - public으로 정의된 모든 메소드에 적용이 되기때문에, 수정자와 같은, 트랜잭션적용이 필요없는 메소드도 적용이 됨
                - @EnableTransactionManager에 Proxy-target-class를 true로 변경해야하고(기본값 false) 인터페이스가 아닌 클래스에 선언해야한다
                  - 만약 인터페이스에 적용하고 proxy target class를 true로햇다면 트랜잭션 안먹는다
                  - 또한 proxy target class를 별도로 설정하지않고 클래스에만 선언하게되면 JDK 다이내믹 프록시로 진행됨
            - AOP 방식(프록시 vs AspectJ)
              - 프록시
                - 스프링의 AOP 방식
                - CGLib든 JDK 다이내믹 프록시든 모두 어쨋든 프록시 사용하는것.. 그래서 해당 클래스 내부에서 바로 트랜잭션 적용되어있는 자신을 호출하면 트랜잭션 안먹는다..(타깃오브젝트의 자기호출) 외부에서 호출해주어야함..
              - AspectJ
                - 프록시를 타깃 오브젝트 앞에 두는 방식이 아닌, 타깃 오브젝트 자체를 조작해서 부가기능을 직접 넣는 방식. 처음부터 타깃 오브젝트의 클래스에 부가기능을 가진 소스코드가 있었던 것처럼 만들어줌
                - 프록시 방식을 사용할때 외부에서 호출해주어야하는 한계점을 이를 통해서 해결가능
                - @EnableTransactionManager에 mode를 aspectJ로 해주어야함
                  - 클래스 레벨, 클래스 메소드레벨에 적용해야함(인터페이스x)       
      - 트랜잭션 속성
        - 전파(propagation)
          - 트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성
        - 격리수준(isolation)
          - 트랜잭션이 진행될때 트랜잭션의 작업결과를 여타 트랜잭션에게 어떻게 노출할 것인지를 결정
          - 예를들어, 격리수준이 REPEATABLE_READ라면, 내가 읽은 데이터를 다른 트랜잭션이 수정하는것을 막아줌. 하지만 다른 트랜잭션이 새로운 로우를 추가하는것은 제한하지않는다..
        - 제한시간(timeout)
        - 읽기전용(read-only)
          - 성능 최적화도된다함..
          - 쓰기작업 막을수있음
        - 롤백예외(rollbackFor)
          - 특정 에러클래스를 발견하면 롤백하라!
          - 기본적으로 런타임에러만 롤백하고, checked error는 롤백대상이 아닌데, 여기서 지정해주면 해당 checked error도 롤백대상이됨
          - @Transactional(rollbackFor=NoSuchMemberException.class)
        - 커밋예외
          - 런타임 예외라도 발견하면 롤백하지말고 커밋해!
          - 사용방법은 롤백예외랑 동일
      - 데이터 엑세스 기술 트랜잭션의 통합
        - 트랜잭션 매니저별 조합가능기술
          - 하나의 트랜잭션 매니저를 사용해서 여러 DA 기술이 짬뽕되어있는 상태에서도 트랜잭션 적용가능!
          - 물론, ***같은 Datasource***를 봐야함!
          - 두개 이상의 여러DB 사용할때도 트랜잭션 필요하다면 JTA 사용해야함 
        - ORM과 비ORM DAO를 함께 사용할때 주의사항
          - ORM은 바로 DB에 반영하지않고 캐시로 수행해야할 작업을 가지고있다가 일괄적으로 반영한다. 그로인해서 비ORM과 서비스내에 같이 있다면 생각했던 결과와 다를수있다(비ORM은 바로 DB에 반영)
          - 이를 해결하기위해 비ORM과 같이 사용할때는 ORM의 flush()를 사용해서 바로 DB에 반영시켜주는것이 좋다. (이또한 AOP로 셋팅이 가능하다하는데, 자세한건 JPA와 같은 ORM 스터디가 필요할듯!)
           
  - 2장을 통한 기타 팁
    - 서버가 제공해주는 DB풀을 사용해야하는 경우에는 JNDI를 통해 서버의 DataSource에 접근!
    - ORM : 오브젝트와 RDB사이에 존재하는 개념과 접근 방법, 성격의 차이 때문에 요구되는 불편한 작업을 제거해줘서, 자바 개발자가 오브젝트를 가지고 RDB에 적절한 형태로 변환하거나 반대로, RDB에 저장되어 있는 정보를 자바 오브젝트가 다루기 쉬운 형태로 변환해주는 기술!
      - ORM 사용하면 SQL문장을 직접 작성x
      - 즉, 쉽게 이야기하면 자바 오브젝트와 RDB사이에 ORM 프레임워크가 적절히 맵핑해주어, 데이터를 오브젝트 관점에서 핸들링 할수있는것!
      - @EnableTransactionManager를 통해서 트랜잭션 AOP관련한 인프라 빈들이 등록됨.. 스프링부트에서는 jdbc사용하면 자동으로 등록이되는듯..