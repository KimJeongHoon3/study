스프링 프레임워크 핵심기술
- IoC 컨테이너 1부 
  - IoC(Inversion Of Control)란 : 제어의 역전.. 직접 new 쓰지않도록.. 의존성을 낮추는!
    - 스프링 IoC 컨테이너
      - bean들을 담고있는것이 container.. container가 있기때문에 bean들을 가져와서 사용할수있음
      - BeanFactory 클래스가 IoC의 핵심
      - 의존성을 낮춰주면 아직 개발이 안된 상태에서도 단위테스트가 가능(with Mock) 
    - Bean 
      - 스프링 IoC 컨테이너가 관리하는 객체
      - 의존성 주입을 하기위해서는 Bean이 되어야함
      - 싱글톤으로 생성해야할때 Bean을 사용하면 상당히 편리하게 가능(하지만 싱글톤으로만 생성되는것은 아님)
      - Scope
        - 싱글톤 : 하나만
        - 프로토타입 : 매번 다른 객체
      - 라이프사이클 인터페이스 지원
        - ex) @PostConstruct : bean이 만들어지자마자 호출되는곳 

    - ApplicationContext
      - BeanFactory 에 비해 추가로 더 많은 기능을 가짐..
        - BeanFactory에서는 bean을 가져오는것 등 bean에 관한 기본적인 기능사용 가능
        - https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html
      - https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html

- IoC 컨테이너 2부 : ApplicationContext와 다양한 빈 설정 방법
  - IoC 컨테이너의 역할
    - bean 인스턴스 생성
    - 의존관계 설정
    - bean 제공
  - 스프링 IoC 컨테이너는 빈 설정파일이 필요하다
  - 처음 스프링에서는 모든 bean을 xml에 따로 등록이 필요했다(id, scope, property로 넣을지.. 등등)
  - 이게 너무 복잡하니.. xml에서 context:component-scan 이 나옴! 지정한 패키지에서부터 스캔하여 bean으로 만들어라!
  - 좀더 나아가서.. 자바 소스에서 빈을 설정하도록하자해서 나온게 @Configuration 을 사용하여 해당 클래스에 @Bean으로 만드는것!


- IoC 컨테이너 3부 : @Autowire
  - @Autowire 는 빈을 찾아 주입해줌..
    - 적용 경우의수
      - 해당타입의 빈이 없는경우 : x
      - 해당타입의 빈이 한개인 경우 : o
      - 해당 타입의 빈이 여러개인 경우
        - 같은 이름의 빈 찾으면 : o
        - 같은 이름 못찾으면 : x
    - 같은 타입의 bean이 여러개 일때
      - @Priamry : 해당 어노테이션있는것으로 우선적용
      - 해당 타입의 빈 모두 주입 : 동일한 타입을 여러개 가지고잇는경우(인터페이스 구현을 여러개..) 그냥 @autowire를 사용하여 list로 받으면 해당 타입을 구현한 모든 bean을 받을수있다..
      - @Qulifier : 이름 지정가능
    - "required=false" 라는 옵션을 사용하면 해당 bean이 반드시 주입되지않아도 기동하는데 문제없도록해줌..(기본값은 "required=true")
    - AutowiredAnnotationBeanPostProcessor​ extends BeanPostProcessor
      - 스프링이 제공하는 @Autowired와 @Value 애노테이션 그리고 JSR-330의 @Inject 애노테이션을 지원하는 애노테이션 처리기.
    - ***클래스의 bean이 생성될때, 해당 클래스 내부에 적용되어있는 빈 생성시 전처리 로직을 타는애들(ex. @autowired, @PostConstruct 등) 중 @Autowired와 같이 빈 주입이 필요하다면, 해당 bean이 생성되어있지않을때 먼저 생성해준다..***
  - @PostConsturct와 같은 어노테이션을 통해서 bean이 생성될때 특정 작업을 가능하게 할수있는데, 아래 라이프사이클에서 postProcessBeforeInitialization 의 구간에서의 작업이다.
  bean을 만들고 또 initialization 하는게 있다하는데, 그 구간임 (@Autowired도 동일한구간에서 이루어짐, 그러나 @PostConstruct가 @Autowire보다 이후에 실행)
  (어떻게 bean이 생성되어 돌아가는지 좀더 살펴보면좋을듯)
  - Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:
      1. BeanNameAware's setBeanName
      2. BeanClassLoaderAware's setBeanClassLoader
      3. BeanFactoryAware's setBeanFactory
      4. EnvironmentAware's setEnvironment
      5. EmbeddedValueResolverAware's setEmbeddedValueResolver
      6. ResourceLoaderAware's setResourceLoader (only applicable when running in an application context)
      7. ApplicationEventPublisherAware's setApplicationEventPublisher (only applicable when running in an application context)
      8. MessageSourceAware's setMessageSource (only applicable when running in an application context)
      9. ApplicationContextAware's setApplicationContext (only applicable when running in an application context)
      10. ServletContextAware's setServletContext (only applicable when running in a web application context)
      11. postProcessBeforeInitialization methods of BeanPostProcessors
      12. InitializingBean's afterPropertiesSet
      13. a custom init-method definition
      14. postProcessAfterInitialization methods of BeanPostProcessors

  - On shutdown of a bean factory, the following lifecycle methods apply:
      1. postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors
      2. DisposableBean's destroy
      3. a custom destroy-method definition

- IoC 컨테이너 4부 : @Component와 컴포넌트 스캔
  - Component scan을 통해서 어디서부터 어디까지 스캔할것인지, 그리고 어떤 컴포넌트를 제외할것인지(필터링) 지정가능
  - 실제 스캐닝은 ​ConfigurationClassPostProcessor​라는 ​BeanFactoryPostProcessor​에 의해 처리 됨.
    - BeanPostProcessor와다름! 이거보다 이전에 실행
  - 컴포넌트 스캔 대신, 펑션을 사용하여도 가능
```java
public static void main(String[] args) {
        new SpringApplicationBuilder()
        .sources(Demospring51Application.class)
        .initializers((ApplicationContextInitializer<GenericApplicationContext>) applicationContext -> {
            applicationContext.registerBean(MyBean.class); //처음 구동시에 속도가 컴포넌트스캔과같이 느리지않는다함.. 외부에서 무언가 주입해야할때 사용하면 좋을듯함.. 근데 그냥 @Bean으로 등록하는게 좀더 나을듯함....
        })
        .run(args);
}
```

- IoC 컨테이너 5부 : 빈의 스코프
  - Scope
    - 싱글톤 : 기본값
      - ApplicationContext 초기 구동시 인스턴스 생성하기때문에, 초기 구동시 Scope이 싱글톤인게 많으면 좀 오래걸릴수도있음
      - 스레드에 안전하지않으니 주의할것
    - 프로토타입 : 매번 새로운 인스턴스 생성
      - 싱글톤 Scope 에서 Proto Scope의 bean을 참조할때.. 어떻게되는가?
        - 자바소스 참고
      - 생명주기가 긴(like 싱글톤) 객체 안에서 생명주기가 짧은(like 프로토타입) 것들을 관리해야할때는 아래 3가지를 활용할것
        - scoped-proxy
        - Object-Provider
        - Provider(표준)
        - 참고 
          - https://www.baeldung.com/spring-inject-prototype-bean-into-singleton

- IoC 컨테이너 6부 : Environment 1부. 프로파일
  - ApplicationContext 에서 Environment를 가져올수있다
  - Environment
    - 프로파일
      - prd, stg, dev 등등 설정가능
      - @Profile("name") 을 통해서 빈 생성시 어떤 프로파일일때 생성할지를 결정해줄수있음
      - 일종의 그룹을 만들수있다!
      - -Dspring.profiles.active="name"
      - 프로파일 정의하기
        - 클래스에 정의
          - @Configuration @Profile(“test”)
          - @Component @Profile(“test”)
        - 메소드에 정의
          - @Bean @Profile(“test”)
      - 표현식
        - ! (not) ex. @Profile("!prod")
        - & (and)
        - | (or)

- IoC 컨테이너 6부 : Environment 2부. 프로퍼티
  - 프로퍼티
	- 다양한 방법으로 정의할수있는 설정값
	- Environment를 통해서 소스설정 및 프로퍼티 값 가져올수 있다!
    - 프로퍼티에는 우선순위가 있으며, 계층형으로 
	- 스프링에서 @PropertySource를 통해서 Environment의 프로퍼티를 추가할수있음!
	- Environment를 기반으로 SpringBoot에서는 @Value로 해당 프로퍼티값을 가져올수있음!
	
- IoC 컨테이너 7부 : MessageSource
  - MessageSource : 국제화(i18n) 기능을 제공하는 인터페이스
	- ApplicationContext는 MessageSource를 상속받고있음..
	- 스프링부트 사용시 property의 이름만 적절히 지정하면 알아서 인식..
	  - messages.properties
	  - messages_ko_kr.properties(MessageSource.getMessage에서 Locale을 KO_KR로 설정하면 이거 읽어옴)
	- Reloading기능이있는 메세지 소스 사용도 가능 
```java
@Bean
public MessageSource messageSource() {
	var messageSource = new ReloadableResourceBundleMessageSource();
	messageSource.setBasename("classpath:/messages");
	messageSource.setDefaultEncoding("UTF-8");
	messageSource.setCacheSeconds(3);
	return messageSource;
}
```

- IoC 컨테이너 8부 : ApplicationEventPublisher
  - ApplicationEventPublisher : 이벤트프로그래밍에 필요한 인터페이스 제공. 옵저버패턴구현
    - ApplicationContext는 ApplicationEventPublisher 를 상속받고있음,,
	  - ApplicationEventPublisher.publishEvent(Object obj)
	  - ApplicationEventPublisher.publishEvent(ApplicationEvent event) //4.2이하
	- 이벤트처리방법
	  - @EventListener 어노테이션을 사용하여 특정 이벤트처리가능 
	  - 기본적으로는 synchronized.. 여러곳에서 동일한 이벤트를 listen 하고있으면 순차적으로 실향
        - 순서정하고싶으면 @Order를 사용하면됨
        - 비동기로 실행하고싶다면 @Async (@Async를 사용하기위한 @EnabledAsync와 되도록이면 @Async사용을 위한 스레드풀도 설정해줄필요있음)
    - 스프링이 제공하는 기본이벤트
	  - ContextRefreshedEvent: ApplicationContext를 초기화 했더나 리프래시 했을 때 발생.
      - ContextStartedEvent: ApplicationContext를 start()하여 라이프사이클 빈들이 시작 신호를 받은 시점에 발생.
      - ContextStoppedEvent: ApplicationContext를 stop()하여 라이프사이클 빈들이 정지 신호를 받은 시점에 발생.
      - ContextClosedEvent: ApplicationContext를 close()하여 싱글톤 빈 소멸되는 시점에 발생.
      - RequestHandledEvent: HTTP 요청을 처리했을 때
***좀더 돌아가는거 확인해보자***

- IoC 컨테이너 9부 : ResourceLoader
  - ResourceLoader : 리소스를 읽어오는 기능을 제공하는 인터페이스
     