자바의정석_객체지향프로그래밍1

- 객체지향언어
  - ***실제세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용*** 이라는 기본개념을 전제로함
  - 사물의 속성과 기능을 분석하여, 데이터와 함수로 정의
  - 재사용성, 유지보수, 중복코드의제거. 이 3가지 관점으로 보면 좋음
  - 장점
    - 코드의 재사용성이 높고 유지보수 용이 => 프로그램 개발과 유지보수에 시간과 비용을 개선
- 클래스와 객체
  - 클래스
    - 정의 : 객체를 정의 해놓은것
    - 용도 : 객체를 생성하는데 사용
  - 객체
    - 정의 : 클래스에 정의된 내용대로 메모리에 생성된것
    - 용도 : 객체가 가지고있는 기능과 속성에 따라 다름
  - 인스턴스
    - 객체를 만드는과정을 클래스의 인스턴스화 라고함
    - 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스 라고함
    - 인스턴스와 객체는 같은의미지만, 엄밀히 이야기하면, 객체는 인스턴스를 대표한다고 볼수 있고, 인스턴스는 어떤 클래스로부터 만들어진것임을 강조하는 보다 구체적인 의미를지님. (굳이 구분할필요는 없음)
  - 인스턴스를 생성하는것은 new 키워드로 가능하며, 생성되엇을때 해당 인스턴스를 참조하는 참조변수("CustomClazz t"에서 t가 참조변수) 는 생성된 인스턴스의 주소값을 가지고있게된다!
  - 즉, 인스턴스를 다루기위해서는 참조변수가 반드시필요하다! 또한, 당연히 참조변수 타입은 인스턴스 타입과 일치해야한다!
  - 참조변수에 주소를 할당하고있지않은 인스턴스는 GC가 적절한 시점에 없애버린다(heap영역에 올라가있는거 없앰)
- 변수와 메서드
  - 변수의 종류
    - 멤버변수 : 클래스영역
      - 클래스 변수(static 변수)
        - 해당 클래스를 사용하려할때, 최초로 한번 해당 클래스가 메모리에 올라가는데(메모리의 메소드(static)영역) 그때 만들어짐.. 그리고 어플리케이션 종료시까지 유지
        - ***클래스이름.클래스변수*** 이렇게 사용할것! 참조변수로도 사용가능은하나, 헷갈리니깐 이렇게!
      - 인스턴스 변수 
        - static이 붙지않은 변수로, 인스턴스가 생성되었을때 만들어짐
    - 지역 변수 : 멤버변수가 아닌 모든 변수(클래스 영역 이외의 영역으로 메서드, 생성자, 초기화 블럭 내부 등)
      - 매개변수
        - 매개변수로 들어오는것은 기본적으로 넘겨받은 데이터를 해당 변수로 복사하는 작업이 이루어진다.. 그리고 해당 메서드 내부에서만 사용가능하다
          - primitive 타입은 그대로 값이 복사되고, 참조변수는 인스턴스의 주소가 복사된다!
          - 해당 메서드 내부에서 작업한 결과값 여러개를 리턴해야한다면, 참조변수를 매개변수에 넘겨주어 해당 참조변수에 저장하는것을 생각해볼수있음!
        - ***매개변수의 값이 적절한것인지 확인하는 작업은 반드시 필요!!!***
          - 대충 이렇게 넘어오겠지 생각하면안되고! 적절한 예외처리나 유효성검사를 해주어야한다!
        
  - 메서드 왜씀?
    - 높은 재사용성
    - 중복코드제거
    - ***프로그램의 구조화***
      - 메서드를 통해 문장들을 작업단위로 나눠서 해당 메서드가 어떤 작업을 하는지 명시적으로, 직관적으로 메서드를 보고 알수있어야.. 
  - JVM 메모리구조
    - JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받는다. 그리고 받은 메모리를 용도에 따라 여러 영역으로 나누어 관리함!
    - 3가지 주요영역
      - 메서드 영역
        - 프로그램 실행에 어떤 클래스가 사용되면, JVM은 해당 클래스파일(.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 여기에 저장.. 이떄, 클래스의 클래스변수도 이 영역에 함께생성
      - 힙(heap)
        - 인스턴스가 생성되는공간.. 인스턴스는 모두 여기에 생성
        - 가비지 컬렉션이 일어나는곳
      - 호출스택(call stack 또는 execution stack 이라고도함)
        - 메서드의 작업에 필요한 메모리 공간을 제공
        - 메서드가 호출되면, 호출된 메서드를 위한 메모리가 여기에 생성.. (메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장)
        - 메서드가 작업 마치면 할당된 메모리 공간을 반환됨
          - LIFO
          - 호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드
          - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드
  - 재귀호출
    - 반복문으로 대체가능하나 재귀호출이 주는 논리적 간결함이 있기때문에 사용
    - 하지만, 반복문은 그저 문장을 반복해서 수행하는것이지만, 재귀호출은 매개변수 복사와 종료 후 복귀할 주소저장 등 추가로 필요한 작업들이 있기때문에 반복문보다 수행시간이 오래걸린다
    - 또한 너무 많이 사용하게되었을때, 콜 스택이 그만큼쌓이는것이기 때문에, 스택오버플로우 에러가 날수있다
    - 결론은 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에만 사용할것!
  - 클래스 메서드(static 메서드)와 인스턴스 메서드
    - 클래스 메서드
      - 굳이 인스턴스 변수나 메서드를 사용하지않는다면, 클래스 메서드로 만드는것을 고려할것! (굳이 객체까지 만들필요가없다면!)
      - 인스턴스 만들지 않아도 사용가능
    - 인스턴스 메서드
      - 인스턴스 변수와 과련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드
      - 인스턴스 변수를 사용하려면 인스턴스가 생성되어야하므로 당연히 인스턴스 메서드 또한 인스턴스가 생성되어야한다
- 오버로딩
  - 조건
    1. 메서드 이름이 같아야함
    2. 매개변수의 개수 또는 타입이 달라야함
    - *반환타입은 오버로딩 구현하는데 상관이없다! 즉, 동일한 메서드이름+파라미터 로 반환타입만 다르게하면 중복에러난다
  - 장점
    - 같은 기능이라면, 매개변수가 달라도 같은 메소드명으로 처리하여, 사용자입장에서 헷갈리지않을수있음
  - 가변인자와 오버로딩
    - 가변인자
      - 타입... 변수명
        - ex. public void methodName(String... str)
        - 가변인자를 매개변수 중에서 제일 마지막에 선언해야한다!
      - 가변인자는 내부적으로 배열을 사용함.. 호출할때마다 새로 배열을 생성하니 사용시 주의를 요함
    - 가변인자가 있는것을 오버로딩할때는, 매개변수를 구분하지 못할수있으니 주의해야한다
      - ex) 
        ```java
            static String concatenate(String delim, String... args){
                ...
            }

            static String concatenate(String... args){
                ...
            }

            // 매개변수가 구분할수 없기때문에 오버로딩이 정상적으로 안되고 컴파일 에러남!

        ```
- 생성자
  - 생성자는 인스턴스가 생성될때 호출하는 인스턴스 초기화 ***메서드*** 이다
    - 여기서 인스턴스 초기화는 인스턴스변수들을 초기화하는것임
  - Card c = new Card(); 가 내부적으로 수행되는과정
    1. 연산자 new에 의해서 메모리(Heap)에 Card 클래스의 인스턴스가 생성된다
    2. 생성자 Card()가 호출되어 수행
    3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다 
  - 기본생성자는 명시적으로 아무런 생성자가 없을때 컴파일러가 알아서 만들어주었기때문.. 만약 명시적으로 선언한 생성자가있으면 컴파일러는 기본생성자를 만들지않는다
  - 생성자에서 다른 생성자 호출하기
    - 조건
      - 생성자의 이름으로 클래스이름 대신 this(\[매개변수\])를 사용해야한다 (메소드 호출하듯이 사용하면 당연안됨..)
      - 한 생성자에서 다른 생성자를 호출할때는 반드시 첫줄에서만 호출이 가능!
        - 다른 생성자를 첫줄에서만 호출이 가능하도록 한 이유는, 생성자내에서 초기화 작업도중에 다른 생성자를 호출하게되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화를 할 것이므로 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질수있기때문..(굳이 겁나 친절하면서 합리적..)

- 변수의 초기화
  - 멤버변수와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적!
  - 멤버변수 초기화 
    - 방법
      - 명시적 초기화 : 말 그대로 선언한곳에 명시적으로 바로 값 넣어서 초기화하는것
      - 생성자 : 생성자를 통해서 초기화하는것
      - 초기화 블럭 : 조건문, 반복문, 예외처리구문 등을 자유롭게 사용할수있기때문에 복잡한 초기화에 사용가능
        - 인스턴스 초기화블럭 
          - 인스턴스 생성시 초기화 블럭을 통해서 초기화 (인스턴스 생성시마다 수행)
          - 여러 생성자에서 공통으로 사용하고있다면, 여기로 빼면좋음
          - 생성자보다 먼저 수행됨!
        - 클래스 초기화 블럭 
          -  클래스 로딩시 클래스 초기화 블럭을 통해서 초기화 (1회만 수행)
        ```java
            class Init{
                static int staticInt=1; //명시적 초기화
                int instanceInt=2;

                static{ //클래스 초기화블럭
                    staticInt=3;
                }

                {//인스턴스 초기화 블럭
                    instanceInt=4;
                }

                Init(int constructorInt){ //생성자 초기화
                    instanceInt=constructorInt;
                }

               

            }
        ``` 
    - 초기화 시기 및 순서
      - 클래스변수
        - 초기화시점
          - 클래스가 처음 로딩될때 단 한번 초기화
        - 초기화순서
          - 기본값 -> 명시적 초기화 -> 클래스 초기화블럭
      - 인스턴스변수
        - 초기화시점
          - 인스턴스가 생성될때마다 각 인스턴스별로 초기화가 이루어짐
        - 초기화순서
          - 기본값 -> 명시적 초기화 -> **인스턴스 초기화 블럭** -> 생성자
      - *클래스변수들은 method area에 올라가고, 인스턴스 변수들은 heap area에 올라감
      - **클래스변수는 인스턴스변수보다 항상 먼저 생성되고 초기화된다!! (당연한이야기..)
- 기타 팁
  - 클래스 설계시 고려사항
    1. 클래스를 설계할떄, 멤버변수 중 모든 인스턴스에 공통으로 사용하는것에 static을 붙인다
       - 모든 인스턴스에서 값이 동일하게 유지되고 이를 참조해야한다면 static을 붙임
    2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할수 있다
       - 클래스변수는 클래스가 메모리에 올라갈때 자동적으로 생성되니깐!
    3. 클래스 메서드는 인스턴스 변수를 사용할수 없다
       - 클래스 메서드는 인스턴스가 생성되지않아도 사용할수 있기때문에, 클래스메서드가 호출될때 인스턴스 변수는 생성이 안되어있을수 있다! 그래서 클래스메서드에서 인스턴스 변수나 메서드 사용못함(당연 반대는 가능)
    4. 메서드 내에서 인스턴스 변수를 사용하지않는다면, static을 붙이는것을 고려한다
       - static이 붙어있으면, 메서드 호출시간이 짧아져서 성능이 향상됨
       - 인스턴스메서드는 실행시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기때문에 static과 비교하여 좀더 시간이 걸린다
  - 클래스 내에서 this
    - this는 참조변수로 인스턴스 자신을 가리킴(주소가 저장)
    - 그렇기때문에 인스턴스가 되어야 사용가능하고, 당연히 인스턴스 멤버들만 사용가능
    - 생성자를 포함한 모든 메소드에는 this가 **지역변수**로 숨겨져있음
    - this(\[매개변수\]) 는 this와 다르다!! this는 참조변수, this(\[매개변수\]) 생성자이다!
  - char의 기본값은 "\u0000" 이다
