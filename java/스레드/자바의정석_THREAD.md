자바의정석_THREAD

- 프로세스와 스레드
  - 프로세스 : 자원(프로그램을 수행하는데 필요한 데이터와 메모리 등)+스레드
  - 스레드 : 프로세스의 자원을 이용해서 실제 작업을 수행. 
    - 스레드가 작업을 수행하는데있어서 개별적인 메모리 공간을 필요로하기때문에, 프로세스의 메모리 한계에 따라 생성할수있는 스레드 수도 제한됨

  - *멀티테스킹 : 여러개의 프로세스가 동시에 실행되는것!(DOS는 한가지작업만 가능..)
  - **멀티스레딩 : 여러 스레드를 사용하는것
    - 장점
      - CPU 사용률 향상
      - 자원을 효율적으로 사용
      - 사용자에 대한 응답성 향상(메신저에서 채팅하면서 파일다운로드)
      - 작업이 분리되어 코드 간결(채팅하는부분 / 파일다운로드하는 부분 나눌수있음)
    - 단점
      - 프로세스 내에서 자원을 공유하기때문에 동기화, 교착상태와 같은 문제들을 고려해서 개발해야함
- 스레드의 실행
  - start를 호출한다고해서 바로 실행되는것은 아니고, 자신의 차례가 되어야 실행됨
    - OS의 스케줄러가 작성한 스케줄에 의해 실행
      - 스케줄러는 실행 대기중인 스레드들의 우선순위를 고려하여 실행순서와 실행시간을 결정하고, 각 스레드들은 스케줄에 따라 자신의 순서가 되면 지정된 시간동안 작업을수행
    - 당연 대기중인 스레드 없으면 바로 실행
  - Thread를 새로이 만들지않고, start했던것을 다시 start하면 에러남!
  - start vs run
    - run은 그냥 메소드 호출한것
    - start는 새로운 호출스텍을 만드는것! 즉 새로운 스레드가 실행하는데 필요한 호출스택을 생성한다음에 run을 호출
      - 그래서 새로운 스레드는 main이 맨 처음 호출이아니라, run이 맨 처음 호출
      - 스레드 소멸되면 호출스택은 알아서 소멸
  - 실행중이 ***사용자스레드*** 가 없을때 프로그램은 종료가된다
    - 데몬스레드가 아니라, 사용자스레드임! 데몬스레드는 알아서 종료

- 싱글스레드와 멀티스레드
  - 컨텍스트 스위칭 : 프로세스 또는 스레드간 작업전환 하는것을 이야기함
    - 스레드의 컨텍스트 스위칭이 프로세스보다 빠르다!(프로세스는 더 많은 정보를 저장해야하기때문에!)
    - 좀더 상세한 내용은 "multiProcess_multiThread_contextSwitchin" 참고
  - 콘솔에 싱글코어 + 두개의 스레드를 사용해서 데이터를 뿌릴때, 하나의 스레드+싱글코어보다 느릴수 있는데 이러한 원인은 두가지로 볼수 있다.
    - 컨텍스트 스위칭에 대한 비용
    - 콘솔에 출력하기 위해서 다른 스레드의 출력이 끝나기를 기다려야하는데 이때 발생하는 대기시간
    - 멀티코어+두개의스레드 일 경우도 크게 속도가 개선되지않은데, 그 이유는 콘솔이라는 자원을 놓고 두 스레드가 경쟁하게되어서 그렇다
  - 두 스레드가 서로 다른 자원을 사용하는 작업의 경우에는 싱글스레드 프로세스보다 멀티스레드 프로세스가 매우 효율적
    - 외부기기와의 입출력!

- 스레드 우선순위
  - 스레드 우선순위는 OS 스케줄링 정책과 JVM에 따라 달라지므로 작업에 우선순위를 두어 우선순위 높은 작업을 빨리 처리하도록 프로그래밍하는게 좋다.. 즉, 우선순위용작업 Queue를 두어 프로그래밍적으로 처리하라!

- 스레드 그룹
  - 스레드 그룹은 서로 관련된 스레드를 그룹으로 다루기 위함!
  - 기본적으로 main 스레드 그룹이 있고, 새로운 스레드 그룹을 만든다는것은 main스레드 그룹 하위에 있게되는것!
  - 스레드를 생성하게 되면, main 스레드그룹안에서 참조되어 동작하기때문에 GC 대상이 되지않는다!(참조변수가 없더라도!)

- 데몬스레드 
  - 일반스레드(사용자 스레드)를 돕는 보조적인 역할이기때문에 일반스레드 종료되면 바로 종료됨!
  - 데몬스레드가 새로운 스레드 생성하면 데몬스레드로 생성됨(스레드 만드는 놈의 셋팅을 보통 default로 따라가는듯)
  - 프로그램 종료시 gracefulshutdown이 필요하다면 데몬스레드 쓰면안되겟지!
  - 가비지컬렉션 같은게 데몬스레드로 동작함

- 스레드의 실행제어
  - 효율적인 멀티스레드를 만들기위해서는 정교한 스케줄링 작업이 필요!
    - 스케줄링 관련메소드
      - static void sleep
        - sleep은 항상 현재 실행중인 스레드에 대해 작동
        - 전혀다른 스레드의 참조변수를 가지고와서 sleep을 호출해도 현재 실행중인 스레드에 대해서 작동
        - 그러므로 static이고, Thread.sleep으로 호출해야한다!
          - yield가 static인것도 같은 맥락임!
      - void join : 지정한 시간동안 해당 스레드를 현재 스레드로부터 join하게함! 즉, 해당 스레드를 파라미터로 지정한 시간이 지나거나, 종료되면 현재 스레드 실행
        - 특정 스레드의 작업이 어느정도 진행 or 완전히 마무리되고 현재 진행 스레드가 동작해야한다면 join을 사용!
      - void interrupt : sleep이나 join에 의해 일시정지상태인 스레드를 깨워서 실행대기상태로 만듬.. 해당 스레드에서는 InterruptedException이 발생함으로써 일시정지상태를 벗어남
      - static void yield : 실행 중에 자신에게 주어진 실행시간을 다른 스레드에게 양보(yield) 하고 자신은 실행대기상태가됨
        - while문으로 계속 도는 스레드에서 boolean과 같은 변수를 조건으로 작업을 수행할때, 작업을 수행하지않도록 변수가 셋팅되었을때 의미없이 뺑뺑이 돌게될텐데, 그때 yield를 써서 다른 스레드를 활성시켜줄수있음!
        ```java
        while(!stopped){
            if(!suspend){
                ...
                //작업
            }else{
                Thread.yield();
            }
        }
        ```
  - 스레드의 상태
    - NEW : 스레드가 생성되고 아직 start가 호출되지않은상태
    - RUNNABLE : 실행중 또는 실행가능한 상태
    - BLOCKED : 동기화블럭에 의해서 정지된 상태(lock이 풀릴때까지 기다리는 상태)
    - WAITING, TIMED_WAITING : 스레드의 작업이 종료되지는 않았지만 실행가능하지 않은 일시정지상태. TIME_WAITING은 일시정지시간이 지정된 경우를 의미
    - TERMINATED : 스레드 작업이 종료된 상태
  - 스레드의 생성부터 소멸까지..
    1. 스레드 생성+ start호출 => 실행대기열에 저장.. 
       - 실행대기열은 큐와 같은 구조로 먼저 실행대기열에 들어온 스레드가 먼저 실행됨. 즉 자신의 차례가 될떄까지 기다려야함
    2. 실행대기상태에 있다가 자신의 차례가 되면 실행상태가됨
    3. 주어진 실행시간이 다되거나, yield를 만나면 다시 실행대기상태가 되고 다음 차례의 스레드가 먼저 실행됨
    4. 실행중에 suspend, sleep, wait, join, I/O block에 의해 일시정지상태가 될수있음.
    5. 지정된 일시정지시간이 다되거나, notify, interrupt 가 호출되면 일시정지상태를 벗어나 다시 실행대기열에 저장되어 자신의 차례를 기다림
    6. 실행을 모두 마치면 스레드는 소멸
    - 당연히 1~6번의 순서대로 스레드가 수행되지않을수있다!
  
- 스레드의 동기화
  - 공유데이터를 사용하는 코드영역인 임계영역에서 잠금(락)을 가지고 들어가도록 하는것!(잠금 없이 다른 스레드 못들어옴!)
  - 즉, 한 스레드가 작업중일떄 다른스레드 못건들게하는것이 동기화임
  - 클래스 내부에 synchronized 키워드가 있다면, 해당 객체로 접근하는 스레드는 ***객체의 lock***을 얻게된다! 즉, 클래스 내부에 synchronized 키워드를 사용한 메소드가 A,B 있다면, A로 스레드가 접근하였을때 A가 락을 반환하기전까지 A는 당연하고 B메소드도 접근할수없다!
  - wait과 notify
    - Object 클래스에 정의되어있음
    - 동기화 블록(synchonized블록) 내에서만 사용가능
    - 보다 효율적인 동기화가능
    - lock을 획득한 놈이 wait을 호출하면, waiting pool에 들어가서 notify를 기다린다(혹은 notifyAll). 하지만, 락을 획득하려고 기다리는 놈이 많을때, 어떤 놈이 락을 획득할지는 알수없다. 즉, 순서가 보장되지는 않는다
    - waiting pool은 객체마다 존재하는것이므로, notifyAll을 호출한다해도 모든 객체의 waiting pool에 있는 스레드가 깨워지는것이 아님! notifyAll이 호출된 객체의 waiting pool에 대기중인 스레드만 해당됨
    - 한계점
      - notify나 notifyAll은 스레드를 구별해서 통지할수는 없음.. 그냥 waiting pool에 있는거중에 하나일뿐..
      - notify를 실행시 운이 나쁘면 실행되어야할 스레드가 통지받지못하여 오랫동안 기다릴수 있는데, 이것을 ***기아 현상***이라고 한다(notify는 한놈에게만 통지해주는것..)
      - 기아 현상을 해결하기위해 notifyAll을 사용할수있는데, 현재 waiting pool에있는 모든 놈들에게 통지는 해주나, 굳이 통지받을 필요없는놈이 통지받아서 lock을 얻기위해 경쟁할수있는데, 이를 ***경쟁상태***라고 함
      - 즉, 구별해서 통지할수있으면 참좋겟다!
  - Lock과 Condition을 통한 동기화
    - concurrent 패키지 (JDK 1.5 이상)
    - lock클래스 종류
      - ReetrantLock
        - 재진입이 가능한 lock. 가장 일반적인 배타 lock
        - 재진입(reentrant)가 붙은이유는 그냥 락걸고 다시 해제하면 다시 락 걸어서 들어올수있어서 그렇다함..
        - 생성자의 매개변수를 true로 주면 공정하게 처리한다는 이야기인데, 어떤 스레드가 오래 기다렸는지 확인해서 오래기다린 놈부터 들어온다
          - 어떤 스레드가 오래 기다렸는지 확인해야하므로 성능은 떨어짐
          - 굳이 이럴필요없으면 사용하지않도록!
        - 수동으로 해제해야하므로 try~finally를 사용하여 꼭 반드시 해제할수있도록 코딩해야함!
        ```java
            lock.lock();
            try{
                //임계영역
            }finally{
                lock.unlock();
            }
        ```
      - ReentrantReadWriteLock
        - 읽기는 공유가능. 쓰기는 배타 lock
        - 읽기락 걸린상태에서 쓰기락 접근안됨(당연 읽기락은 가능)
        - 쓰기락걸린 상태에서는 어떤 락도 접근안됨
      - StampedLock
        - ReentrantReadWriteLock에 낙관적 lock 기능을 추가
    - ReentrantLock과 Condition
      - 구분해서 통지할수있도록 해주는게 Condition
      - Condition을 만들면 waiting pool을 나누는 기능을한다
      - 이를 통해 기아 현상이나, 경쟁 상태가 개선가능(물론 특정 스레드를 지정할수는 없음)
      - 기존 wait -> await
      - 기존 notify -> signal
      - 기존 notifyAll -> signalAll
      ```java
        ReentrantLock lock=new ReentrantLock();
        Condition con1=lock.newCondition();
        Condition con2=lock.newCondition();
      ```
- volatile
  - 각 코어마다 캐시가 있는데, 그러다 보니 메모리에 저장된 변수의 값이 변경 되었음에도 반영이 안될때가 있다. 이때, 항상 메모리에서 읽어오돌 갛는것이 volatile 키워드!
  - synchronzied 키워드도 같은효과를 낸다
    - synchronized 블럭으로 들어갈때와 나올때, 캐시와 메모리간 동기화가 이루어진다
  - long과 double을 원자화 할수도있음
    - JVM은 4바이트(32) 단위로 처리하기때문에 int와 int보다 작은 타입들은 한번에 읽거나 쓰는것이 가능하다
    - 그러나, 크기가 8byte인 long과 double타입의 변수는 하나의 명령어로 값을 읽거나 쓸수 없기때문에, 변수가 값을 읽는 과정에 다른 스레드가 끼어드 ㄹ여지가 있다. 다른 스레드가 끼어들지 못하게 하려고 변수를 읽고 쓰는 모든 문장을 synchronized를 써도되지만 volatile을 쓰면 가능하다
    - 이를 원자화 라고 이야기하는데, 원자화라는 것은 작업을 더 이상 나눌수 없게 한다는 의미!
    - 하지만, 원자화랑 동기화랑은 다르다! 동기화가 필요한 작업에는 반드시 동기화 관련 처리를 해주어야함!
    - *상수에는 volatile을 붙일수없음! final이 있으면 상수는 변하는값이 아니기때문에 멀티스레드에 안전해서 붙일필요가 당연없다!
- 용어정리
  - 병렬(parallel) vs 병행(concurrent)
    - 병렬(parallel) : 하나의 작업을 여러 스레드가 나눠서 처리하는것
    - 병행(concurrent) : 여러 스레드가 여러 작업을 동시에 진행하는것
- 기타 팁
  - InterruptedException을 발생시킬수 있다는 이야기는 interrupt()에 의해 작업을 취소될수있도록 코드를 작성할수 있다는 말이다!