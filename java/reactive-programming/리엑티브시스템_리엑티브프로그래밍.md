- 리엑티브 시스템 vs 리엑티브 프로그래밍 (<span style="color:yellow">말이 참 어려움.. 나중에 다시볼것..</span>)
    - 리액티브 시스템은 이러한 개별적인 서비스들이 서로를 인지하면서 하나로 합쳐져 외부에 반응하는 구조적 스타일에 기반을 둔다. 이것은 스케일을 키우거나(up) 줄일(down) 수 있고 부하를 분산할 수 있게하며 이러한 단계 중 일부를 미리 수행할 수도 있다.
    - 현대 시스템을 이끄는 것은 응답성(Responsiveness)이다. 클라이언트/고객은 제때에 가치를 얻지 못하면 다른 곳으로 가버린다는 것을 알아야 한다. 근본적으로 가치를 얻지 못하는 것과 필요할 때 가치를 얻지 못하는 것은 다를 게 없다.
    - 동기, 블로킹 통신(좌)는 자원을 비효율적으로 사용하며 병목현상이 발생하기 쉽다. 리액티브 방식(우)는 위험을 줄이고 값 비싼 자원을 보전하며 하드웨어/인프라에 대한 요구가 덜하다.
    - 리액티브 프로그래밍은 일반적으로 이벤트 기반이다. 이것은 리액티브 시스템이 메시지 기반인 것과 대조적이다. 이벤트 기반과 메시지 기반 사이의 구분에 대해서는 다음 부문에 다루고 있다.
    - 리액티브 프로그래밍 라이브러리의 API는 일반적으로 둘 중 하나이다.

    콜백 기반 : 사이드 이펙트(side-effect)를 발생시키는 익명 콜백을 이벤트 발생지에 붙여 이벤트가 데이터 흐름 체인을 지나갈 때 호출함
    선언적(declarative) 방식 : map, filter, fold와 같이 잘 정립된 결합자(combinator)를 사용하는 함수형 결합을 통해 이루어지는 짐
    대부분 라이브러리들은 이 두 가지 스타일을 섞어서 제공한다. 또한 windowing, counts, trigger와 같은 스트림 기반 연산자들을 추가로 제공하기도 한다.

    - JVM에서 리액티브 프로그래밍을 지원하는 유명 라이브러리들로는 Akka Streams, Ratpack, Reactor, RxJava, Vert.x가 있지만 이 라이브러리들이 전부는 아니다. 이 라이브러리들은 리액티브 프로그래밍 표준인 리액티브 스트림 명세를 구현한다. 리액티브 스트림은 JVM에서 사용되는 리액티브 프로그래밍 라이브러리 간의 상호 운용이 가능하도록 하는 표준으로 스스로에 대한 설명에 따르면 이는 “논 블로킹 역압으로 비동기 스트림을 처리하는 표준을 제공하기 위한 계획” 이다.


    - 리엑티브 프로그래밍의 이점
    - 리액티브 프로그래밍의 가장 큰 장점은 멀티코어와 멀티CPU 하드웨어에서 연산 자원 활용을 증가할 수 있다는 것
    - 두 번째 이점은 개발자의 생산성이다. 전통적인 개발 패러다임은 비동기와 논 블로킹 연산 및 입출력을 직선적이고 유지보수 가능하게 다루는 데 어려움이 있다. 리액티브 프로그래밍은 대개 동작 중인 컴포넌트들 사이의 명확한 조정(coordination)에 대한 필요성을 제거하여 이러한 문제를 해결한다.
    - 리액티브 프로그래밍이 빛을 발하는 것은 컴포넌트를 생성하고 작업 흐름을 결합하는 시점이다. 비동기 실행의 모든 이점을 가지기 위해서는 역압이 굉장히 중요하다. 역압은 과도한 사용과 무한한 자원 소비를 피할 수 있다.
        - 데이터 흐름 측면에서 안정적인 상태를 유지하기 위해서 풀(pull) 방식의 역압은 새로운 요청을 업스트림으로 보내고 메시지 수신을 다운스트림으로 진행한다. 그러므로 생산자가 소비자를 압도하지 않는다.

    - 리액티브 프로그래밍은 수명이 짧은 데이터 흐름 체인을 통해 연산하는 데 중점을 둔다. 이것은 주로 이벤트 기반이다. 반면 리액티브 시스템은 (메시징이라고도 하는) 메시지 기반[5]으로 분산 시스템에서 통신과 조정을 통한 복원성과 탄력성에 중점을 둔다.

    - 리액티브 선언문의 용어집에는 개념적인 차이
    - 메시지는 특정 대상으로 보내지는 데이터 항목이다. 이벤트는 컴포넌트가 주어진 상태에 도달했을 때 발생시키는 신호이다. 메시지 기반 시스템에서는 주소 지정이 가능한 수신자가 메시지 도착을 기다리고 메시지에 응답하며 그렇지 않을 경우 휴면한다. 이벤트 기반 시스템 알림에서 리스너는 이벤트 발생지에 소속되어 이벤트가 발생할 때 호출된다. 즉, 이벤트 기반 시스템은 주소 지정이 가능한 이벤트 발생지에 초점을 맞추고 메시지 기반 시스템은 주소 지정이 가능한 수신자에 집중한다.

- 출처 : http://blog.lespinside.com/reactive-programming-versus-reactive-systems/#2
