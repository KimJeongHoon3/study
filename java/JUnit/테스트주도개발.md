테스트주도개발
- 테스트 주도개발 패턴
  - 기본적인 전략
    - 테스트한다는 것은 무엇을 뜻하는가?
    - 테스트를 언제 해야하는가?
    - 테스트할 로직을 어떻게 고를것인가?
    - 테스트할 데이터를 어떻게 고를것인가?
  - 각각의 테스트는 독립적이어야한다. 즉, 문제가 하나면 테스트도 하나만 실패해야하고, 문제가 둘이면 테스트도 두 개만 실패해야한다..
  - 테스트를 격리하기 위한 작업은 결과적으로 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다.
  - 구현해야할 테스트목록을 작성하라!
    - 구현해야할 것들에 대한 테스트를 목록에 적음
      - 구현할 필요가 있는 모든 오퍼레이션의 사용 예들을 적는다
      - 이미 존재하지않는 오퍼레이션에 대해서는 해당 오퍼레이션의 널버전을 리스트에 적는다(이게 뭔소리일까..)
      - 리팩토링 목록을 적는다
  - 테스트 작성은 테스트 대상이 되는 코드를 작성하기 직전에 작성하는것이 좋다!
    - 코드 작성후에는 테스트는 안만드는거로!
  - 테스트를 작성할때 단언을 제일먼저써라!
    - 단언을 먼저 작성하면 작업을 단순하게 만들어준다! 
    - 아래의 사항들을 해결해준다! (p212 참고)
      - 테스트 하고자 하는 기능이 어디에 속하는지.. 기존메소드? 새로운메소드? 새로운 클래스??
      - 메소드 이름 어떻게 만들지?
      - 올바른 결과를 어떤시긍로 검사할지?
      - 이 테스트가 제안하는 또 다른 테스트는?
  - 명백한 데이터를 사용할것!
    - 만약 수식이 필요한 내용이라면 단언부에서 값이 도출되는 수식을 적어주면좋음! 이 수식을 통해서 내가 무얼 만들어야하는지를 알수있으니까!
    - 특별한 경우가 아니라면 상수를 직접쓰지말것! 
  ---
- 빨간 막대 패턴
  - 목록에서 내가 구현할수있겠다 싶은것을 시작으로!
    - 아는것에서 모르는것으로 성장하는 프로그램!
  - 오퍼레이션이 아무 일도 하지않는경우를 먼저 테스트하라!
  - 새 오퍼레이션을 어디에 적용할지에 대한 고민은 현실적인 테스트 하나를 작성함으로써 상당히 많은 문제가 해결된다
    - 하지만 현실적인 테스트를 작성하는 과정은 쉽지않기에, 이 시간을 짧게 줄이기 위해 발견하기 쉬운 입출력을 사용한다(예를들어, 소켓기반 서버를 만든다면 소켓을 소켓에 데이터를 write하고 해당 데이터를 read해온것과 같은지 확인하는것)
  - 외부에서 만든 소프트웨어에 대한 테스트를 작성할때에도 코딩먼저가 아니라, 해당 소프트웨어가 잘 돌아가는지 제공받은 API를 사용해서 간단한것을 TEST해볼것!(p222 참고)
  - 테스트 주제와 벗어난 아이디어가 생각났을때는 나중에할일에 꼭 적어놓을것!
  - 장애가 생겼으면 장애로 인하여 실패하는 테스트, 장애가 수정되었다고 볼수있는 테스트를 작성할것!

---
- 테스팅 패턴
  - 큰 테스트 케이스를 돌리다가 깨졌다면, 큰 테스트를 쪼개어 작은테스트로 만들어 통과시키고 큰 테스트를 다시 돌릴것!
  - 비용이 많이 들거나 복잡한 리로스에 의존하는 객체를 테스트하기위해서는 모의객체(Mock, 상수반환)를 사용하라! (p233 참고)
    - 고전적인 예로는 데이터베이스!
    - 모의 객체는 모든 객체의 가시성에 대해 고민하도록 격려해서, 설계에서 커플링이 감소하도록한다.(모의객체를 통해서 모의객체뿐아니라 모의객체를 호출하는 객체에서 어떤 함수를쓰고 어떤 파라미터를 전달할지를 고려하니까 그런듯?)
    - 모의 객체를 사용하면 프로젝트에 위험요소가 하나 추가되지만, 모의객체용 테스트 집합이 진짜객체에서 사용가능할때 이러한 위험요소를 줄일수있다
  - 팀 프로젝트하고있으면 언제나 깔끔하게 체크인하고 만약 합쳐졋을때 빨간막대를 발견하면 다시 만들어야한다.. 결코 주석으로 잠시나마 빨간막대를 회피하려들지말것!
--- 
- 초록 막대 패턴
  - 실패하는 테스트를 만든 후 첫번째 구현은 상수를 사용하는것이다! 그리고 이 상수를 변수로 바꿔나가라!
    - 가짜구현을 하면 진짜구현을 하기 이전에 이런 접근방법이 맞는지도 확인해주는 역할을 한다! 즉, 테스트도중에 잘못 생각한부분이라 완전 엎을수도 있는데, 이를 진짜구현부터하면 이를 엎을때 그만큼 시간을 버리는것!
  - 어떤 계산을 어떻게 해야 올바르게 추상화할것인지에 대해 감잡기 어려울때 삼각측량을 통해서 추상화를 해나가면 좋다!
  - 단순한 연산들에대해 너무 쪼갠다고 가짜구현부터 하지말고 명백하다면 바로 고

---
- xunit 패턴
  - 테스트 메서드는 의미가 그대로 드러나는 코드로 읽기쉬워야한다.. 테스트코드가 길어지면 쪼개라!

---
- 디자인 패턴
  - 커맨드
    - 특정 명령을 수행하기위한 객체를 만드는것!
    - Runnable 인터페이스
  - 값 객체
    - 널리 공유해야하나, 동일성(객체가 완전 똑같아야하는것)이 중요하지않을때, 객체에 연산을 수행해야한다면 새로운 객체를 반환해주는것
    - equals를 정의해야함
    - 이를 통해서 별칭문제를 해결가능자
      - 별칭문제 : 객체 내부의 값이 객체 자신도 모르는 사이에 바껴버려서 예상치 못한 결과가 나타나는것..
        - 이에 대한 해결을 위해서 옵저버 패턴을 쓸수는 있으나, 이에 대한 등록 제거 등등에 대한것을 고려할때 로직이 복잡해 질수있음
  - 템플릿 메서드
    - 작업 순서는 동일하나 각 작업 단위에 대한 미래의 개선 가능성을 열어두고싶을때 사용(즉, 구현부가 변화될수있다~)
    - 초기 설계에 의해서 얻어지는 것보다는 경험에 의해서 발견되는 것이 좋다.. 순서에 관한 내용과 상세한 구현에 대한 내용이라는것이 나눠줘야함.. 이에 대한 중복을 상위클래스로 보내면서 추상화시킴.. 
  - 컴포지트 패턴
    - 유사한 객체간(엄밀히는 다른역할을 하지만) 중복을 막기위해 묶을 필요가 있는경우!
    - 보통 하나의 인터페이스(or 추상클래스)를 구현한 두개의 객체가 나옴
    - 역할이 엄밀하게는 다르기때문에 프로그래머의 트릭이지 세상 사람들에게 일반적으로 받아들여지는 개념은 아니라고함
    - 트리모양의 모습이 나타날때, 모든 노드를 합쳐야할때에 상당히 유용하게 쓰임
---
- 용어정리
  - 삼각측량 : 예제 두개를 가지고 일반화(추상화)하는것..?