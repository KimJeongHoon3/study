effective_java_메서드

- 아이템49_매개변수가 유효한지 검사하라
  - 매개변수의 값이 특정 조건을 만족하도록 **제약**이 필요하다면, 문서화하고 메서드 몸체가 본격적으로 특정 작업을 수행하기전에 검사를 해야한다!
    - 메서드 몸체 실행전 매개변수검사를 제대로 수행하지못하면 생길수있는 side effect?
      - 메서드가 수행되는 중간에 모호한 예외를 던질수있음
      - 메서드가 잘 수행되지만 잘못된 결과 반환
      - 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알수 없는 시점에 이 메서드와는 관련 없는 오류를 뱉음 (최악)
  - public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화하자 (@throws 자바독 태그를 사용)
    - 보통은 IllegalArgumentException, IndexOutOfBoundsException, NullPointerException 중 하나가 될것
    - 클래스 레벨에서 공통으로 사용되는 예외는 클래스 레벨에 정의해놓자
  - 자바7의 java.util.Objects.requireNonNull 메서드를 활용하여 null 검사를 하자~
  - 공개되지 않은 메서드라면, assert(단언문)를 사용해서 매개변수 유효성을 검증하자
    - 사용방법
      ```java
        static void methodWithAssert(int i) {
        // if(1==1) throw new AssertionError("test"); // 이렇게쓰면 바로 예외던짐. 즉, AssertionError를 명시적으로 선언하면 정상적으로 예외던진다..

            assert i > 0; // assert뒤에가 false이면 AssertionError를 던지는데, VM option으로 -ea를 붙여주어야만 AssertionError를 던진다.

            System.out.println("메서드 수행");
        }

        public static void main(String[] args) {
            methodWithAssert(-3);
        }
      ```
    - 굳이 jvm 옵션을 넣어주어야 assert 에서 예외를 던지는데 왜쓰나?
      - 챗GPT 답변
        - ![](2023-06-02-15-43-27.png)
        - 개발자의 의도를 명확히 전달하고 코드의 안정성을 높이는 데 도움을 줌으로써 개발자가 개발하는 과정에서 실수를 줄일수 있다. 하지만 assert문으로 일반적인 예외처리나 유효성 검사를 대체할수 있는것은 아니다!! 즉, 개발시에 개발의 버그를 빨리 발견할 수 있도록 도와주는 정도라고 생각하면될듯?
  - 생성자 매개변수의 유효성 검사도 꼭 잘 실행하자!
    - 클래스 불변식을 어기는 객체가 만들어지지않게 하는데 꼭 필요하다! 
  - 매개변수 유효성 검사해야 한다는 규칙의 **예외**
    - 유효성 검사 비용이 지나치게 높거나 실용적이지 않을때
    - 계산 과정에서 암묵적으로 검사가 수행될 때
      - ex. Collections.sort(List) 에서 매개변수 List의 대상들이 비교가능한놈들인지 유효성 검사를 하지않는데, 이는 실제 객체간 비교하는 계산과정에서 타입이 맞지않으면 예외를 던지기때문
  - 결론
    - 메서드가 건네받은 값으로 메서드가 수행하고자하는 바를 행할수 있도록 하는 (최소한의)제약을 사용하자. 메서드는 최대한 범용적으로 설계되어야한다!
  - 기타 팁
    - @Nullable 애너테이션은 표준은 아님

---

- 아이템50_적시에 방어적 복사본을 만들라
  - 프로그래밍은 항상 클라이언트가 내가 만든 클래스의 불변식을 깨뜨리려 혈안이 되어있다고 가정하고 방어적으로 만들어야한다
    - 의도적으로 보안을 뚫으려나 시도도 있지만, 평범한 프로그래머의 실수로 클래스 오작동을 할 수 있기때문
    - 그래서 적절하지않은 클라이언트로부터 클래스를 보호하는데 시간을 투자하는게 좋다
  - 어떻게 방어적으로 만드나?
    - 클래스의 구성을 불변으로! (이렇게 만들면 방어적 복사를 할 일이 거의 없어진다~)
      - ex. Period 클래스 내부에 startDate와 endDate를 `Instant`를 사용해서만든다(혹은 `ZonedDateTime`이나 `LocalDateTime`도 괜춘)
    - 어쩔수 없이 가변으로 구성되어있는 클래스는?
      - 방어적 복사(defensive copy)를 수행하자!
        - 생성자에서 받은 가변 매개변수 각각을 복사
          - 참고로 방어적 복사본을 만들기전에 유효성 검사를 수행하는것이아닌, **방어적 복사본을 만든 이후 유효성 검사를 수행하여야한다!**
            - 복사본을 만드는 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기때문
          - 또한, 매개변수가 제3자에 의해 확장될 수 있는 타입이라면(ex. final 선언안되어있는 클래스) 방어적 복사본을 만들때 clone사용하지마라
          - ex. 
            ```java
                public Period(Date start, Date end) {
                    this.start = new Date(start.getTime()); // Date의 clone을 사용하지않았다. 이는 Date가 final이 아니기에 클라이언트가 악의적으로 하위클래스에 clone을 오버라이딩하여 기존 Date를 참조하도록 만든걸 넘길수 있기때문..
                    this.end = new Date(end.getTime());

                    if(this.start.compareTo(this.end) > 0) // 방어적 복사본을 먼저만들고 유효성 검사
                        throw new IllegalArgumentException("start가 end보다 늦음");
                }
            ```
        - 클래스에서 가변 필드를 반환해야할때에도 방어적 복사본을 만들어주자
          - 생성자에서 가변 매개변수를 방어적으로 복사했다면, 가변필드 반환해줄때 clone을 사용해도 괜춘
            - but!! 인스턴스를 복사하는데는 일반적으로 생성자나 정적팩터리를 써라! 훨씬 이점이 많다!(아이템13 참고)
          - ex.
            ```java
                public Date start() {
                    return new Date(start.getTime());
                }

                public Date end() {
                    return end.clone(); // 생성자에서 new Date로 생성을 하기때문에, clone을 사용해도 안전!
                }
            ```
      - 단순 불변 객체를 만들기 위해서뿐 아니라, 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야할때면 내부 자료구조의 불변식 유지를 위해서 전달받은 객체를 복사해야할 수 있다
        - ex. 건네받은 객체를 Map의 key로 저장하거나 Set에 저장했을때, 외부에서 해당 객체를 변경하게되면 Map의 key나 Set의 불변식이 중복된 값으로 인해 깨어질 수 있다
        - 내부 객체를 클라이언트에 건네주기 전에 방어적 복사본 만드는것도 마찬가지이유..
          - ex. 배열을 넘겨줘야한다면 clone을 호출하여 방어적 복사를 수행하던지, 불변 뷰(`Collections.unmodifiableList(Arrays.asList(배열))`)를 반환
      - 그럼 방어적 복사는 단점이 없나?
        - 방어적 복사는 성능저하가 따른다
          - 그렇기때문에 복사비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없다고 신뢰한다면 **문서화를 통해서** 방어적 복사를 안되어있으니 어떻게 사용해야하는지, 그리고 해당 요소를 클라이언트가 수정했을시 책임이 클라이언트에 있음을 반드시 남겨놓아야한다!
          - 방어적 복사 생략해도 되는 상황?
            - 같은 패키지에 속하는 등의 이유로 호출자가 컴포넌트 내부를 수정하지 않으리라 확신할때
            - 메서드나 생성자의 매개변수로 넘기는 행위가 그 객체의 통제권을 명백히 이전함을 뜻할때
              - 하지만, 통제권을 넘긴것을 결국 취약점이 발생할수 있는 구간이기때문에, 클래스와 클라이언트가 상호 신뢰할수잇을때
              - 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될때만 사용하자
                - ex. 래퍼 클래스 특성상 클라이언트는 래퍼에 넘긴 객체에 여전히 직접 접근할 수 있게되어, 래퍼의 불변식을 파괴할 수 있긴하지만 그 영향을 오직 클라이언트 자신만 받게 된다. (BufferedInputStream 같은 경우 데코레이터 패턴을 사용한 래퍼 클래스의 대표적인 예시인데, 말 그대로 InputStream에 성능을 위해 만들어진 래퍼 클래스이기때문에 InputStream에 직접접근하여 BufferedInputStream의 불변식을 파괴한다할지라도 영향가는건 클라이언트 자신뿐.. )
            - => 물론 이 생략의 전제는 문서화를 해야한다는 것!!!
  - 기타 팁
    - Date는 낡은 API 이다.. 가변이기도하고 날짜 표현하는데 Zone 지정도 없는것 등 부족한부분이 많음.. 날짜관련 개발을 진행한다면 Date 사용하지말자