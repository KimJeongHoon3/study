effective_java_직렬화

- 아이템85_자바 직렬화의 대안을 찾으라
  - 직렬화는 프로그래머가 어렵지 않게 분산 객체를 만들수 있다는 구호로 인기가 있었으나, 아래와 같은 문제도 수반되었다
    - 보이지 않는 생성자
    - API와 구현사이의 모호해진 경계
    - 잠재적인 정확성 문제
    - 성능
    - 보안
    - 유지보수성
  - ObjectInputStream.readObject
    - readObject 메서드는 Serializable을 구현한 클래스라면 클래스패스 안에 있는 모든 타입의 객체를 만들어 낼 수 있다
    - 역직렬화 과정에서 타입들 안의 모든 코드를 수행할수 있기에, 코드 전체가 공격 범위에 들어 갈 수 있게된다
    - 바이트 스트림을 역직렬화할때는 매우 주의가필요!!
  - 역직렬화 관련 대표 문제
    - 역직렬화 폭탄(deserialization bomb) 받게되면, 이를 처리하느라 다른 요청 처리못함 (서비스 거부 공격)
  - 어떻게 직렬화 위험 피할 수 있나?
    - 역직렬화를 하지 않는것..
    - 자바 직렬화를 쓰는것 대신, 객체와 바이트 시퀀스를 변환해주는 다른 메커니즘이 많이있다! (크로스-플랫폼 구조화된 데이터 표현(cross-platform structured-data representation))
      - 자바 직렬화보다 훨씬 간단
      - 속성-값 쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체를 사용
      - ex. JSON, 프로토콜 버퍼(구글)
        - 효율엔 프로토콜 버퍼가 더 좋다함! 써야할일 있으면 나중에 꼭 찾아보자~
  - 레거시 때문에 자바 직렬화 완전배제 어려우면 어떻게?
    - 신뢰할 수 없는 데이터트 절대 역직렬화하지 말자
      - 객체 역직렬화 필터링(java.io.ObjectIinputFilter - 자바9부터)
  - 결론
    - 어떻게든 자바 직렬화 사용보단, JSON이나 프로토콜 버퍼와 같은 크로스-플랫폼 구조화된 데이터 표현으로 마이그레이션하자..


---

- 아이템86_Serializable을 구현할지는 신중히 결정하라
  - Serializable을 구현하면, 릴리즈한 뒤에는 수정하기 어려움
    - 직렬화된 바이트 스트림 인코딩(직렬화 형태)도 하나의 공개 API가 된다..
    - 커스텀 직렬화를 사용하지않고, 그냥 자바의 기본 방식을 사용하면, 그걸 도입해서 배포한 순간의 클래스의 내부구현방식에 묶여버린다.. 영원히..
    - private, package-private 예외없음..
    - 배포이후 내부 클래스 개선하고자할때, 아무생각없이 내부 편의 메서드 하나를 추가하게되면 직렬화(혹은 역직렬화)시 기존과 달라지게되어 예외가 떨어진다
      - ex. serialVersionUID를 직접 명시하지않으면, 시스템이 런타임에 암호 해시함수를 적용해 자동으로 클래스 안에 생성해넣는데, 이게 메서드 추가에 따라 달라지게됨
        - 달라지면 직렬화과정에서 예외
  - 버그와 보안 구멍이 생길 위험이 높아진다
    - 역직렬화시 객체생성을 수행하게되면, 생성자를 통해서 생성을 하게될텐데, 이게 생성자를 호출하는 로직이 눈에 보이지않기때문에 생성자에서 지켜야할 불변식같은 부분을 놓칠 수 있다
  - 신버전 릴리즈시에 테스트할 것이 늘어난다
    - 직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화 한 뒤에 구버전으로 역직렬화할 수 있는지, 그리고 그 반대도 가능한지 검사해야한다. 그에 따라 테스트 갯수는 증가
  - 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안되며, 인터페이스도 대부분 Serializable을 확장해서는 안된다
    - 이를 사용하는 클라이언트가 직렬화를 신경써야하므로.. 매우부담
    - 물론, Serializable을 구현한 클래스만 지원하는 프레임워크면 어쩔수없음
  - 내부 클래스는 직렬화를 구현하지 말아야한다
    - 내부 클래스에는 바깥 인스턴스의 참조와 유효범위 안의 지역변수 값들을 저장하기 위해 컴파일러가 생성한 필드들이 자동으로 추가되어있는데, 이 필드들이 명세에도 어떻게 정의되어있는지 나와있지않다. 즉, 직렬화형태가 불분명.. 그래서 사용하면안됨!!
    - 정적 멤버 클래스는 Serializable을 구현해도 됨
  - 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하다면 주의할 점
    - 불변식 보장이 필요한 필드가 있다면, finalize 메서드를 final로 선언하여 하위클래스에서 상속못하도록 해야한다 (finalizer 공격 막기위함)
    - 인스턴스 필드 중 기본값(정수형 0, boolean은 false, 객체 참조타입은 null)으로 초기화되면 위배되는 불변식이 있다면 클래스에 readObjectNoData 메서드를 추가해야한다
      - <span style="color:red">readObjectNoData 메서드를 넣으면, 초기화시에 기본값으로 초기화되면 알아서 호출되는건가..?</span>
      ```java
        private void readObjectNoData() throws InvalidObjectException {
            throw new InvalidObjectException("스트림 데이터가 필요합니다");
        }
      ```
    - 상속용 클래스인데, 직렬화 지원안하면..
      - 상위 클래스에 매개변수가 없는 생성자를 제공하지않는다면, 직렬화 프록시 패턴을 사용
- 기타 팁
  - 역사적으로 BigInteger와 Instant 같은 '값' 클래스와 컬렉션 클래스들은 Serializable을 구현하고, 스레드 풀처럼 '동작'하는 객체를 표현하는 클래스들은 대부분 Serializable을 구현하지 않았다
