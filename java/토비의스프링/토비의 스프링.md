# 토비의 스프링 vol1
(이에 대한 스터디는 최대한 어떻게 객체지향을 풀어나가는지에 집중할것!)
- 스프링이란?
  - 어플리케이션 개발을 빠르고 효율적으로 할수있도록 도와주는 애플리케이션 프레임워크
  - 이를 위해 애플리케이션의 기본틀, 공통 프로그래밍 모델, 기술 API를 제공
    - 애플리케이션의 기본틀(스프링 컨테이너) 
      - 애플리케이션 컨텍스트라고도 부르는 런타임 엔진을 제공
      - 설정 정보를 참고해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리
      - 독립적으로도 동작할수있지만, 보통 웹 모듈에서 동작하는 서비스나 서블릿으로 등록해서 사용(서블릿에 해당 컨테이너를 등록한다는 말인듯..?)
    - 공통 프로그래밍 모델(IoC/DI, 서비스 추상화, AOP)]
      - IoC/DI
        - 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델
        - 컨테이너에 등록해야지만 스프링이 제공해주는 가치를 누릴수있음!!!
      - 서비스 추상화
        - 구체적인 기술과 환경에 종속되지않도록 유연한 추상계층으로 개발
      - AOP
        - 부가적인 기능을 독립적으로 모듈화함
    - 기술 API
      - 다양한 영역에 바로 활용할수있는 방대한 양의 기술 API를 제공
      - 스프링에서 제공하는 API와 지원기술은 스프링의 프로그래밍 모델에 따라 작성되어있기때문에 스프링모델을 코드에 잘 녹여낼수있음!
  - => 스프링을 사용한다는것은 위를 활용하여 애플리케이션을 개발한다는것이다!
  - 스프링의 장점
    - 단순함 : 복잡한 기술 프레임워크가 아닌, 객체지향적 개발모델인 POJO 프로그래밍!
    - 유연성(+확장성) : 상당히 많은 서드파티를 지원해주고, 프레임워크에 프레임워크를 더하는 확장성이 매우 뛰어남!
    - 객체지향설계를 지향함으로써, 오브젝트를 어떻게 효과적으로 설계하고, 구현하고, 사용하고, 이를 어떻게 개선해나갈지에 대한 기준을 마련해준다!! 이를 잘 할수있도록 프레임워크 또한 제공해준다!! 그렇게 만들어져잇는 프레임워크가 그렇게 개발할수있도록 도와주기도한다!! 

- 1장 오브젝트와 의존관계
  - 관심사의 분리
    - 객체를 설계할때 가장 염두해두어야할 사항은 미래의 변화를 어떻게 대비할것인가 이다.
    - 객체 지향설계는 변화에 효과적으로 대응할수있도록 해준다
      - 실 실계를 최대한 가깝게 모델링을하기때문에, 실 세계의 반영한 가상의 추상세계를 구성하여, 편리하게 변경, 발전, 확장 시킬수있다.(실 세계에서 변화되면 가상에서도 변화되도록)
    - 변화의 폭을 줄이는 방법은 분리와 확장을 고려한 설계이다
      - 관심사의 분리 : 관심이 같은것 끼리는 하나의 객체안으로 또는 친한 객체로 모이게하고, 관심이 다른것은 가능한 한 따로 떨어져서 서로 영향을 주지않도록 분리하는것!
    - 리팩토링 : 외부의 동작방식에는 변화없이, 내부구조를 변경해서 재구성하는 작업또는 기술.. 이를통해서 유지보수용이, 유연한 제품 개발, 코드의 품질높여줌 => 생산성향상
      - 메소드 추출 : 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는것
      - 
  - 용어정리
    - 자바빈 : 디폴트생성자 + getter / setter
      - 디폴트 생성자는 프레임워크에서 해당 객체를 생성할때(리플렉션) 파라미터가 없는 생성자가 필요하기때문


  - 관계 설정 책임의 분리 : 한 클래스 내에 해당 클래스 본연의 관심사 외에 다른 관심사가 함께 있다면 관계적으로 제대로 분리되지않은것! 여기서 다른 관심사라는것은 자신의 역할외에 다른 역할을 수행하는 클래스를 직접 책임지고 만드는것(new) 등을 이야기함.. 그렇기 때문에 이를 분리하기위해서는 인터페이스를 사용하여, 해당 인터페이스가 제공하는 함수만 사용하면되는것이지, 이 인터페이스가 어떤 구체적인 오브젝트로 만들어져있는지 신경쓰지않도록 하는것! 
    - ex) 토비의 스프링 예제상 UserDao의 역할은 데이터베이스에 접근하여 데이터를 핸들링하는 역할인데, ConnectionMaker(데이터베이스의 연결을 정의한 인터페이스)가 어떻게 구체적으로 만들어지는것인지는 신경쓰지않고 제공된 인터페이스를 사용하는것이 관계 설정 책임을 분리하는 핵심이다(인터페이스가 실제 오브젝트와 오브젝트사이의 관계를 엮어주는 역할!)
   
  - 원칙과 패턴
    - 개방폐쇄원칙 : 클래스나 모듈은 확장에는 열려있고, 변경에는 닫혀있어야한다
      - UserDao에서는 DB 연결방법이라는 기능을 확장하는데에는 열려있으나, UserDao의 핵심기능을 구현한 코드(데이터 select, add, update 등)는 변화에 영향을 받지않는것!
   
      * 객체지향설계원칙(SOLID) : 객체지향의 특징을 잘 살릴수있는설계의 특징을 이야기함.. 디자인패턴은 이 원칙을 지켜서 만들어진것. 즉, 객체지향설계원칙이 크고 일반적인 개념
         - SRP(The Single Responsibilty Principle) : 단일책임의 원칙
           - 단일 책임이니, 다른 역할의 기능들이 혼재되어있지 않음으로, 특정 기능을 고쳐야할때 다른 역할의 기능들을 줄줄이 고칠필요없음
         - OCP(The Open Closed Principle) : 개방폐쇄원칙 
         - LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙 
           - "부모 클래스 타입인 A를 사용하는 기존의 프로그램 코드가 자식 클래스 B로 대입 시켰을 때도 문제 없이 작동하도록 하기 위해서, 자식 클래스는 부모 클래스가 따르던 계약 사항을 자식도 따라야한다" 는 원칙
           - https://pizzasheepsdev.tistory.com/9#:~:text=%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84%20%EC%B9%98%ED%99%98%20%EC%9B%90%EC%B9%99%20(LSP%3A%20Liskov%20Substitution%20Principle)&text=%EC%9D%B4%EC%A0%84%EA%B3%BC%20%EB%A7%88%EC%B0%AC%EA%B0%80%EC%A7%80%EB%A1%9C%20%EC%9D%B4%20%EC%9B%90%EC%B9%99,%EC%97%90%20%EB%AC%B8%EC%A0%9C%EA%B0%80%20%EC%97%86%EC%96%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4'.
         - ISP(The Interface Segregation Principle) : 인터페이스분리원칙
           - 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는것!
           - 이를 통해서, 클라이언트와 오브젝트간에 관계를 명확하게 할수있다!
         - DIP(The Dependency Inversion Principle) : 의존관계 역전 원칙 
           - 구상클래스에 의존하는것이 아닌(new 범벅..), 추상화된것에 의존하도록 만들기! (팩토리 메서드 패턴도 이 원칙에 맞을것이고, 스프링 컨테이너를 통해 구상클래스를 주입받는것도 이 원칙에 맞음..)
           - new를 통해 직접 생성하고 그것에 의존하는것이 아닌, 추상화(인터페이스)에 의존하게되면, 인터페이스를 구체화한 대상을 전달받아야하고, 보통 이를 펙토리에서 전달받게되는 즉, 외부로부터 전달받게되므로 의존관계는 뒤집히게됨..
         
      * 디자인 패턴 : 특별한 상황에서 발생하는 문제에 대한 구체적인 솔루션
   - 높은 응집도와 낮은 결합도
      - 응집도 : 응집도가 높다는것은 하나의 책임과 관심사에 집중되어있다는것! 이를 잘 지킨다면, 고쳐야할 부분이 생겼을때 딱 그 부분만 고치면 된다. 즉, 다른곳에 연쇄적으로 수정이 일어날 곳이 준다. 테스트할때도 변경된 부분만 테스트가 가능하다. 기능과 기능간에 분리되어있으므로(단일 책임) 다른 기능들과 굳이 연결해서 테스트할 필요가없으니 이에 대한 부담도 줄음
      - 결합도 : 낮은 결합도라는것은 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공(인터페이스활용)하여, 서로 독립적이고 구체적인것을 알 필요가 없도록 만들어주는것이다. 이를 통해 오브젝트의 변경에 다른 오브젝트가 미치는 영향은 매우 줄게된다. 즉, 결합도라는것은 하나의 오브젝트가 변경이 일어날때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도라고 할수있다.

   - 전략패턴
      - 기능 맥락(context)에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 사용하여 외부로 분리시키고, 해당 인터페이스를 구현한 구체적인 클래스를 필요에 따라 변경해서 사용할수 있게끔하는 디자인 패턴.
      - 클라이언트가 사용할 전략을 선택하여 컨택스트가 진행
      - 특정 기능에 변경이 많다면 인터페이스를 사용하여 요구사항에 맞는 기능을 구현하여 그에 맞는 전략을 가져가는것이다 

  - 제어의 역전(IoC)
    - 오브젝트 팩토리 
      - 팩토리 : "객체 생성방법 결정 + 만들어진 객체를 반환" 하는 역할
         - 오브젝트를 사용하는쪽과, 오브젝트를 생성하는쪽의 ***역할과 책임을 깔끔하게 분리하려는 목적***으로 사용!
         - 팩토리 메소드 패턴이나 추상팩토리 패턴과는 다름!
      - 설계도로서의 팩토리
         - 설계도 : 컴포넌트의 구조와 관계를 정의. 즉, 오브젝트들간에 관계를 정의!
            - 클라이언트가 UserDao를 사용하겠다고 요청하면, ConnectionMaker의 구체적인 오브젝트를 연결하여 UserDao를 넘겨준다.
               - ConnectionMaker의 구체적인 오브젝트가 추가되거나 변경되어도 UserDao는 영향받지않는다!
            - 이를 활용하면 UserDao뿐아니라, AccountDao, MessageDao 등과 같이 확장하여 사용가능하다.
     - 제어권 이전을 통한 제어관계의 역전
        - 제어의 역전은 "수동적"이 되었다는것!
        - 능동적으로 모든 것을 직접 만들어서 컨트롤하는것이 아닌, 실제적인 구현은 다른 곳에서 만들고 만들어진 것을 수동적으로 사용하겠다!
        - 템플릿 메소드 패턴에서도 제어의 역전을 볼수있는데, 템플릿 메소드를 통해서 해당 메소드는 상위클래스에서 사용되어지지만, 실제적인 구현은 하위클래스에서 이루어진다. 하위클래스에서 제어권을 가지는것이 아닌, 하위클래스에서는 정의만 할뿐, 실제적인 제어권은 상위클래스에서 가지고있기때문에 상위클래스에서 호출되었을때(수동적) 제어가 역전된것!
        - 라이브러리랑 프레임워크의 차이점에서도 제어권이전에 대한 개념을 알 수 있음
           - 라이브러리 : 코드상에서 능동적으로 필요할때 사용! 제어의역전x
           - 프레임워크 : 코드상에서 수동적으로 움직임(내가 만든 코드가 프레임워크에 의해 호출됨) 제어의역전o
        - 프레임워크나 컨테이너의 역할은 컴포넌트간의 관계를 정의, 사용, 생명주기를 관리하는것이다. 그로인해, 각각의 오브젝트들이 서로를 제어하거나 관리하지않게된다!


  - 스프링의 IoC
    - 오브젝트 팩토리를 이용한 스프링 IoC
      - 스프링 빈 : 스프링 컨테이너가 생성, 관계설정, 사용 등을 제어해주는 ***제어의 역전이 적용***된 오브젝트 (메소드에 @bean을 통해서 등록할때 메소드이름이 빈 이름이다)
      - 어플리케이션 컨텍스트 : 설정 정보를 가져와서 이를 기반으로 빈 생성, 관계 설정등의 제어를 해줌
        - BeanFactory를 구현했기때문에 빈 팩토리로 라고 부를수도있고 또는 IoC 컨테이너, 스프링컨테이너 라고 부르기도한다.
      - 어플리케이션 컨텍스트 동작방식
        1. @Configuration 이 있는 클래스(설정정보)로 ApplicationContext에 bean을 등록    
        2. client가 원하는 bean을 요청
        3. ApplicationContext에 등록된 bean목록에서 클라이언트가 요청한 bean을 찾아서 반환
      - 어플리케이션 컨텍스트 장점
        - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
          - 필요한 오브젝트를 가져오려면 어떤 팩토리 클래스를 사용해야할지를 알아야하고, 팩토리 오브젝트를 생성했어야하는데, applicationContext를 사용함으로써 팩토리가 아무리 많아져도 이를 알아야하거나 직접 사용할 필요가 없다.
        - 애플리케이션 컨텍스트는 종합 IoC서비스를 제공
          - 오브젝트간의 관계설정, 오브젝트가 만들어지는 방식, 자동생성, 오브젝트에 대한 후처리, 정보의조합, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공 
        - 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공.
    - 스프링 IoC 용어정리
      - 빈 : 스프링이 직접 그 생성과 제어를 담당하는 오브젝트를 빈
      - 빈 팩토리 : 스프링의 IoC를 담당하는 핵심 컨테이너. 빈을 등록, 생성, 조회하고 돌려주는것, 빈 관리 등
      - 어플리케이션 컨텍스트 : 빈 펙토리를 확장한 IoC 컨테이너. 빈 펙토리 이상의 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것
      - 설정정보/설정 메타정보 : IoC 적용을 위해 사용하는 메타정보
      - 컨테이너 또는 IoC 컨테이너 
      - 스프링 프레임워크

  - 싱글톤 레지스트리와 오브젝트 스코프 
    - 오브젝트의 동일성 & 동등성
      - 동일성 : 오브젝트가 진짜 완전 똑같아야함. 참조변수만 여러개 있는것일뿐, 같은 오브젝트를 바라보는 상태 
      - 동등성 : equals 메소드를 가지고 비교함. 즉, equals에 특정 조건만 만족하면 오브젝트가 다르다 할지라도 같다고 봐주는것. default값(equals 오버라이딩 안되어있으면)은 동일성 비교와 같음
    - 싱글톤 레지스트리로서의 애플리케이션 컨텍스트 
      - 애플리케이션 컨텍스트는 기본적으로 싱글톤을 저장하고 관리하는 싱글톤 레지스트리 이다. 싱글톤 레지스트리를 통해서 싱글톤으로 만들어준다!
      - spring은 서버에서 사용될 목적으로 만들어졌기에, 서버에서 요청마다 새로운 오브젝트를 만드는것은 너무 많은 부하를 주기때문에, 한번만 생성해서 공유하는 싱글톤이 디폴트이다!
      - 싱글톤을 우리가 직접 구현하게되면, 생성자를 private으로 놓기때문에 상속이나 다형성 활용이 불가하다. 테스트 코드시 mock으로 빼기도 어렵게된다. 그로 인해 스프링은 싱글톤 레지스트리를 통해서 일반 클래스를 빈으로 등록하면, 싱글톤으로 만들어지게되고, 이것이 상속이나 다형성, 테스트코드시 mock을 사용할수있게해준다
      - 그러나 싱글톤으로 만들게 되었을때 여러 스레드가 동시에 접근하게되면 이에 따른 동기처리를 해주어야하고, 무상태 방식으로 만들어주어야한다. 이에따라 요청에 대한 정보를 전달해줄때 파라미터나 리턴값을 잘 활용해야한다
    - 스코프는 싱글톤, 프로토타입, HTTP 요청이 생길때마다 생성하는 요청스코프, 웹의 세션과 스코프가 유사한 세션스코프도 있음

  - 의존관계 주입(DI)
    - 오브젝트가 인터페이스를 의존하는 것이 변화에 영향을 덜 받고 결합도를 낮춰준다. 그리고 이에 따라 실제 인터페이스를 구현한 오브젝트를 연결시켜주어야 하는데(런타임시에), 이 구체적인 오브젝트를 연결해 주는것을 DI(의존관계 주입) 이라하며, 이 역할을 스프링 컨테이너가 수행한다!
    - 의존관계 주입이란 아래 3가지를 충족
      - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야한다.(코드상에서는 구체적인 오브젝트의 의존관계가 드러나면안된다는뜻..)
      - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정
      - 의존관계를 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.(팩토리 클래스, 스프링에서는 스프링 컨테이너(빈 팩토리))

  - 정리
    - 스프링이란 어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크. 스프링의 주된관심은 오브젝트와 그 관계!
    - 객체 지향적으로 개발을 해나가는데 좋은 tool을 제공해주는게 스프링!
    - 특힌, 객체간의 관계를 설정하는데 도움을 줌으로써 높은 응집도와 낮은결합도가 가능하도록 도와준다!
     
   

- 2장 테스트
  - 테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것
  - 단위 테스트는 항상 일관성 있는 결과가 보장돼야한다. DB에 남아있는 데이터와 같은 외부환경에 영향을 받지 말아야하는것은 물론, 테스트를 실행하는 순서를바꿔도 동일한 결과가 보장되도록 만들어야한다.
  - 테스트는 항상 포괄적으로, 꼼꼼하게 진행되어야한다! 어정쩡하게 몇개만 테스트하고 넘어가면안됨!! 충분한 검증을하자!!!
  - 작은 단위로 테스트하는게 유리!
  - ***예외조건에 대한 테스트를 잊지말것!***
    - 예외테스트를 통해서 어떤 예외처리를 어디서, 어떻게 진행할것인지를 파악 할수있음!
  - @Test 실행될때마다 새로운 오브젝트가 생성된다!! 한번 만들어진 테스트 클래스의 오베즉트는 하나의 테스트 메소드를 사용하고 나면 버려진다!
  - 테스트도 리팩토링한다! 중복되는코드는 함수로 빼던지, @Before이나 @After를 사용하여 공통 준비작업과 정리를 처리할수있도록하자
  - 스프링 테스트는 어떻게?
    - 스프링을 활용하기위해서는 applicationContext를 생성해주어야하는데, 이를 사용하기위해서 지속적으로 테스트마다 만드는것은 부담! 이를 해결하기 위해 아래 두가지 사용
      1. @BeforeClass 를 통해서 테스트간 static으로 가지고있음
      2. @RunWith(SpringJUnit4ClassRunner.class) : 스프링에서 제공해주는 확장클래스(for junit) 이를 사용하면 applicationContext를 주입받을수있는데, 이는 테스트용으로 쓸수 있도록 해주는데, @ContextConfiguration(locations="application.properties 경로")를 통해서 가져오는 설정파일이 동일하다면 @Test시 딱 한번만 applicationContext를 생성!(테스트 클래스에서 모두 공유)
        - 이를 주입받을수 있다는것은, applicationContext를 통해서 bean들을 주입받을수 있다는것!
    - 스프링 컨테이너없이 테스트 할 수 있는 방법을 우선적으로 고려할것! 그래야 신속하고 빠르게 진행가능!
    - 복잡한 의존관계가 엮여져 있는 오브젝트는 스프링 DI 컨테이너를 잘 활용할것!
    - 테스트 전용 설정 파일을 작성하는것이 좋음!
        
  - 학습테스트 
    - 학습테스트 장점
      - 다양한 조건에 따른 기능을 손쉽게 확인 가능
      - 학습한 테스트 코드를 개발중에 참고가능
      - 프레임워크나 제품을 업그레이드할때 호환성 검증을 도와줌
      - 테스트 작성에 좋은 훈련이됨
    - 버그 테스트 : 코드에 오류가 있을때 그 오류를 가장 잘 드러내 줄 수 있는 테스트. 일단 버그테스트는 실패하도록 만들어야함!
      - 장점
        - 테스트의 완성도를 높임
        - 버그의 내용을 명확하게 분석
          - 동등분할 : 같은 결과를 내는 값의 범위를 구분해서 각 대표값으로 테스트를 하는 방법. 작업의 결과의 종류가 true, false 또는 예외발생이라면 각 결과를 내는 입력값이나 상황의 조합을 만들어 모든 경우에 대한 테스트를 해보는게 좋다!
          - 경계값 분석 : 경계의 근처에 있는 값을 이용해 테스트하는것. 숫자의 입력값인 경우 0이나 그 주변값 도는 정수의 최댓값, 최솟값 등으로 테스트하는것!


- 3장 템플릿
  - 템플릿이란 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며, 일정한 패턴으로 유지되는 특성을 가진 부분을, 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할수 있도록 하는방법! (즉, 변하는곳과 변하지않는곳을 분리/독립시키는 패턴)
  - 템플릿 메소드 패턴 : 변하는 부분은 하위클래스에서, 변하지않는부분은 상위클래스에서 정의. 즉, 하위클래스에서 오버라이딩한 메소드(변경이 일어나는..)를 상위클래스에서 호출함 => 이는 변할때마다 클래스가 새로 생성되어야함
  - 이에대한 개선으로 전략패턴의 최적화를 생각할수있음. 변하는 부분을 전략패턴으로 사용. 변화되는부분을 메소드의 파리미터로 전달받음(전략객체)으로써 지속적으로 클래스 생성하는것을 막을수있으며, 소스도 더 직관적으로 볼 수 있음. - 템플릿/콜백 패턴 (전략객체를 위한 인터페이스는 보통은 하나의 메소드를 사용하며 이러한 전략객체를 메소드로 전달할때 익명클래스로 생성하여 전달해줌 - 마이크로 DI)
    - 마이크로DI : 일반적으로 DI는 의존관계에 있는 두개의 오브젝트와 이 관계를 다이내믹하게 설정해주는 오브젝트 팩토리(DI 컨테이너), 이를 사용하는 클라이언트라는 4개의 객체에서 일어난다. 이러한 DI가 하나의 메소드안에서 객체를 생성하고 전달하여 의존관계를 셋팅하여 매우 작은 단위의 코드와 메소드 사이에서 일어나기도 하는데, 이를 마이크로 DI라고 한다.

  - 템플릿/콜백 패턴 : 전략패턴의 컨텍스트를 템플릿이라 부르고, 익명 내부클래스로 만들어지는 오브젝트를 콜백이라고 부른다.
    - 템플릿 : 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀. 고정된 틀 안에서 바뀔수 있는 부분을 넣어서 사용하는 경우에 템플릿이라함
    - 콜백 : 실행되는 것을 목적으로, 다른 오브젝트의 메소드에 전달되는 오브젝트(callbackObj). 즉, ***템플릿안에서 실행될 목적***으로 전달되는 객체임! 보통은 단일 메소드를 사용하고 특정 기능을 위한 한번 호출하는게 일반적
      - obj.method(callbackObj)
    - 특징 
      - 메소드 단위로 사용할 오브젝트를 매번 새롭게 전달
      - 클라이언트 메소드 내의 정보를 직접 참조! (클라이언트가 템플릿 메소드 호출시 오브젝트를 익명내부 클래스로 만들기때문에 그때의 클라이언트에 담긴 정보를 참조가능! 강력하게 결합되어있음!)
      - 컨텍스트 호출과 동시에 전략DI(익명내부클래스)를 수행하는것!
      - 템플릿은 한번에 하나 이상의 콜백으로 사용할수도있고, 하나의 콜백을 여러번 호출할수도 있다!

  - 3장을 통한 기타 팁
    - 중복된 코드는 먼저 메소드로 분리 => 그 중 일부 작업을 필요에 따라 바꾸어 사용해야 한다면 인터페이스를 사이에 두고 분리해서 전략패턴을 적용 & DI로 의존관계 관리 => 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어 질수 있다면 템플릿/콜백패턴을 적용
    - 테스트 작성시 네거티브를 먼저 생각해보자!

- 4장 예외
  - 예외는 두가지 처리를 염두해야함
    - 복구
    - 중단
  - 예외의 종류와 특징
    - java.lang.Error
      - 시스템에 비정상적인 상황발생하였을때. 에플리케이션 코드에서 못잡음
      - 애플리케이션에서는 해당 레벨에 대한 에러는 신경쓸필요없음
    - java.lang.Exception
      - 언체크예외
        - RuntimeException or RuntimeException 서브클래스
        - 예외처리 할수는 있으나 반드시처리해주어야하는것은 아님(컴파일 에러 안남)
        - 복구할 가능성이 없는것은 언체크 예외로처리하고 일괄적으로 handling 하는게 좋음(메일이 간다든가..)
          - <span style="color:blue">만약 문제생겼을때 (특별한 로직을 수행하지않고, 혹은 다시 처리를 진행해야하는 등이 아닌) 
          - 
          - 에러를 리턴해줘야하는거면 그냥 언체크예외를 사용해서 일괄적으로 처리해주는게좋겟다.. (ex. 문제 생겼을때 kafka로 에러 코드 전달해주는것)</span>
      - 체크 예외
        - Excpetion or Exception클래스의 서브클래스 (Not RuntimeException)
        - 예외처리 반드시 해주어야함(컴파일 에러남)
        - ***복구할 가능성이 있는 경우***에 사용. 적절한 처리로직 필요
        - 어플리케이션 예외는 체크예외를 해주는게 좋음
          - 비지니스 로직상에서 복구가 필요한 에러들..(엄밀히 말하면 이 또한 기술적으로는 시스템에러가 아니니깐 정상로직이나, 일반적인 flow에서 예외상황이라고 생각하면 좋을듯) ex) 인출시 잔고없을때 진행하는 로직
  - 예외처리 방법
    - 복구
      - 보통은 체크예외에서 사용
    - 회피
      - 바로던지기
      - 한번 catch에서 잡고 던지기(catch문에서 무언가 실행할게 있을 것)
    - 전환
      - catch에서 잡고 예외전환한뒤 던짐
      - 좀더 세부적이고 구체적인 에러를 전달하고자할때도 사용 (+ 추상화된 예외)
        - 예를들어, 단순이 Dao에서 SQLException이 아닌, DuplicateUserIdException과 같이 특정 상황에 좀더 세부적으로 전달.
        - Dao에서 적절한 예외로 전달해서 던져주면, 이에 대한 복구잡업은 service에서! 
      - 예외를 전활할때는 기존발생한 예외를 담아서 던지는 중첩예외로 만드는것이 좋음
      - 또한 체크예외를 언체크 예외로 변경하여 던져주기도함(반대일 경우도 있겠지)
        - try catch로 계속 잡아주거나 던져줄 필요없이!
  - DataAccessException
    - 스프링에서 제공하는 SQLException(JDBC)을 대체할수잇는 런타임예외(각 DBMS별로 너무 다름..ㅡㅡ)
    - 각 DBMS의 드라이버나 메타정보를 참고해서 DataAccessException의 하위클래스를(좀 더 에러의 의미를 명확하게 하기위해) 만들어주기때문에, 각 DBMS에 의존적이고 통일이 어려운 JDBC를의 한계를 보완
    - 한걸음 더 나아가, 자바의 다양한 데이터 엑세스 기술을 사용할때 발생하는 예외들을 추상화해서 DataAccessException 계층구조 안에 정리해놓았음
      - JDBC,JDO,JPA, 하이버네이트 등 데이터 엑세스 기술들에 대한 각각의 에러들에대해서 추상화시켜놓았으니 데이터 엑세스 기술들이 변해도 소스변화를 최소화 시킬수있겠지
      - ***어느정도 추상화된 공통 예외로 변환해주긴 하지만, 근본적인 한계가 있기때문에 사용에 매우 주의를 기울여야함! 미리 학습테스트를 만들어서 실제로 전환되는 예외를 꼭 확인할것!***
    - 이를 사용하면 Dao 인터페이스를 만들때 특정 데이터엑세스기술에 종속되어있는 메소드(예외 던질때 특정 엑세스기술의 Exception)가 아닌 통일 시켜줄수있음!

  - 4장을 통한 기타 팁
    - 예외안에 의미있는 정보들을 넣어주면 좋을듯!
      - 예를들어, 잔고 관련하여 에러가 났다면, 현재 남은 금액이 얼마인지도 에러클래스 내부적으로 담고있다가 전달해주면 좋을듯

- 5장 서비스 추상화 (PSA - Portable Service Abstraction)
  - 추상적인 작업 내용은 유지한 채로 구체적인 구현방법을 자유롭게 바꿀수 있도록하는것!
  - 데이터 엑세스 기술이 변경된다고해서 비지니스로직이 있는 계층(service)이 변경되어서는 안된다!
    - 그래서 dao는 인터페이스로! dao인터페이스도 exception 같은 경우, 데이터 엑세스 기술에 영향받지않도록 RuntimeException을 사용하고, 스프링에서 이미 추상화되어있는 데이터 엑세스 오브젝트를 활용하자!
    - 비지니스로직 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메소드로 정리되어야한다!
  - 이를 해결하기위해 서비스 계층을 스프링은 제공해준다
  - 각 오브젝트와 메소드가 자기 몫의 책임을 맡아 일을 하는 구조여야함!
    - ***객체 지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신, 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다.(당연히 책임이 있는 오브젝트에게 요청!) 오브젝트에게 데이터를 요구하지말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이다.***
  - 트랜잭션 서비스 추상화
    - 트랜잭션 : 쪼갤수 없는 논리 단위. 그래서 문제일어나면 아예 안되어야한다!(All or Nothing!)
    - 트랜잭션을 적용하려면 jdbc기준 동일한 connection을 사용해야하므로 보통 service 계층에서 적용을 하게된다. 그러나, 그렇게 된다면 다른 데이터 엑세스 기술을 사용하게되면, 데이터 엑세스 기술별로 service를 만들어야한다. 이를 막기위해서 스프링은 PlatfromTransactionManager라는 추상화된 서비스를 제공해준다.
      - 즉, DI만 특정 데이터 엑세스 기술에 맞춰서 해준다면, 서비스 계층의 코드는 전혀 고칠 필요가 없다!
  - 단일책임의 원칙
    - 스프링은 DAO와 SERVICE와 같은 수평적인 관계(로직의종류)에서도, DAO와 Datasource 같은 수직적인관계(로직과 기술)에서도 모두 결합도가 낮게 설계할수있도록 도와준다. 이는 DI로 인하여 가능하다!
    - DI는 관심, 책임, 성격이 다른 코드를 깔끔하게 분리해준다.
    - 단일 책임원칙은 하나의 모듈에는 한가지 책임이 있어야한다는것이다. 즉, 모듈이 변경되어야할 이유도 하나여야 된다는것이다!
    - 이런 단일책임원칙을 잘 지켜졌을때, 수정해야할 부분이 명확해지며, 수정해야할곳도 최소한으로 줄게된다
  - 테스트와 서비스 추상화
    - 로우레벨의 다양한 기술(하는 역할은 동일)에 대해 ***인터페이스를 활용하여 일관성 있는 접근 방법을 제공***할수잇다. 이를 통해서 확장 불가능한 API도 서비스 추상화를 통해서 손쉽게 테스트가 가능하다
    - ***특히나 외부리소스 연동에는 서비스 추상화를 통해서 더욱 손쉽게 원하는 오브젝트에만 집중하여 테스트가 가능하다***
      - 예를들어, 서비스계층에서 특정기능 수행시 확인 메일발송 기능이 있을때, 메일발송은 주된로직이 아니므로 이를 추상화해놓는다면(mock객체 생성가능) 빠르게 서비스의 주 기능을 테스트 해볼수있다
    - 테스트 대상으로부터 전달받은 정보를 검증할수있도록 설계된것을 목 오브젝트라한다
      - 스텁 + 테스트 결과 및 테스트 대상 오브젝트와 이와 연계된 의존오브젝트간에 일어나는일을 검증
      - *스텁 : 테스트 코드가 정상적으로 수행하는것을 도움
      - 그냥 Mock은 가짜 객체로 이해하는게 좋을듯함..
  - 5장을 통한 기타 팁
    - ENUM을 잘 활용하자!
      - 타입에 안전!
      - ENUM을 사용하여 다양하게 활용이 가능하니 잘 익혀둘것!
        ```java
        public enum Level {
            GOLD(3,null),SILVER(2,GOLD),BASIC(1,SILVER);

            private final int value;
            private final Level nextLevel;

            Level(int value,Level nextLevel){
                this.value = value;
                this.nextLevel=nextLevel;
            }

            public int intValue() {
                return value;
            }

            public Level nextLevel(){
                return nextLevel;
            }

            public static Level valueOf(int value){
                switch (value){
                    case 1 : return BASIC;
                    case 2 : return SILVER;
                    case 3 : return GOLD;
                    default : throw new UnsupportedOperationException("not defined type : "+value);
                }
            }

        }
        ```
    - update시에 where 조건이 정상적으로 먹지 않아 모두 update되는 불상사를 막기위해 항상 update요청한데이터, 그렇지않은 데이터 2개의 로우를 테스트할것
    - 테스트 진행시에는 경우의 수를 잘 따져가면서 해야한다! 대충 한두개 됐다고 넘어가면안됨!!
    - 테스트 데이터는 변경이 일어나는 경계가 되는값의 전후를 잘 활용하라!
    - 코드개선시 항상 숙지할것!
      - 코드에 중복된 부분은 없는지
      - 코드가 무엇을 하는것인지 이해하는데 불편함은 없는지
      - 코드가 자신이 있어야할 자리에 잇는지
      - 앞으로 변경이 일어나면 무엇이 있을수 있고, 그 변화에 쉽게 대응할수잇도록 작성이 되어있는지
    - 도메인 클래스에 비지니스 로직이 들어가면 테스트소스만들어라! 
    - 비지니스 로직 처리시 중간에 에러를 일부러 내야한다면, 그런 에러를 낼수있는 서비스 클래스를 새로 만들어라!(되도록이면 테스트 클래스 내부에서!)

- 6장 AOP
  - 핵심기능(타겟)같은 경우는 독립적으로 존재 가능하며 그렇기에 테스트도 가능하다. 그러나, 부가기능(ex. 트랜잭션)같은 경우는 핵심기능에 종속되어있을수 밖에 없다. 그로인해 독립적으로 테스트가 어렵고, 코드상에도 명확하게 분리가 어렵다. 이를 해결하기위해 AOP라는 개념이 생기게 되었으며, 이는 부가기능을 하나의 관점으로 따로 떼어 볼수 있도록 해주어서 부가기능만을 집중해서 개발하고 테스트 가능하게 되었다. 즉, 관점지향프로그래밍인 AOP는 OOP를 도와줄수있는 존재이며, 이를 따로 떼어서 설명할수 없다
  - 트랜잭션의 사용이 AOP로 발전되는 순서 (p500~ 간단하게 설명굿)
    - 프록시(데코레이터 패턴)를 사용하여 비지니스 로직과 트랜잭션 로직을 분리
      - 프록시 오브젝트는 기존 비지니스로직(타겟)을 DI받아 트랜잭션에 필요한 작업을 구현하고 타겟을 호출
      - 부가기능은 마치 자신이 핵심 기능을 가진 클래스인것처럼 꾸며서(핵심기능의 인터페이스를 동일하게 구현), 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만들어야함
      - 트랜잭션 기능을 부여하지않아도 되는 메소드 조차 프록시로서 위임기능이 필요하기때문에 일일이 다 구현을 해줘야함..
    - 다이나믹프록시를 활용한 트랜잭션 전용 bean을 생성
      - 다이나믹 프록시를 확장하여 지정한 특정 메소드만 사용할수 있도록 해줄수있음
        - InvocationHandler에 데코레이터 패턴을 적용하여 pointcut과 유사하게 적용할수있음(패턴을 받으면됨)
      - 하지만, 이는 트랜잭션을 적용할 타겟이 생길때마다 설정에서 추가로 셋팅을 해주어야함.. 중복!
      - 트랜잭션뿐 아니라 다른 부가기능을 추가해야할때마다 설정 변경 및 추가필요
      - ~~invocationHandler의 재사용이 어려움.. 새로운 타깃이 있으면 새로 만들어야..?~~ 이건 약간 어떻게 만드느냐에따라 다를듯..
      - *JDK의 다이나믹 프록시는 특정 인터페이스를 구현한 오브젝트에 대해서 프록시 역할을 해주는 클래스를 런타임시 내부적으로 만들어준다. 런타임시에 만들어지기때문에 클래스 소스가 따로 남지 않을뿐이지 타깃 인터페이스의 모든 메소드를 구현하는 클래스가 분명히 만들어진다..
    - ProxyFactoryBean
      - 서비스 추상화를 프록시 기술에도 적용
      - 다이나믹프록시에서 사용하는 invocationHandler는 Proxy 사용을 위해 타겟을 직접 넣어주며 타겟의 기능을 직접 실행시켜주어야하는데, MethodInterceptor는 추상화가 되어있어서 MethodInvocation.proceed()만 호출하는 타깃을 실행시킨다. 그렇기 때문에 부가기능에 집중할수 있다. (MethodInvocation에는 타깃오브젝트에대한 정보가 담겨져있다)
      - 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유가능
      - 내부적으로 java의 다이내믹프록시를 사용함!
      - 다이나믹 프록시를 생성할때, Pointcut을 사용하여 적용해야할 대상인지를 구분하고, 적용해야할 부가기능이 정의된 advice를 invocation콜백에 적용하여 타깃을 감싼다(프록시 적용)
      - Advice, Advisor 모두 공유가 가능하지만, 결국 타깃이 생길떄마다 설정에 ProxyFactoryBean 설정을 동일하게 해주어야함(중복)
    - DefaultAdvisorAuitoProxyCreator
      - bean 후처리기를 이용한 자동 프록시 생성기
        - BeanPostProcessor를 구현
        - bean 후처리기란 이름 그대로 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준것(후처리!)
      - bean으로 등록된 모든 advisor 내의 pointcut을 이용해 생성된 bean이 프록시 적용대상인지를 확인하고, 적용대상이면, 내장된 프록시 생성기에게 현재 bean에 대한 프록시를 만들게하고 만들어진 프록시에 어드바이저를 연결해준다. 또한 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨터이너에게 돌려줌
      - 등록된 "어드바이저"를 알아서 찾아서 읽고 적용한다!!!
      - 여기서 좀더 나아가 스프링은 간단하고 효과적인 방법으로 포인트컷의 클래스와 메소드를 선정하는 알고리즘을 작성할수 있는 방법인 "포인트컷 표현식"을 제공
        - AspectJExpressionPointcut 클래스 사용
        - 이를 사용해 클래스와 메소드의 선정 알고리즘을 한번에 지정가능
        - 포인트컷 표현식 문법(메소드의 풀 시그니처를 문자열로 비교하는개념)
          - *메소드의 풀 시그니처란 Target.class.getMethod("methodName",int.class,int.class) 를 찍어보면 확인가능
          - ex. public int com.test.Target.methodName(int,int) throws java.lang.RuntimeException
  ```java
    execution([접근 제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴|"..",...))
    //타입패턴 : 클래스 이름이 아닌, 오브젝트의 타입! ex. 인터페이스, 슈퍼클래스
    //자세한것은 토비스프링vol1 p491~ 참고
  ```
  - 프록시(대리자, 위임자) : 클라이언트와 사용대상사이에 대리역할을 맡은 오브젝트를 총칭
    - 데코레이터 패턴
      - 부가적인 기능을 부여해주기위해
      - 타겟의 소스변경x, 클라이언트 소스 변경x, 기능추가 o
      - 
    - 프록시 패턴               
      - 클라이언트가 타깃에 접근하는 방법을 제어하기위함 (그냥 프록시와 프록시 패턴은 다르다)
      - 타깃의 기능 확장에 관여 x
      - 예시
        - 프록시를 통해 생성을 늦추는것
        - 원격 오브젝트를 이용하는것 (ex. RMI)
          - 원격에 있는 오브젝트를 클라이언트는 마치 로컬에 존재하는 오브젝트를 쓰는것처럼 프록시 사용가능
        - 
  - AOP 적용기술
    - 스프링 AOP
      - 프록시 사용
    - AspectJ
      - 클래스로딩시 바이트 코드 조작
      - 컴파일된 타겟의 클래스파일 자체를 수정
      - 그럼 이를 왜쓰나?
        - 스프링 컨테이너를 사용하지않기때문에 이를 사용하지않는 환경에서돟 손쉽게 AOP 적용가능
        - 프록시 사용에 따른 제약으로 부터 자유로움
          - 프록시는 메소드로만 제한(private은 또 안됨)
          - AspectJ는 스태틱 메소드 호출이나 초기화, 심지어 필드 입출력 등에 부가기능을 부여할 수 있음
        - 근데, 사용이 조금 어려운게 단점!
  - AOP 관련 용어정리
    - target(타깃) : 부가기능 부여할 대상. 핵심기능 담은 클래스 or 부가기능 담은 프록시 오브젝트가 타깃이 될수있음
    - join point : 어드바이스가 적용될수 있는 위치. 타깃 오브젝트가 구현한 인터페이스의 모든 메소드는 조인포인트가 됨
    - proxy : 클라이언트와 타깃 사이에 투명하게 존재. 부가기능을 제공. 스프링은 프록시를 통해 AOP를 지원
    - Advice : 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트. 타깃 오브젝트에 종속되지않는다! 순수한 부가기능!(ex. MethodInterceptor를 구현한 오브젝트)
    - Pointcut : 메소드 선정 알고리즘을 담은 오브젝트! => 적용 클래스 맞는지(클래스필터), 메소드 맞는지(메소드매처)
      - 어드바이스 적용할 조인포인트를 선별하는 작업 또는 기능을 정의한 모듈
      - spring aop는 AspectJ pointcut expression language 를 기본적으로 사용함
    - Advisor : Pointcut + Advice. 즉, 어떤 부가기능(advice)을 어디에 전달(pointcut)할 것인지를 알고 있는 모듈
    - Aspect : application을 구성하는 중요한 한가지 요소. 핵심기능에 부가되어 의미를 갖는 특별한 모듈. Advisor는 단순한 형태의 Aspect!
    - AOP : 관점 지향 프로그래밍. 핵심기능과 부가기능을 분리함으로써 부가기능을 하나의 관점에서 바라볼수 있도록 프로그래밍 하는것. 이를 통해서 부가기능에만 또한 집중할수있다(개발,설계시) 그래서 AOP는 OOP와 대비되는 개념이 아니라, OOP를 돕는 보조적인 기술.

  - 트랜잭션 좀더 알아보기
    - 트랜잭션 속성
      - 트랜잭션 전파(propagation) : 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을때 또는 없을때 어떻게 동작할 것인가를 결정하는 방식. 예를들어, 트랜잭션 전파가 REQUEIRED(기본값)으로 되어있다면, 트랜잭션을 이미 시작한 A서비스에서 DB에 접근하는 다른 B서비스(트랜잭션이 적용되어있는 서비스) 를 호출하였을 경우, 이미 시작한 트랜잭션이 있기때문에 새로운 트랜잭션을 만들지 않음. 즉, B서비스에서 에러나면 A서비스에서 이미 진행되었던 작업또한 롤백이 이루어짐
        - PROPAGATIOIN_REQUIRED : 이미 시작된 트랜잭션이 있으면 참여
        - PROPAGATIOIN_REQUIRED_NEW : 앞에 시작된 트랜잭션이 있던지 상관없이 새로운 트랜잭션 시작
        - PROPAGATIOIN_NOT_SUPPORTED : 트랜잭션 적용무시
          - 트랜잭션을 사용하지 않게 한다. 이미 진행 중인 트랜잭션이 있으면 보류시킨다.
        - [종류 정리](https://oingdaddy.tistory.com/28)
        - 이에 대한 설정을 기반으로 트랜잭션 메니저의 getTransaction()호출시 새로운 트랜잭션을 만들지 말지를 결정
      - 격리수준
      - 제한시간
        - 트랜잭션 수행하는데 제한시간을 걸수 있음
        - 기본값은 제한시간없음
      - 읽기전용
        - read only로 셋팅하면, 트랜잭션 내에서 데이터 조작하는시도를 막을수있음
    - 트랜잭션 사용시 트랜잭션 속성도 함께 프로퍼티로 셋팅가능한 TransactionInterceptor라는 트랜잭션 전용 advice가 있는데 런타임예외가 발생하면 트랜잭션은 롤백되지만, 체크예외를 던지는 경우에는 커밋이 된다(체크예외는 잡지않는다!)
    - ***타깃 오브젝트가 자기자신의 메소드 호출할때는 프록시를 통한 부가기능 적용x => 이를 해결하기 위해서는 AspectJ..***
    - @Transactional
      - 스프링부트는 이거쓰면끝.. 함수또는 클래스에..
      - 인터페이스에도 사용가능하나, 되도록 타깃 클래스에서 적용할것!
  - 6장을 통한 기타 팁
    - 특정 서비스 자체를 테스트하고싶다면, 이와 연관되어있는 오브젝트(ex. DAO)와는 고립을 시켜주는게 좋음
      - 특정 service 테스트시 리턴해주는 값도 없다면 내부에 의존되어있는 오브젝트의 메소드를 호출했는지, 호출했으면 몇번이나 했는지 등에 대한 확인이 필요! 이를 위해 목 오브젝트 사용 (Mockito 사용할것!)
      - DAO와 같이 DB를 연결하고 하는 작업들을 MOCK으로 사용하게되면, 테스트에대한 부담도 줄고 시간도 절약할수있다!(커넥션이나 기타 다른 작업을 생략하니 훨씬 빨라짐!)
    - 단위 테스트와 통합테스트 (토비스프링에서 아래와같이 정의해서 부른다고 하겠다하지만 통용되는듯함)
      - 단위테스트 : 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는것
      - 통합테스트 : 두개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 
      - 가이드s
        - 항상 단위테스트 먼저 고려할것
        - 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트등의 테스트 대역을 이용하도록 테스트를 만들것
        - 외부 리소스 사용해야만 가능한 테스트는 통합테스트로 만들것
        - DAO는 DB연동해서 테스트하는게 좋고, 충분히 검증이 끝나면 대역으로 전환할것! 물론, 나중에 다른 오브젝트와 실제 엮어서 통합테스트도 함께 진행하여야함!
        - 결국 통합테스트는 반드시 이루어져야함! 하지만 단위 테스트를 충분히 거쳤다면 통합테스트에 대한 부담은 많이 줄수 있음
        - 단위 테스트를 만들기가 너무 복잡하면 처음부터 통합테스트를 고려해볼것.. 하지만 이때도 최대한 할수있는 단위테스트는 마치고 진행하는게 좋음!
        - 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합테스트! 가능하면 스프링의 지원없이 직접 코드레벨의 DI를 사용하면서 단위테스트하는게 좋음!(물론, 다 그렇게 되기는 어려움)
        - => 테스트를 잘 작성하면서 진행하지않으면 소스 리팩토링에 대한 "용기" 를 잃어버리기 때문에 코드의 품질은 떨어진다!!
    - 스프링의 빈(bean)은 기본적으로 클래스 이름과 프로퍼티로 정의되고, 스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해서 해당 클래스의 오브젝트를 만든다
      - 리플랙션(reflection) 을 사용하면 private 생성자도 만들어주기때문에(reflection은 private 접근규약을 위한가능), private 생성자로 되어있는 오브젝트를 빈으로 등록할때 스태틱메소드로 객체를 생성해서 빈으로 등록해주어야한다!
    - xml 설정시 Class 타입은 value를 이용해 클래스 또는 인터페이스의 이름을 넣어주면된다. 스프링은 프로퍼티의 타입이 Class인 경우는 value로 설정한 이름을 가진 Class 오브젝트로 자동변환해준다.
    - 다른 모듈의 DAO접근시에는 해당 DAO모듈을 갖는 서비스계층을 거쳐가자!
    - 테스트 프레임워크에서 @Transactional 사용시 자동으로 rollback된다! 이를 막기위해서는 @Rollback(false)를 함께 선언해준다!
    - 되도록 통합 테스트할때는 @Transactional을 사용하자

- 7장 스프링 핵심 기술의 응용
  - 스프링은 빈을 생성하고, DI 진행하고, 해당 빈의 초기화작업이 이루어지는 "후처리기" 가 있다(BeanPostProcessor)
    - @Transactional, @PostConstruct 도 후처리기에서 등록해주는것
  - SqlService
    - 기능
      - 외부 리소스 읽어오기(SqlReader)
      - 읽어온 리소스를 잘 보관하고있다가 필요할때 제공(SqlRegistry)
      - 필요에따라 SQL 수정
    - 구현
      - SqlService는 SqlReader에서 데이터를 가져와서 다시 SqlRegistry에 제공하는 번거로움보다, SqlReader에게 SqlRegistry(전략)를 아싸리 넘겨주는게 좋음! //센스!
  - Resource
    - 스프링에서 제공해주는 리소스를 접근할수있도록 추상화한 인터페이스
      - 그냥 자바에서는 URL클래스를 통해서 웹이나 외부의 리소스(like file)에 대한 접근을 할수있었는데, 클래스패스안에 존재하는 리소스나 서블릿 컨텍스트의 리소스를 지정하는 방법이 없었음.. 또한 파일존재여부를 미리 파악할수도 없었음..
    - applicationContext가 사용할 설정정보 파일을 지정하는 것부터 시작해서 스프링의 거의 모든 API는 외부의 리소스 정보가 필요할때는 항상 이 Resource 추상화를 이용
    - ResourceLoader
      - 문자열안에 리소스의 종류(접두어)와 리소스의 위치를 전달하면, 리소스 종류에 맞게를 이용해 Resource 오브젝트를 리턴해줌!
      - file:, classpath:, http: 등 
      - Resource는 설정에서 따로 주입받지않는데, applicationContext가 ResourceLoader이기에 주입하는 타입이 Resource 이면 문자열을 적절한 Resource의 구현체로 알아서 셋팅해준다!
    - Resource는 단지 리소스에 접근할 수 있는 추상화된 핸들러일뿐! Resource 타입의 오브젝트가 만들어졌다고 해도 실제로 리소스가 존재하지 않을 수 있다!
    - "classpath:"는 루트부터 절대위치를 적어야한다!

  - 내장형DB
    - 애플리케이션에 내장돼서 애플리케이션과 함께 시작되고 종료되는 DB를 말한다. 
    - 데이터는 메모리에 저장되기때문에 IO로 인해 발생하는 부하가 적어서 성능이 뛰어남!
    - EmbeddedDatabase로 추상화!
      - 스프링 컨테이너가 종료될때 알아서 shutdown 되기때문에 종료코드가 필요없음
    - 트랜잭션도 된다!
      - 일괄처리가 필요한 로직에 있어서는 내장형DB를 생각해보는게좋겠지
  - Spring 3.1 DI
    - 자바언어의 변화와 스프링
      - 애노테이션의 메타정보활용
        - 자바코드가 실행목적이 아닌, 코드를 보고 어떻게 동작할지를 결정! 즉, 리플렉션 API를 활용해 어떻게 만들었는지 살펴보고 그에 따라 동작을 하는 기능이 많이 사용되고있다! 메타정보를 데이터로활용! (어노테이션 사용하여..)
    - 정책과 관례를 이용한 프로그래밍
      - 미리 정의한 규칙을 따라서 프레임워크가 작업을 수행!
      - 이런 스타일을 통해서 자바코드로 모든 작업 과정을 직접 표현했을때에 비해서 작성해야할 내용이 크게 줄었음!(즉, 알아서해준다는것)
      - 코드는 간결해졌으나, 정책을 잘못알고있거나 기억못하면 의도한대로 동작하지않는 코드가 만들어질수있다는 단점이있음..
    - 빈 스캐닝과 자동와이어링
      - @Autowired
      - @Component
        - 이게 붙어있으면 자동으로 bean으로 등록시켜주는 마커(maker)와 같음
        - 따로 bean id를 지정해주지않으면 클래스이름의 맨앞을 소문자로 바꿔서 bean id로 등록해줌
      - @ComponentScan
        - @Component가 자동으로 bean으로 등록시켜주려면 빈 스캔기능을 사용하겠다는 애노테이션 정의가 필요!
        - @ComponentScan(basePackages="spring.good") 라고 정의할수도잇는데, spring.good 패키지 하위에잇는 모든 클래스를 스캔해준다
    - 컨텍스트 분리와 @Import
      - 독립적인 모듈은 context를 따로 빼는것이 좋다! 해당 context를 뺏다면 @Import를 통해서 가져오면된다!(근데 스프링부트를 사용하게되면 @Configuration으로 등록해도 상관없을듯한데..)
    - 프로파일
      - 운영과 테스트시에 bean의 타입이나 이름은 같지만 구분해서 등록이 필요한 경우가 있는데, 이때 프로파일을 사용하면좋다
      - @Profile("prod") 로 지정하면, 활성 프로파일 목록에 "prod"가 등록되어있을때만 동작한다
        - 활성프로파일이란 스프링컨테이너를 실행할때 추가로 지정해주는속성
          - @ActiveProfiles("prod") 이런식으로 지정도 가능하며, 부트에서는 application.properties에서 셋팅가능
    - 프로퍼티 소스
      - 프로퍼티 파일의 확장자는 보통 .properties이며 내부에 키=값 형태로 프로퍼티를 정의
      - @PropertySource 어노테이션을 통해서 등록가능하며, 이를 Environment 객체에 저장하게된다
        - Environment로 가져오면 딱 해당 문자열을 가져옴..
        - @Value를 통해서도 가져올수있는데, 이를 사용하면 적절한 변환이 됨 (PropertySourcePlaceholderConfigurer 가 static으로 등록되어있어야함)
    - 빈 설정의 재사용과 @Enable*
      - 경로셋팅과 같은 설정값에 변경이 필요한부분은 인터페이스로 빼주어 DI 되도록 하면좋다! 그래야 완벽히 독립된 모듈로써 자유롭게 가져다쓰기좋다
      - @Import로 사용된것들도 좀더 의미있게만들기위해서 @Import를 매타에노테이션으로 놓고 @Enable\*을 정의해서 사용하면좋다. 이를 확장하면 Import에서 필요한 설정값을 @Eanble\*에서 가져오도록 셋팅하여 넘겨줄수도있따!
  - 7장을 통한 기타 팁
    - 인터페이스에만 의존하도록 만들어야 구현클래스를 바꾸고 의존 오브젝트를 변경해서 자유롭게 확장하기 좋다!
    - 성격이 다른 코드가 한데 섞여 있는 클래스라면 먼저 인터페이스를 정의해서 코드를 각 인터페이스별로 분리하는게 좋다. 다른 인터페이스에 속한 기능은 ***인터페이스를 통해 접근***(직접접근x)하게 만들고, 간단히 자기참조 빈으로 의존관계를 만들어 검증한다. 검증을 마쳤으면 아예 클래스를 분리!
    - 특정 의존 오브젝트가 대부분의 환경에서 거의 디폴트라고 해도 좋을 만큼 기본적으로 사용될 가능성이 있다면, 디폴트 의존관계를 갖는 빈을 만드는것을 고려해볼 필요가있따!
      - 디폴트 의존관계란 외부에서 DI받지 않는 경우 기본적으로 자동 적용되는 의존관계를 말한다.(그냥 직접 생성해서 DI해줌)
    - DI는 확장을 위해 필요한것이므로 항상 미래에 일어날 변화를 예상하고 고민해야 적합한 설계가 가능하다. 결국 ***DI는 미래를 프로그래밍하는것!***
    - DI를 DI 스럽게 만들기 위해서는 오브젝트간에 인터페이스를 통해 느슨하게 연결해야한다. "DI한다! => 인터페이스로 만든다!" 라고 기억하자!
    - 인터페이스의 분리원칙
      - 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는것!
      - 이를 통해서, 클라이언트와 오브젝트간에 관계를 명확하게 할수있다!
      - A오브젝트가 B오브젝트가 필요한데, B오브젝트가 구현한(혹은 타입을 상속한) B1이라는 인터페이스만 필요하다면, B오브젝트 전체를 넘겨주지말고 B1인터페이스로 넘겨주라! 굳이 B1외의 것을 보여줄필요가없잖아!
    - 새로만든 클래스의 빈이 다른 빈 오브젝트와 함께 사용될때 문제없는지 확인을 위해서 통합테스트하는것을 잊지말것!
    - @Bean 등록시 주의사항..
      - 메소드의 리턴값의 타입은 주입받아 사용하는 타입으로! 예를들어, DataSource(인터페이스)로 주입받는다면, return 타입도 DataSource(인터페이스)로!
      - @Bean 메소드 안에 로컬변수의 타입은 필요한 생성한 오브젝트 타입을 그대로쓰면댐! 인터페이스로 추상화하면 해당 객체의 세부 기능을 사용못하니깐!(어차피 bean 셋팅할때 한번만쓰게되니깐 문제없고, 제대로 등록하려면 당연히 그렇게해야겟지..)
    - @Configuration 안에서 다른 설정정보 필요하면 내부적으로 @Autowired로 주입받아서 해당 설정 객체의 데이터를 가져오면된다!
    - @Resource는 필드이름기준으로 bean을 찾는다. @Autowired는 필드타입기준.. 없으면 이름이 일치하는지
    - @Enable 로 시작하는 애노테이션들은 관례적인것들을 사용하기 쉽도록 만들어놓은것이다!
      - 즉 @EnableTransactionManagement 을 선언하면 <tx:annotation-driven />을 선언한것과 같다
      - 아래의것들을 생성하고 적절히 DI해준것
        - InfrastructureAdvisorAutoProxyCreator
        - AnnotationTransactionAttributeSource
        - TransactionInterceptor
        - BeanFactoryTransactionAttribtteSoruceAdisor
    - 단지 주입받는게 아닌, 다른 작업이 필요하면(like 주입받는 오브젝트로 새로운 오브젝트를 생성하는..) 수정자 메소드에 @Autowired 선언해서 만들어주면댐
    - 설정정보가 아주 많으면 분리해주는것이 좋으나, 그렇지않으면 하나로 관리하는것이 좋음. 그렇다고 구분없이 하나에다가 다 때려받는것이아니라, 스태틱 중첩 클래스를 활용할것!(스태틱 중첩클래스위에 @Configuration 하나 붙여주면끝)

- 8장 스프링이란 무엇인가?
  - 스프링이란?
    - ***자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크***
      - "애플리케이션 프레임워크"
        - 일반적인 프레임워크는 특정계층에서 한가지 기술분야에 집중이 되는데(ex. ORM은 DB쪽), 스프링은 애플리케이션 전 영역을 포괄하는 범용적인 프레임워크이다. 
        - 애플리케이션 개발의 "전 과정"을 빠르고, 효율적으로 개발하기위함!
        - 단지 여러계층의 다양한 기술을 한데 모았다는것 이상으로 애플리케이션 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 가진다!
      - "경량급"
        - 이전에 있었던 무거운 프레임워크나 기타 환경에 종속되었던것들로부터 훨씬 자유롭고 가볍기때문에 경량이라 표현
        - 예전에는 고가의 무거운 WAS 가 필요했고, 그에 맞는 설정파일구조와 패키징 등 개발환경이 필요했는데, 스프링은 톰켓이나 제티를 사용하여 서블릿 컨테이너로만도 개발이 가능하다! 또한 이런것들을 사용할때, 엔터프라이즈 개발의 고급기술을 대부분 사용할수 있다
      - "자바 앤터프라이즈 개발을 편하게"
        - 개발자가 복잡하고 실수하기 쉬운 로우 레벨 기술을 많이 신경쓰지 않으면서 사용자의 요구사항인 비지니스로직을 빠르게 개발해 나가는것!
        - 스프링 자체에 집중이아닌 비지니스 로직에 집중!  
    - 엔터프라이즈 서비스 기술을, POJO 방식으로 개발된 애플리케이션의 핵심로직을 담은 코드에 제공할수있도록 해주는것이 스프링의 강력한 특징과 목표!
      - POJO(Plain Old Java Object)?
        - 자바의 단순한 오브젝트
          - ***객체지향 원리에 충실하고 환경과 기술에 종속되지않는 오브젝트!***
        - POJO로 개발할수있게 해주는 가능기술이 IoC/DI, AOP, PSA 이다
          - IoC/DI
            - A->B 의존관계에서, B는 자유롭게 확장가능하고(확장에 열려있음) B가 변경되도 A는 아무런 영향을 받지않고(변경에는 닫힘) 그대로 유지가능한것! (OCP 실현)
            - 활용
              - 핵심기능의변경(전략패턴)
              - 핵심기능의 동적변경
              - 부가기능의 추가(데코레이터패턴)
              - 인터페이스의 변경
                - 인터페이스 호환안될때 어댑터패턴으로 접근. 이에 더 나아가 좀더 일반화하면 서비스 추상화(PSA)
              - 프록시
              - 템플릿과 콜백(마이크로 DI)
              - 싱글톤과 오브젝트 스코프
              - 테스트
                - 고립가능케하여 필요한 테스트에 집중 가능
          - AOP
            - POJO 만으로 엔터프라이즈 애플리케이션을 개발하면서도 엔터프라이즈 서비스를 선언적으로 제공하는데 반드시 필요한 기술!
            - 적용기법
              - 스프링이 제공해주는 다이내믹 프록시사용
                - public 메소드 호출에만 적용가능
              - AspectJ를 활용하여 다양한 조인포인트 사용 
          - PSA
            - 환경과 세부기술의 변화에 관계없이 ***일관된 방식***으로 기술에 접근할수있게해줌
  - 엔터프라이즈 개발의 복잡함
    - 왜 복잡한가?
      - 엔터프라이즈 시스템을 개발하는데는 순수한 비지니스 로직을 구현하는것 외에도, 기술적으로 고려할 사항이 많음
      - 비지니스 로직의 복잡함
      - => 위 두개가 짬뽕되고 강력한 결합을 초래.. 
    - 해결책
      - 기술적복잡함과 비지니스로직의 복잡함을 최대한분리하자!
      - 기술의 적용사실이 코드에 직접 반영되지않는, 즉 이로인해 코드의 설계와 구현방식을 제한하지않는 비 침투적인 기술을 사용!(스프링!)
        - EJB는 어떤 기술을 적용했을때 그 기술과 관련된 코드나 규약등이 코드에 등장하는 경우를 침투적인 기술이라함
  - 복잡함을 상대하는 스프링의 전략
    - 기술적 복잡함을 상대하는 전략
      - 서비스 추상화
        - 기술에 대한 접근방식이 일관성이 없고, 특정환경에 종속적인것을 해결
      - AOP
        - 기술적인 처리를 담당하는 코드가 성격이 다른코드에 섞여서 등장
          - 기술적인 처리라는것은 트랜잭션같은것!
    - 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략
      - 자바의 객체지향 언어를 잘 살릴수있도록 해줌!
      - POJO
    - => 이 전략들의 도구는 기본적으로 객체지향과 DI
      - 기술적인 복잡함을 해결하기위해서는 DI가 바탕이 된 여러가지 기법이 활용! 
      - 비지니스 로직의 복잡함을 해결하기 위해서는 DI보다는 객체지향 설계 기법이 중요! (근데 DI도 객체지향설계를 위한 도구인디..??)
      - 기술적인 코드에 침범당하지않은(기술의 복잡함이 잘 분리된) 비지니스로직은 객체지향적인 특성을 잘 살린 상속, 다형성, 위임을 포함해서 객체지향 디자인패턴과 설계기법을 잘 녹일수있다!!
  - 정리
    - 엔터프라이즈 서비스를 개발하는데 있어서, 기술적 복잡함과 비지니스로직의 복잡함을 분리하여 POJO 방식(객체지향 추구, 기술과 환경에 종속x)으로 비지니스로직에 집중할 수 있도록 도와주는것이 스프링! 이를 가능하도록 기술적으로 도와주는것이 IoC/DI, AOP, PSA 이다   
    이를 통해 애플리케이션 개발의 모든 기술과 영역을 종합적으로 다루는 애플리케이션 프레임워크를 실현!

- 9장 스프링 프로젝트 시작하기
  - 스프링의 주요기능은 웹브라우저를 클라이언트로하고 DB에 데이터를 저장, 조회하는데 집중되어있음
  - 스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE 서버가 필요
    - JavaEE 표준을 따르는 애플리케이션 서버는 두가지
      1. 경량급 WAS/서블릿 컨테이너
        - 보통 스프링은 jetty나 tomcat같은 서블릿 컨테이너 사용
      2. WAS
  - 스프링 애플리케이션 배포단위
    - war : 톰캣과 같은 서블릿 컨테이너 사용할때
    - ear : 엔터프라이즈 애플리케이션으로 패키징하는것. EJB모듈 관련
  - 스프링이 지원하는 기술이란
    1. 해당 기술을 스프링의 DI패턴을 따라 사용가능
        - 적절한 프로퍼티를 통해서 값을 주입받기도하고 빈으로도 등록가능
    2. 스프링의 서비스 추상화적용
        - ***일관된 접근!***
        - 비슷한 기술들 그러나, 구현은 다 각기 다른 기술들에 대해 일관된 접근을 제공
    3. 스프링이 지지하는 프로그래밍 모델을 적용
        - DAO에서 예외들을 하나로 묶어주는것과 같이 특정 기술에 종속x(2번이랑 비슷한듯..)
    4. 템플릿/콜백 이 지원
        - JDBC, JMS, JCA 를 비롯한 여러가지기술을 지원하는 템플릿/콜백을 제공
        - 만약 템플릿/콜백이 없다면 판에 박힌 코드때문에 상당히 지저분해짐
    - => 기술,환경에 종속되지않는 추상화를 제공해주는게 핵심인듯


  - 9장을 통한 기타 팁
    - 계층형 아키텍처
      - 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해 내는것을 아키텍트차원에서 계층형 아키텍처라함
      - 멀티티어 아키텍처라고도함
      - 일반적으로 웹은 3개의 계층을 갖는다하여 "3-tier 애플리케이션" 이라함
        - 3계층 아키텍처
          - 데이터 엑세스계층 : DB나 레거시 시스템과 연동하는 인터페이스 역할
            - DB외에 ERP, 레거시시스템, 메인프레임 등에 접근하는 역할을 하기때문에 EIS(Enterprise Information System) 계층이라고도함
            - 어떤 환경이나 기술에도 영향받지않을수 있도록 추상화가 중요한데, 그로인하여 수직적 계층구조가 나타남
              - 한 계층내에서 추상화 수준에 따라 수직적으로 계층을 나누었을때를 수직적 계층이라고 함. 상위로 갈수록 더 추상화된것!
          - 서비스계층 : 비지니스 로직
            - POJO!
            - 특별한 경우가 아니라면 굳이 추상화 수직구조를 가질 필요없음! 기술API를 직접 다루지 않으므로!(로직을 모델링하다가 상속구조는 만들수있겠지)
            - AOP를 잘 활용하여 서비스 계층코드에 트랜잭션과 같은 부가기능의 기술API가 침범하지않도록 해주어야함
            - 이상적인 서비스계층은 데이터 엑세스 계층이나 프레젠테이션 계층이 바뀌어도 그대로 유지될수 있어야한다!
          - 프레젠테이션계층 : UI를 만들고 흐름을 관리
            - HTTP를 처리하는 서블릿을 기반으로 두는 경우가 많음
      - 계층형 아키텍처 설계원칙
        - 객체지향 설계원칙이 동일하게 적용해야함. 즉, 각 계층은 응집도가 높으며, 계층간에는 결합도가 낮아야한다!
        - 서비스 계층에 ResultSet과 같은 데이터엑세스계층 내부에서 해결해야할 클래스가 보여서는 안된다! 이러면 계층간 결합도가 높아진다!(JDBC라는 특정 데이터 엑세스 계층에 종속되는 서비스 계층의 코드가 됨..)
        - 계층의 경계를 넘어갈때는 반드시 특정 계층에 종속되지않는 오브젝트 형태가 필요!
        - 계층사이의 호출은 인터페이스!
          - 인터페이스를 사용하게한다는건 각 계층의 경계를 넘어서 들어오는 요청을 명확히 정의하겠다는것!
          - 한 계층 내부에서만 사용되도록 만든 빈을 다른 계층에서 직접 DI해서 사용하면안된다!
        - 엔터프라이즈 애플리케이션에 존재하는 정보를 어떻게 다룰것인지에 따라 두가지가 존재
          - 정보를 단순히 데이터로 다루는경우
            - 계층사이에 결합도가 높고, 각 계층의 응집도는 낮음. 
            - 화면을 중심으로 하는 업무 트랜잭션 단위로 코드가 모이기때문에 처음엔 개발하기 쉬우나, 중복많고 객체지향사용 어려움(변화에 취약)
          - 정보를 오브젝트로 다루는 경우
            - 도메인 모델을 반영하는 오브젝트 구조를 만들어두고, 그것을 각 계층사이에서 정보를 전송하는데 사용하는것
            - 애플리케이션 전 계층에서 동일한 의미를 가짐. 그래서 전 계층에서 일관된 구조를 유지한 채로 사용가능.
            - ***도메인 오브젝트를 사용하는 아키텍처는 ORM과 같은 데이터 엑세스 기술을 사용하는걸 권장..***
            - 비지니스 로직도 담을수있음
              - ***특정 도메인 오브젝트에 종속되는*** 비지니스 로직을 도메인오브젝트에 넣음
              - "풍성한 도메인 오브젝트방식"이라고도함
              - 객체지향적 특성을 살리고, 응집도가 매우 높아짐!
              - 이에 한걸음 더 나아간것이 아예 도메인오브젝트들이 서비스 계층과 데이터 액세스 계층사이에 존재하게하여 독립적인 계층으로 두는것(도메인계층)
                - 도메인에 종속되는 비지니스 로직의 처리는 도메인 계층의 오브젝트 안에서 진행(서비스 계층의 도움은 필요없다!)
                - 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반계층의 기능을 직접 활용. 이를 위해 AspectJ AOP를 사용해야함
                  - 도메인 오브젝트를 만드는것은 스프링컨테이너에 등록하는것이 아니라, 요청에 따라 임시적으로 new 키워드를 통해 잠시 만들었다가 소멸되는데, 이런 상황에서 데이터 엑세스를 사용하기위해서는 어쨌든 DI가 필요하고, 이를 위해서 스프링 AOP가 아닌, AspectJ AOP가 필요하다
                - *여기서 서비스계층이 필요없는것은 아님! 여러 도메인 오브젝트들의 기능을 조합해서 복잡한 작업을 해야하는 경우도 있고, 트랜잭션같은 기반서비스 이용이 필요한 작업을 위해서는 서비스 계층이 필요!
                - 매우 복잡하고 변경이 잦은 도메인에는 매우좋은 아키텍처! 복잡한 도메인의 구조와 로직을 최대한 도메인 계층의 오브젝트에 반영하고 도메인 모델과 설계에 변경이 발생했을때 도메인 계층의 오브젝트도 빠르게 대응 가능! 또한 응집도가 매우 높아서 단위테스트하기 매우 수월
      
  - HTTP 세션은 서블릿 컨테이너가 제공해줌

