모던자바인액션
- Part 1 - 기초
  - 1장 - 자바 8,9,10,11 : 무슨일이 일어나고있는가?
    - 멀티 코어에 따른 더욱 빠른 데이터 처리가 가능하여졌는데, 자바는 코어 하나만을 기존에 사용하였다.. 이에 따라 멀티코어 이상을 잘 활용할수있도록 병렬처리가 필요해졌고, 이에 대한 대응을 위해 자바 8이상부터 대폭 개선됨(+ 간결함)
    - Java 8에서 제공하는 새로운기술
      - 스트림 API
        - DB의 질의 언어처럼 고수준의 언어로 표현하면, 스트림 라이브러리가 최적의 저수준 실행방법을 선택하여 값을 리턴해준다(forkAndJoin 활용하여 병렬연산같은..)
          - 또한 스트림 파이프라인을 이용해서 입력부분을 여러 CPU 코어에 쉽게 할당할수있다는 부가적인 이득도있음! 즉, 복잡한 병렬작업을 직접처리하지않아도된다!
        - 스트림
          - 한번에 한개씩 만들어지는 연속적인 데이터 항목들의 모임
        - 스트림 메서드로 전달하기위해서는 안전하게 실행할수 잇는 메서드를 만들어야하는데, 이러한 함수를 순수(pure)함수, 부작용없는(side-effect-free) 함수, 상태없는(stateless)함수라 부른다
        - 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제(루프를 이용하여 각 요소를 반복하면서 작업을 수행 - 외부반복), 멀티코어 활용의 어려움을 해결
          - ***컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면, 스트림은 데이터에 어떤 계산을 할것인지 묘사하는것에 중점을 둔다!***
        - 필터링, 추출, 그룹핑, 병렬화!
      - 메서드에 코드를 전달하는 기법
        - 동작파라미터화
          - 동작(행위)을 넘겨줄수있도록 하는것!
          - 메서드를 값처럼 전달가능!(이급시민 -> 일급시민으로 격상시킴)
            - 메서드참조
            - 람다
            - 메서드참조 vs 람다
              - 좀더 의미를 명확하게 할수있는것은 메서드참조!
              - 심플하게 전달해줄수잇는것은 람다표현식
              - 코드의 명확성이 항상 중요하기때문에, 간단한거면 람다표현식을, 로직이 복잡해지면 메서드참조를 사용하자!
        
      - 인터페이스의 디폴트 메서드
        - 인터페이스에 무언가 변경이 필요하면, 기존 해당 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야했는데, 기존 구현을 고치지않고도 인터페이스를 바꿀수 있도록 해준것이 인터페이스의 디폴트메서드
         
  - 2장 - 동작 파라미터화 코드 전달하기
    - 자주 바뀌는 요구사항에 효과적으로 대응 하기위함!
    - 동작 파라미터화란 어떻게 실행할 것인지 결정하지않은 코드블럭을 의미.. 실행은 나중에!
      - 스프링에서 사용하는 템플릿/콜백 패턴에서 콜백과 매우 유사함.. 콜백은 템플릿내부에서 실행될것을 목적으로 메서드에 전달해주는 오브젝트인데, 결국 행동을 정의해서 전달해주는것이니 동작파라미터화된것으로 볼수도 있지않을까싶음
    - 런타임에 세부 전략을 넘겨주어 실행되기때문에, 적절한 전략을 선택하는 전략패턴과 매우 긴밀하게 연결됨
    - 동작 파라미터화는 아래의 모습으로 구현가능 (아래로 내려갈수록 간결..)
      - 클래스( new DefinedClazz() ) => 계속해서 클래스 정의해줘야함.. 
      - 익명클래스( new Clazz(){...} ) => new 클래스이름, 함수이름 반복..
      - 람다 (+메서드 참조) ( ()->{} )
  - 3장 - 람다 표현식
    - 람다 : 익명함수!
    - 자질구레한 코드해결을 위해서 도입됨.. 뭔가 새로운 기술적인 기능을 제시해주는것은아님!
    - 함수형 인터페이스에서 유용하게 사용할수잇음
      - 함수형인터페이스
        - 하나의 추상메서드로 구성되어있는 인터페이스!(디폴트 메서드는 여러개 있어도 상관없음)
        - @FunctionalInterface
          - 함수형 인터페이스임을 알려주는것!
          - 그냥 컴파일시에 해당 어노테이션을 사용했음에도, 함수형 인터페이스가 제대로 정의되어있지않으면(ex. 추상메서드 두개..) 에러알려주는것.. 이거 없다고 함수형 인터페이스가 아닌것은 아님!
        - 자바 8에는 여러 함수형 인터페이스가 정의되어있음
          - Consumer
          - Supplier
          - Predicate
          - Function
          - BiFunction
          - UnaryOperator
          - *AutoBoxing 피할수있도록 IntPredicate, LongBinaryOperator, IntFunction.. 등의 기본형으로 셋팅된 함수형 인터페이스를 제공해줌
            - IntPredicate와 Predicate\<Integer\>는 사용할때는 차이가 전혀 없지만, 후자와같은경우 박싱(int -> Integer)이 필요하고, 이 박싱은 힙에 저장되고 메모리를 더 소비하게 된다.. 
        - 자바에서 제공하는 함수형 인터페이스는 checked예외를 던지지못함! 굳이 사용해야한다면 따로 함수형인터페이스를 따로 만들던지, 구현부에서 try~catch로 감싸야함
        - 언제 사용하는것이 좋을까?
          - 전반적으로 비슷하나, 특정부분에서 차이가 있다면 해당부분에 파라미터와 리턴값을ㅇ 잘 맞추어서 이를 함수형 인터페이스로 만들고, 이에 대한 전략을 전달하도록!
    - 람다는 타입을 제공해주지않아도, 알아서 타입추론을 진행한다
      1. 람다를 사용한 메서드의 선언을 확인
      2. 선언된것을 기반으로 함수형 인터페이스에 타입을 추론하고 이를 기대함(여기서 함수형 인터페이스의 제네릭이라면 타입을 구체화함..)
      3. 기대한 함수형 인터페이스의 메서드에 어떤 타입이 들어오고 리턴값은 무엇인지를 확인
      4. 메서드에 실제 전달된 값이 이와 같은지 확인하여 컴파일
    - 람다 표현식 앞에 "()" 캐스트 연산자를 넣을수있는데, 이는 어떤 메소드 시그니처가 사용되어야하는지를 명시적으로 구분해주는 역할을 한다
      - 예를들어, 인수없고 리턴값 void인 함수형인터페이스는 여러개가 될수있기때문에 어떤놈인지 알려주는것!
      - 캐스트에 인터섹션타입(Intersection Type)이란걸 사용할수도있는데, 이에 대한 설명은 "toby_reactive_stream 유투브 강의정리.md" 에서 확인할것
    - 자유변수를 사용할때는, 람다 캡처링을 이용해서 사용가능
      - 자유변수란 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수!
      - 자유변수중에서 힙에 올라가있는 인스턴스변수나 클래스 메모리에 올라가 있는 static변수의 경우는 람다 캡처링에 별 문제가없음.. 
      - 외부 지역변수를 가져올때가 주의해야함
        - 이 외부지역변수는 final로 선언되어있어야하거나, final로 선언된 변수와 똑같이 사용되어야함!(final 없어도 외부에서 해당 변수에 변동을 주면안됨)
          - 지역변수에대한 복사한 값을 람다에 넘겨주는데, 해당 람다가 이후에 다른 스레드에서 실행되엇을때, 어떤 시점에서 실행될지 모르는데, 그때에 변경가능한 자유지역변수를 사용한다면, 스레드 실행시 정확히 어떤 값인지 알수가없다.. 그렇기때문에, final과 같이 해당 변수에 변경이 일어나면안되도록 한것! (Runnable을 구현하는 람다를 생각하면 쉽게 이해할수있음.. 새로운 스레드 만들어졌는데, 만약 변경가능한 지역변수를 복사한다면 항상 동일한 값이 넘어온다는것을 보장할수없다!)
          - 그리고 복사한 값을 쓰는 또 다른 이유는.. 만약 스택에 있는 외부지역변수가 해당 스레드가 종료되어 사라진다면..? 나중에 람다를 실행시키는 또 다른 스레드는 어떻게할것이냐..? 그래서 값에 대한 복사가 필요함.. 그리고 이에 따라 파라미터에 변하는 값이아닌 고정된 값이 넘어온다는 것으로 안전성을 확증할수있음 
        - 람다식에서 외부 지역 변수를 이용할 경우 final 혹은 effectively final 이어야 하는 이유는 지역 변수가 스택에 저장되기 때문에 람다식에서 값을 바로 참조하는 것에 제약이 있어 복사된 값을 이용하게 되는데, 이때 멀티 쓰레드 환경에서 복사 될/복사된 값이 변경 가능 할 경우 이로 인한 동시성 이슈를 대응할 수 없기 때문이다.
        - [설명굿](https://vagabond95.me/posts/lambda-with-final/)
    - 메서드 참조
      - 특정 메서드만을 호출하는 람다의 축약형
      - 명시적으로 메서드명을 참조함으로써 가독성을 높일수 있음
      - 만드는방법
        - 정적 메서드 참조
          - ex. Integer::parseInt
        - 다양한 형식의 인스턴스 메서드 참조
          - ex. String::length, String::compareToIgnoreCase
        - 기존 객체의 인스턴스 메서드 참조
          - ex. this::methodName
          
      |람다|메서드참조|
      |--|--|
      |(args) -> ClassName.staticMethod(args)|ClassName::staticMethod|
      |(arg0, rest) -> arg0.instanceMethod(rest)|ClassName::instanceMethod (여기서 ClassName은 arg0의 타입)|
      |(args) -> expr.instanceMethod(args)|expr::instanceMethod|
    - 생성자 참조
      - ClassName::new 와 같이 new 키워드를 사용해서 생성자의 참조를 만들수있음
      - 생성자중에서 파라미터가 있는놈인지 구분하는것은 함수형인터페이스를 보고 유추가능
        - ex. 
          ```java
            Supplier<Apple> c1=Apple::new; //new Apple()
            Apple a1=c1.get();

            Function<Integer,Apple> c2=Apple:new; //new Apple(Integer) Function에서 받아오는 인수(Integer)를 통해서 파라미터를 지닌 생성자인지 추론가능 
            Apple a2=c2.get();

          ```
    - java가 제공해주는 함수형 인터페이스중에 람다표현식을 조합할수있는 유틸리티 메서드를 제공해주는게 있음!
      - 이 유틸리티 메서드는 디폴트메서드로 정의되어있기때문에 함수형 인터페이스 원칙에 위배되지않는다
      - Comparator 조합
        ```java
          inventory.sort(Comparator.comparing(Apple::getWeight).reversed()); //reversed()는 디폴트메서드,, 무게를 기준으로 내림차순 정렬
          inventory.sort(Comparator.comparing(Apple::getWeight).reversed().thenComparing(Apple::getCountry)); //thenComparing은 디폴트메서드,, 위의 결과에서 두 사과의 무게가 같으면 국가별로 정렬
        ```
      - Predicate 조합
        ```java
          Predicate<Apple> redAndHeavyAppleOrGreen=
            redApple.and(apple -> apple.getWeight()>150)      // 빨간색이면서 150 보다 크고
                    .or(apple -> GREEN.equals(a.getColor())); // 또는 그냥 녹색사과 (redApple에서 녹색사과있음 이를 리턴해줌)
                    
        ```
        - 주의 : A or B and C 는 (a||b) && c 와 같음
      - Function 조합
        - andThen
          - 먼저 적용한 결과를 다른 함수의 입력으로 전달하는 함수를 반환
          - Function\<A,B\>.andThen(Fucntion\<B,C\>)
            - 앞의 Function 결과를 뒤에 Function의 파라미터로 넘겨줌.. 결과는 C타입
        - compose
          - 인수로 주어진 함수를 먼저 실행한 다음에 그 결과를 외부함수의 인수로 제공 
          - Function\<B,C\>.andThen(Fucntion\<A,B\>)
            - 뒤의 Function의 결과를 앞의 Function의 파라미터로 넘겨줌 결과는 C 타입
  - Part1 기타 팁
    - 비슷한 코드가 반복적으로 보이면 추상화해라!
    - 공통으로 사용되는것은 최대한빼라!!
      - System.out.println이 공통으로 사용된다면, syso은 빼고, syso에서 찍을 String을 리턴받도록해라!
    - 여러 타입에서 동일한 로직을 사용한다면, Object가 아닌 제네릭을 사용하여, 세련된 코드와 더불어 타입에 대한 안정성도 보장받도록하자!
      ```java
        //List<?> 를 filter하는 로직
        public static <T> List<T> filter(List<T> list, Predicate<T> p){
          List<T> result=new ArrayList<>;
          for(T t:list){
            if(p.test(t)){
              result.add(t);
            }
          }

          return result;
        }

      ```
    - ExecuterService를 이용하면 테스크를 스레드 풀로 보내고, 결과를 Future로 저장할수있다!! (기존 멀티스레드 사용할때, 결과를 받지 못하는점을 해결)
    - 함수형 프로그래밍은 의미전달에 탁월!
    
      ```java
        List<Apple> inventory ..;

        inventory.sort(comparing(Apple::getWeight));
        //Apple을 weight으로 비교해서 inventory를 sort하라!

      ```   
    - 용어정리
      - 함수형 프로그래밍 : 
      - 람다 
        - 익명함수 + 메서드를 인수로 전달가능(메서드참조)
        - 익명 클래스와 유사.. 
      - 함수 : 특정클래스에 종속x. 정적메서드와 같은 의미로 사용
      - 메서드 : 특정 클래스에 종속

      - 익명함수 : 
      - 메서드참조 
      - 익명클래스 : 
      - 리엑티브 프로그래밍 : 
      - 리엑티브 스트림즈 : 
      - https://mangkyu.tistory.com/111
      - https://dinfree.com/lecture/language/112_java_9.html
      - 메소드와 함수 (Method and Function)의 차이점
        - 함수가 메소드를 아우르는 포괄적인 용어이다.
        - 함수는 객체로부터 독립적이며, 메소드는 객체에 종속적이다.
        - 메소드는 거의 모든 면에서 함수와 동일하지만, 아래의 2가지 포인트에서 다른 점이 있다.
          - 메소드는 호출된 객체에 암시적으로 전달된다.
          - 메소드는 클래스 안에 있는 data를 조작할 수 있다.
        - 기본적으로 두 용어의 뜻은 동일하나 '객체(클래스)로부터 독립적인가 아닌가'가 함수와 메소드를 나누는 기준이다.
      - 함수 디스크립터
        - 함수형 인터페이스의 추상 메서드 시그니처
        ~~- 람다 표현식의 시그니처를 서술하는 메서드 (딱 와닿진 않는듯..)~~
          - 대략 람다가 사용할 추상메서드가 어떤 모양으로 되어있는지 설명하는거라고 생각하면될듯..?
        - ex) 
          - () -> void
            - 인수없고 리턴값도 없는 시그니처
          - (Apple, Apple) -> int
            - 두개의 Apple 인수를 받고, 리턴타입이 int인 시그니처


```java
    public static <T, U extends Comparable<? super U>> Comparator<T> comparing(  //U는 Comparable을 상속받는놈.. Comparable에 들어가는 제네릭 타입은 U의 슈퍼타입가능
            Function<? super T, ? extends U> keyExtractor)
    {
        Objects.requireNonNull(keyExtractor);
        return (Comparator<T> & Serializable)
            (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));   //(c1,c2) -> U타입.compareTo(U타입).. 즉 Function에서 return해주는 타입을 가지고 비교해라..
    }

```