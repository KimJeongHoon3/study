모던자바인액션
- Part 1 - 기초
  - 1장 - 자바 8,9,10,11 : 무슨일이 일어나고있는가?
    - 멀티 코어에 따른 더욱 빠른 데이터 처리가 가능하여졌는데, 자바는 코어 하나만을 기존에 사용하였다.. 이에 따라 멀티코어 이상을 잘 활용할수있도록 병렬처리가 필요해졌고, 이에 대한 대응을 위해 자바 8이상부터 대폭 개선됨(+ 간결함)
    - Java 8에서 제공하는 새로운기술
      - 스트림 API
        - DB의 질의 언어처럼 고수준의 언어로 표현하면, 스트림 라이브러리가 최적의 저수준 실행방법을 선택하여 값을 리턴해준다(forkAndJoin 활용하여 병렬연산같은..)
          - 또한 스트림 파이프라인을 이용해서 입력부분을 여러 CPU 코어에 쉽게 할당할수있다는 부가적인 이득도있음! 즉, 복잡한 병렬작업을 직접처리하지않아도된다!
        - 스트림
          - 한번에 한개씩 만들어지는 연속적인 데이터 항목들의 모임
        - 스트림 메서드로 전달하기위해서는 안전하게 실행할수 잇는 메서드를 만들어야하는데, 이러한 함수를 순수(pure)함수, 부작용없는(side-effect-free) 함수, 상태없는(stateless)함수라 부른다
        - 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제(루프를 이용하여 각 요소를 반복하면서 작업을 수행 - 외부반복), 멀티코어 활용의 어려움을 해결
          - ***컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면, 스트림은 데이터에 어떤 계산을 할것인지 묘사하는것에 중점을 둔다!***
        - 필터링, 추출, 그룹핑, 병렬화!
      - 메서드에 코드를 전달하는 기법
        - 동작파라미터화
          - 동작(행위)을 넘겨줄수있도록 하는것!
          - 메서드를 값처럼 전달가능!(이급시민 -> 일급시민으로 격상시킴)
            - 메서드참조
            - 람다
            - 메서드참조 vs 람다
              - 좀더 의미를 명확하게 할수있는것은 메서드참조!
              - 심플하게 전달해줄수잇는것은 람다표현식
              - 코드의 명확성이 항상 중요하기때문에, 간단한거면 람다표현식을, 로직이 복잡해지면 메서드참조를 사용하자!
        
      - 인터페이스의 디폴트 메서드
        - 인터페이스에 무언가 변경이 필요하면, 기존 해당 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야했는데, 기존 구현을 고치지않고도 인터페이스를 바꿀수 있도록 해준것이 인터페이스의 디폴트메서드
         
  - 2장 - 동작 파라미터화 코드 전달하기
    - 자주 바뀌는 요구사항에 효과적으로 대응 하기위함!
    - 동작 파라미터화란 어떻게 실행할 것인지 결정하지않은 코드블럭을 의미.. 실행은 나중에!
      - 스프링에서 사용하는 템플릿/콜백 패턴에서 콜백과 매우 유사함.. 콜백은 템플릿내부에서 실행될것을 목적으로 메서드에 전달해주는 오브젝트인데, 결국 행동을 정의해서 전달해주는것이니 동작파라미터화된것으로 볼수도 있지않을까싶음
    - 런타임에 세부 전략을 넘겨주어 실행되기때문에, 적절한 전략을 선택하는 전략패턴과 매우 긴밀하게 연결됨
    - 동작 파라미터화는 아래의 모습으로 구현가능 (아래로 내려갈수록 간결..)
      - 클래스( new DefinedClazz() ) => 계속해서 클래스 정의해줘야함.. 
      - 익명클래스( new Clazz(){...} ) => new 클래스이름, 함수이름 반복..
      - 람다 (+메서드 참조) ( ()->{} )
  - 3장 - 람다 표현식
    - 람다 : 익명함수!
    - 자질구레한 코드해결을 위해서 도입됨.. 뭔가 새로운 기술적인 기능을 제시해주는것은아님!
    - 함수형 인터페이스에서 유용하게 사용할수잇음
      - 함수형인터페이스
        - 하나의 추상메서드로 구성되어있는 인터페이스!(디폴트 메서드는 여러개 있어도 상관없음)
        - @FunctionalInterface
          - 함수형 인터페이스임을 알려주는것!
          - 그냥 컴파일시에 해당 어노테이션을 사용했음에도, 함수형 인터페이스가 제대로 정의되어있지않으면(ex. 추상메서드 두개..) 에러알려주는것.. 이거 없다고 함수형 인터페이스가 아닌것은 아님!
        - 자바 8에는 여러 함수형 인터페이스가 정의되어있음
          - Consumer
          - Supplier
          - Predicate
          - Function
          - BiFunction
          - UnaryOperator
          - *AutoBoxing 피할수있도록 IntPredicate, LongBinaryOperator, IntFunction.. 등의 기본형으로 셋팅된 함수형 인터페이스를 제공해줌
            - IntPredicate와 Predicate\<Integer\>는 사용할때는 차이가 전혀 없지만, 후자와같은경우 박싱(int -> Integer)이 필요하고, 이 박싱은 힙에 저장되고 메모리를 더 소비하게 된다.. 
        - 자바에서 제공하는 함수형 인터페이스는 checked예외를 던지지못함! 굳이 사용해야한다면 따로 함수형인터페이스를 따로 만들던지, 구현부에서 try~catch로 감싸야함
        - 언제 사용하는것이 좋을까?
          - 전반적으로 비슷하나, 특정부분에서 차이가 있다면 해당부분에 파라미터와 리턴값을ㅇ 잘 맞추어서 이를 함수형 인터페이스로 만들고, 이에 대한 전략을 전달하도록!
    - 람다는 타입을 제공해주지않아도, 알아서 타입추론을 진행한다
      1. 람다를 사용한 메서드의 선언을 확인
      2. 선언된것을 기반으로 함수형 인터페이스에 타입을 추론하고 이를 기대함(여기서 함수형 인터페이스의 제네릭이라면 타입을 구체화함..)
      3. 기대한 함수형 인터페이스의 메서드에 어떤 타입이 들어오고 리턴값은 무엇인지를 확인
      4. 메서드에 실제 전달된 값이 이와 같은지 확인하여 컴파일
    - 람다 표현식 앞에 "()" 캐스트 연산자를 넣을수있는데, 이는 어떤 메소드 시그니처가 사용되어야하는지를 명시적으로 구분해주는 역할을 한다
      - 예를들어, 인수없고 리턴값 void인 함수형인터페이스는 여러개가 될수있기때문에 어떤놈인지 알려주는것!
      - 캐스트에 인터섹션타입(Intersection Type)이란걸 사용할수도있는데, 이에 대한 설명은 "toby_reactive_stream 유투브 강의정리.md" 에서 확인할것
    - 자유변수를 사용할때는, 람다 캡처링을 이용해서 사용가능
      - 자유변수란 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수!
      - 자유변수중에서 힙에 올라가있는 인스턴스변수나 클래스 메모리에 올라가 있는 static변수의 경우는 람다 캡처링에 별 문제가없음.. 
      - 외부 지역변수를 가져올때가 주의해야함
        - 이 외부지역변수는 final로 선언되어있어야하거나, final로 선언된 변수와 똑같이 사용되어야함!(final 없어도 외부에서 해당 변수에 변동을 주면안됨)
          - 지역변수에대한 복사한 값을 람다에 넘겨주는데, 해당 람다가 이후에 다른 스레드에서 실행되엇을때, 어떤 시점에서 실행될지 모르는데, 그때에 변경가능한 자유지역변수를 사용한다면, 스레드 실행시 정확히 어떤 값인지 알수가없다.. 그렇기때문에, final과 같이 해당 변수에 변경이 일어나면안되도록 한것! (Runnable을 구현하는 람다를 생각하면 쉽게 이해할수있음.. 새로운 스레드 만들어졌는데, 만약 변경가능한 지역변수를 복사한다면 항상 동일한 값이 넘어온다는것을 보장할수없다!)
          - 그리고 복사한 값을 쓰는 또 다른 이유는.. 만약 스택에 있는 외부지역변수가 해당 스레드가 종료되어 사라진다면..? 나중에 람다를 실행시키는 또 다른 스레드는 어떻게할것이냐..? 그래서 값에 대한 복사가 필요함.. 그리고 이에 따라 파라미터에 변하는 값이아닌 고정된 값이 넘어온다는 것으로 안전성을 확증할수있음 
        - 람다식에서 외부 지역 변수를 이용할 경우 final 혹은 effectively final 이어야 하는 이유는 지역 변수가 스택에 저장되기 때문에 람다식에서 값을 바로 참조하는 것에 제약이 있어 복사된 값을 이용하게 되는데, 이때 멀티 쓰레드 환경에서 복사 될/복사된 값이 변경 가능 할 경우 이로 인한 동시성 이슈를 대응할 수 없기 때문이다.
        - [설명굿](https://vagabond95.me/posts/lambda-with-final/)
    - 메서드 참조
      - 특정 메서드만을 호출하는 람다의 축약형
      - 명시적으로 메서드명을 참조함으로써 가독성을 높일수 있음
      - 만드는방법
        - 정적 메서드 참조
          - ex. Integer::parseInt
        - 다양한 형식의 인스턴스 메서드 참조
          - ex. String::length, String::compareToIgnoreCase
        - 기존 객체의 인스턴스 메서드 참조
          - ex. this::methodName
          
      |람다|메서드참조|
      |--|--|
      |(args) -> ClassName.staticMethod(args)|ClassName::staticMethod|
      |(arg0, rest) -> arg0.instanceMethod(rest)|ClassName::instanceMethod (여기서 ClassName은 arg0의 타입)|
      |(args) -> expr.instanceMethod(args)|expr::instanceMethod|
    - 생성자 참조
      - ClassName::new 와 같이 new 키워드를 사용해서 생성자의 참조를 만들수있음
      - 생성자중에서 파라미터가 있는놈인지 구분하는것은 함수형인터페이스를 보고 유추가능
        - ex. 
          ```java
            Supplier<Apple> c1=Apple::new; //new Apple()
            Apple a1=c1.get();

            Function<Integer,Apple> c2=Apple:new; //new Apple(Integer) Function에서 받아오는 인수(Integer)를 통해서 파라미터를 지닌 생성자인지 추론가능 
            Apple a2=c2.get();

          ```
    - java가 제공해주는 함수형 인터페이스중에 람다표현식을 조합할수있는 유틸리티 메서드를 제공해주는게 있음!
      - 이 유틸리티 메서드는 디폴트메서드로 정의되어있기때문에 함수형 인터페이스 원칙에 위배되지않는다
      - Comparator 조합
        ```java
          inventory.sort(Comparator.comparing(Apple::getWeight).reversed()); //reversed()는 디폴트메서드,, 무게를 기준으로 내림차순 정렬
          inventory.sort(Comparator.comparing(Apple::getWeight).reversed().thenComparing(Apple::getCountry)); //thenComparing은 디폴트메서드,, 위의 결과에서 두 사과의 무게가 같으면 국가별로 정렬
        ```
      - Predicate 조합
        ```java
          Predicate<Apple> redAndHeavyAppleOrGreen=
            redApple.and(apple -> apple.getWeight()>150)      // 빨간색이면서 150 보다 크고
                    .or(apple -> GREEN.equals(a.getColor())); // 또는 그냥 녹색사과 (redApple에서 녹색사과있음 이를 리턴해줌)
                    
        ```
        - 주의 : A or B and C 는 (a||b) && c 와 같음
      - Function 조합
        - andThen
          - 먼저 적용한 결과를 다른 함수의 입력으로 전달하는 함수를 반환
          - Function\<A,B\>.andThen(Fucntion\<B,C\>)
            - 앞의 Function 결과를 뒤에 Function의 파라미터로 넘겨줌.. 결과는 C타입
        - compose
          - 인수로 주어진 함수를 먼저 실행한 다음에 그 결과를 외부함수의 인수로 제공 
          - Function\<B,C\>.andThen(Fucntion\<A,B\>)
            - 뒤의 Function의 결과를 앞의 Function의 파라미터로 넘겨줌 결과는 C 타입
  - Part1 기타 팁
    - 비슷한 코드가 반복적으로 보이면 추상화해라!
    - 공통으로 사용되는것은 최대한빼라!!
      - System.out.println이 공통으로 사용된다면, syso은 빼고, syso에서 찍을 String을 리턴받도록해라!
    - 여러 타입에서 동일한 로직을 사용한다면, Object가 아닌 제네릭을 사용하여, 세련된 코드와 더불어 타입에 대한 안정성도 보장받도록하자!
      ```java
        //List<?> 를 filter하는 로직
        public static <T> List<T> filter(List<T> list, Predicate<T> p){
          List<T> result=new ArrayList<>;
          for(T t:list){
            if(p.test(t)){
              result.add(t);
            }
          }

          return result;
        }

      ```
    - ExecuterService를 이용하면 테스크를 스레드 풀로 보내고, 결과를 Future로 저장할수있다!! (기존 멀티스레드 사용할때, 결과를 받지 못하는점을 해결)
    - 함수형 프로그래밍은 의미전달에 탁월!
    
      ```java
        List<Apple> inventory ..;

        inventory.sort(comparing(Apple::getWeight));
        //Apple을 weight으로 비교해서 inventory를 sort하라!

      ```   
    - 용어정리
      - 함수형 프로그래밍 : 
      - 람다 
        - 익명함수 + 메서드를 인수로 전달가능(메서드참조)
        - 익명 클래스와 유사.. 
      - 함수 : 특정클래스에 종속x. 정적메서드와 같은 의미로 사용
      - 메서드 : 특정 클래스에 종속

      - 익명함수 : 
      - 메서드참조 
      - 익명클래스 : 
      - 리엑티브 프로그래밍 : 
      - 리엑티브 스트림즈 : 
      - https://mangkyu.tistory.com/111
      - https://dinfree.com/lecture/language/112_java_9.html
      - 메소드와 함수 (Method and Function)의 차이점
        - 함수가 메소드를 아우르는 포괄적인 용어이다.
        - 함수는 객체로부터 독립적이며, 메소드는 객체에 종속적이다.
        - 메소드는 거의 모든 면에서 함수와 동일하지만, 아래의 2가지 포인트에서 다른 점이 있다.
          - 메소드는 호출된 객체에 암시적으로 전달된다.
          - 메소드는 클래스 안에 있는 data를 조작할 수 있다.
        - 기본적으로 두 용어의 뜻은 동일하나 '객체(클래스)로부터 독립적인가 아닌가'가 함수와 메소드를 나누는 기준이다.
      - 함수 디스크립터
        - 함수형 인터페이스의 추상 메서드 시그니처
        ~~- 람다 표현식의 시그니처를 서술하는 메서드 (딱 와닿진 않는듯..)~~
          - 대략 람다가 사용할 추상메서드가 어떤 모양으로 되어있는지 설명하는거라고 생각하면될듯..?
        - ex) 
          - () -> void
            - 인수없고 리턴값도 없는 시그니처
          - (Apple, Apple) -> int
            - 두개의 Apple 인수를 받고, 리턴타입이 int인 시그니처


```java
    public static <T, U extends Comparable<? super U>> Comparator<T> comparing(  //U는 Comparable을 상속받는놈.. Comparable에 들어가는 제네릭 타입은 U의 슈퍼타입가능
            Function<? super T, ? extends U> keyExtractor)
    {
        Objects.requireNonNull(keyExtractor);
        return (Comparator<T> & Serializable)
            (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));   //(c1,c2) -> U타입.compareTo(U타입).. 즉 Function에서 return해주는 타입을 가지고 비교해라..
    }

```

- Part 2 - 함수형 데이터 처리
  - 4장 스트림 소개
    - 스트림
      - 정의 : 데이터 처리 연산을 지원하도록 소스(ex. List)에서 추출된 연속된 요소(Sequnce of elements)
        - 연속된 요소 : 연속된 값 집합의 인터페이스를 제공하는것은 컬렉션과 동일하나, 컬렉션은 요소 저장 및 접근 연산이 주를 이루고, 스트림은 filter, map, sorted와 같이 표현 계산식이 주를 이룸
        - 소스 : 컬렉션, 배열, IO 자원 등의 데이터 제공 소스로부터 데이터를 소비.. 정렬된 컬렉션으로 스트림이 생성되면 정렬이 당연 그대로 유지됨
        - 데이터 처리 연산 : 연산은 순차적으로도 가능하고 병렬적으로도 가능! 
      - SQL 질의와 같이 명확하게 기대하는것이 무엇인지를 표현(선언형! 보이는곳에서 루프로 데이터처리를 하지않음)
        - *선언형 코드와 동작파라미터를 잘 활용하면 변하는 요구사항에 명시적이고 빠르게 대응할수있다
      - 병렬처리에 용이
      - 데이터처리 (스트림)파이프라인을 만들어서 여러 연산을 가독성있게, 명확하게 볼수있다
      - 반복자와 마찬가지로 해당 스트림은 한번 소비되면 끝이다! 스트림이 또 필요하면 다시 소스로부터 스트림을 생성해야한다! (I/O라면 소스를 반복사용할수없으므로 새로운 스트림만들수없음!)
      - 특징요약
        - 선언형 : 간결, 가독성 굿
        - 조립할수있음 : 유연성 굿
          - filter, map, flatmap 등과 같은 중간연산은 모두 Stream을 반환하고 그로인해서 파이프라인을 구성할수있음
        - 병렬화 : 성능 굿(쉽게 병렬화가능)
      - *스트림 vs 컬렉션
        - 공통점
          - 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공(자료구조에 순차적으로 접근할수있는 API 제공한다는말)
        - 차이점
          - 데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이
            - 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장해야함.. 즉, 컬렉션의 모든 요소는 컬렉션에 추가하기전에 계산되어야한다!(무언가를 미리 만들어놓고 더하거나 빼거나하니깐..)
            - 스트림은 이론적으로 요청할때만 요소를 계산하는 고정된 자료구조! 사용자가 데이터를 요청할때만 값을 계산하기때문에 게으르게 만들어지는 컬렉션과 같음!
          - 반복문의 차이!
            - 컬렉션은 외부반복.. 명시적으로 컬렉션 항목을 하나씩 가져와서 처리한다(내가 직접 손대서 처리.. 병렬작업있으면 겁나 까다로움)
            - 스트림은 내부반복을 이용하여 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리!(내가 직접 손대지않는다)
      - 스트림 이용하기
        - 스트림 이용과정
          - 질의를 수행할 (컬렉션 같은) ***데이터 소스***
          - 스트림 파이프라인을 구성할 ***중간연산 연결*** (항상 스트림을 반환함)
          - 스트림 파이프라인을 실행하고 결과를 만들 ***최종연산*** (스트림이 아닌 값을 반환함)
          - *스트림 파이프라인은 빌더패턴과 비슷.. build가 최종연산(ex. collect, foreach..)과 같음
  - 5장 스트림 활용
    - 필터링
      - filter
      - distinct
        - hashCode, eqauls로 같은지 확인..
    - 스트림 슬라이싱 (java 9)
      - 스트림의 요소를 선택하거나 스킵하도록 해줌
      - predicate를 이용한 슬라이싱
        - Loop를 다 돌지않고 특정 조건에 부합하지않다면 바로 끝냄 (정렬이 되어있어야 쓸수있겟지?)
        - takeWhile(Predicate)
          - 처음으로 거짓 마주하게되면, 그 지점에서 작업을 중단하고 그놈전까지의 요소를 반환
        - dropWhile(Predicate)
          - 처음으로 거짓 마주하게되면, 그 지점에서 작업을 중단하고 그놈부터 시작하여 남은 모든 요소를 반환
      - 스트림 축소
        - limit(n)
          - 해당 숫자만큼 차면 바로 반환
      - 요소 건너뛰기
        - skip(n)
    - 매핑
      - map
        - 함수를 적용한 결과가 새로운 요소로 매핑(변환 된다고 생각하면됨)
      - flatmap
        - 스트림을 리턴하나, 해당 스트림은 결국에 합쳐져서(평면화되어) 하나의 스트림으로 반환된다
        - (같은말)flatMap 메서드는 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는기능!
    - 검색과 매칭
      - 특정속성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리 
      - anyMatch, allMatch, noneMatch 모두 쇼트서킷 기법을 사용
        - *쇼트서킷 : 전체 스트림을 처리하지않더라도 결과를 반환하는것! 예를들어, and연산에서는 연산중에 하나라도 거짓이라면 다 거짓이기때문에 뒤의 계산을 굳이하지않는다.. 이것을 쇼트서킷이라함(무한한 요소를 가진 스트림을 유한한 크기로 줄일수있는 유용한 연산)
      - findAny
        - 이 또한 쇼트서킷을 이용하여 결과를 찾는 즉시 실행종료를 하게되는데, 반환값이 Optional\<T\>이다.
          - 여기서 Optional은 값이 존재하지않을수도 있기떄문에 제공해주는것으로, 값이 존재하지않을때 어떻게 동작할것인지를 지정할수있다! 이를 통해 코드의 안전성을 높일수있음!
      - findFirst
        - 논리적인 아이템 순서가 정해져있을때, 첫번째 요소를 찾을수있다\
        - *findAny vs findFirst
          - 병렬실행에서는 첫번째 요소를 찾기어려움.. 반환 순서가 상관없다면 병렬스트림에서는 제약이 적은 findAny를 사용해야한다!
    - 리듀싱
      - 모든 스트림 요소를 처리해서 값으로 도출하는것(요소들을 더하거나 기타 연산을 하면서 줄여나가는것)
      - 요소의 합, 최대최소 등에 쓰임
        ```java
            int sum=numbers.stream().reduce(0,(a,b) ->  a+b); //합계 
            int sum=numbers.stream().reduce(0,Integer::sum); //합계.. 이렇게도 쓰임\

            Optional<Integer> sum=numbers.stream().reduce((a,b) ->  a+b); //합계 (초기값 없기때문에 빈값이 들어올수있으므로 Optional)

        ```
    - *스트림연산
      - 내부 상태없음
        - filter, map 과 같이 내부에 상태를 갖지않는연산(넣으면 넣을수있지만, 보통의 이야기..)
      - 내부 상태있음
        - 한정되어있음
          - reduce, sum, max...
        - 한정되어있지않음
          - distinct, sorted...
    - 스트림 연산 문법 간략 정리
      - ![](./operation.jpeg)
    - 숫자형 스트림
      - 스트림 API 숫자 스트림을 효율적으로 처리할 수 있도록 ***기본형 특화스트림***을 제공
      - 이를 사용함으로써 박싱 비용을 피할수있을뿐아니라, sum,max등 숫자관련 리듀싱연산 수행 메서드도 제공
      - boxed를 통해서 특화스트림을 일반스트림으로 변경할수도있음
        ```java
        IntStream intStream=menu.stream().mapToInt(Dish::getCalories);
        Stream<Integer> stream=intStream.boxed();
        ```
      - 종류
        - IntStream
        - DoubleStream
        - LongStream
      - 숫자범위도 만들수 있음
        ```java
        IntStream intStream=IntStream.rangeClosed(1,100); //1과 100 포함
        IntStream intStream=IntStream.range(1,100); //1과 100 포함x

        ```
    - 스트림 만들기
      - 값으로 만들기
        - Stream.of
        - Stream.empty(); //껍데기만드는것
      - null이 될수 있는 객체로 스트림 만들기 (java 9)
        - Stream.ofNullable
      - 배열로 스트림 만들기
        - Arrays.stream
          - 넘어오는 파라미터에 따라 숫자형스트림으로 반환할수도있음!
      - 파일로 스트림 만들기
        - Stream\<String\> stream=Files.Lines(파일경로);
      - 무한스트림(언바운드스트림)
        - 제한이 없이 계속 생성되기때문에 보통 limit과 같이 쓰임
        - iterate
        - generate
          - Supplier\<T\> 를 인수로 받아서 새로운 값을 생산
          - 병렬작업시 Supplier에는 상태값이 있으면 안전하지않다!!
    - 6장 스트림으로 데이터 수집
    - collect에 다양한 요소 누적 방식을 인수로 받아서 스트림을 최종결과로 도출하는 리듀싱연산을 수행할수 있음(Collector를 인수로받음.. Collector는 인터페이스이고 Collectors는 Collector의 구현체들을 모아놓은 클래스)
    - collect는 요소한개씩 가져와서 파라미터로 받은 동작을 수행하도록 해준다(리듀싱 연산)
      - collect로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할수있도록 해주는것이 컬렉터! 이 컬렉터를 통해 동작파라미터화가 가능!
    - Collectors(클래스) 에서 제공하는 메서드 기능
      - 스트림 요소를 하나의 값으로 리듀스하고 요약
        - 스트림에 있는 객체의 숫자 필드의 합계나 평균등을 반환하는 연산을 요약연산이라함
        - counting(), maxBy, minBy, summingInt, averagingInt, summarizingInt ...
          - summarizingInt 요놈은 count, sum, min, average, max 다나옴
        - joining을 통해서 문자열 연결도 가능
          - 구분자 넣을수있음
        - 위의 예처럼 특화되어있는것 말고 범용적으로 사용하기위해서는 reducing을 사용하면됨
          - 초기값, 변환함수, 두항목을 하나로 더하는 BinaryOperator 이렇게 3개의 인수를 가짐
          - 하나의 인수를 갖기도하는데, 스트림의 첫번째요소가 시작값이됨
          - *collect vs reduce <span style="color:yellow">좀 더 찾아볼것 p206</span>
            - collect 메서드 : 도출하려는 결과를 누적하는 컨테이너를 가지고 reducing
            - reduce 메서드 : 두 값을 하나로 도출하는 불변형 연산 
      - 요소 그룹화
        - 그룹화할 key를 넘겨주는함수를 분류함수 라고 함 (근데 여기서 함수는 정적메서드는 아님.. 클래스에 독립되어있지않음)
        - groupingBy에 두번째인수를 활용하여 그룹핑한 데이터에 추가적인 조작이 가능 
          - filtering
          - mapping
          - flatMapping
          - groupingBy
            - Map\<key1, Map\<key2, List\<Dish\>\>\> 이런 형식으로 나옴
          ```java
            groupingBy(Dish::getType
                        , filtering(d -> d.getCount()>5, toList())
                      )
            );
          ```
        - groupingBy(f) 는(하나의 인수만 갖는), 사실 groupingBy(f,toList()) 와 같다!
        - 컬렉터의 결과를 다른 형식에 적용가능
          - Collectors.collectingAndThen
            - 적용할 컬렉터와 변환함수를 인수로 받아 다른 컬렉터를 반환해줌.. Wrapper 역할!
      - 요소 분할
        - Prdicate를 분류함수로 사용
        - 맵의 키 형식은 Boolean으로, 최대 두개의 그룹을 가짐
        - 참, 거짓 두가지 요소의 스트림 리스트를 모두 유지하는것이 분할의 장점!(필터링하면 참인것들만 되므로..)
      - ![](collectors_static_factory_method1.jpeg)
      - ![](collectors_static_factory_method2.jpeg)
    - Collector 인터페이스
      - 리듀싱 연산을 어떻게 구현할지 제공하는 메서드 집합으로 구성
      - 이를 통해서 collect에 보내줄 리듀싱 적절하게 커스텀가능
      ```java
        public interface Collector<T,A,R> {
            Supplier<A> supplier(); // 인스턴스 만들어줌..
            BiConsumer<A,T> accumulator(); // 수집될 곳에 누적해주는곳
            Function<A,R> finisher(); // 최종결과를 반환해줌.. 누적자를 그대로 반환할거면 항등함수(나 자신을 반환)를 반환해주는 Function.identity() 사용하면됨
            BinaryOperator<A> combiner(); // 스트림의 서로 다른 서브파트를 병렬로 처리할때 누적자가 이 결과를 어떻게 처리할지 정의 (포크조인 프레임워크를 사용하여 병렬처리)
            Set<Characteristics> characteristics(); //병렬로 할때 어떠한 최적화를 선택할건지에 대한 힌트
        }

        // T는 수집될 스트림 항목의 제네릭 형식
        // A는 누적자, 즉 수집과정에서 중간 결과를 누적하는 객체의 형식
        // R은 수집 연산 결과 객체의 형식(항상 그런것은 아니지만 대개 컬렉션형식)

        /**
            스트림 병렬 리듀싱 수행과정
            1. 스트릠을 분할해야 하는지 정의하는 조건이 거짓으로 바뀌기 전까지 원래 스트림을 재귀적으로 분할(너무 작업의 크기가 작아지면 병렬 수행의 속도는 순차 수행의 속도보다 느려짐.. 프로세싱 코어의 갯수롤 되도록이면 초과하지말것!)
            2. 서브 스트림의 각 요소에 리듀싱 연산을 순차적으로 적용해서 서브스트림을 병렬로 처리
            3. 컬렉터의 combiner 메서드가 반환하는 함수로 모든 부분결과를 쌍으로 합침.. 모든 서브스트림의 결과가 합쳐지면 연산이 완료

        */ 
            
        /**
            Characteristics 메서드
            - UNORDERED : 리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향을 받지 않는다
            - CONCURRENT : 다중 스레드에서 accumulator 함수를 동시에 호출할 수 있으며 이 컬렉터는 스트림의 병렬 리듀싱을 수행할수 있음 UNORDERED를 명시하지않으면, 데이터 소스가 정렬되어있지 않은(like 집합) 놈들한테만 병렬 리듀싱을 수행
            - IDENTITY_FINISH : 누적자 객체를 최종 결과로 바로 사용
        
        */
        
      ```
      - ![collector 인터페이스 사용 flow](sequential_reducing_flow.jpeg)

  - 7장 병렬 데이터 처리와 성능
    - 병렬 스트림
      - 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림
      - 내부적으로 ForkJoinPool 사용(프로세서 수 와 동일한 스레드생성)
      - 병렬 스트림 효과적 사용하기
        - 순차스트림과 병렬스트림을 적절한 벤치마크로 직접 성능을 측정하여 비교하는것이좋음
          - *벤치마크 (컴퓨팅): 컴퓨터의 부품 등의 성능을 프로그램을 이용하여 비교, 평가하여 점수를 내는 결과 
        - 자동박싱과 언박싱은 성능을 크게 저하시킬수 있으니 특화스트림을 활용하자
        - findFirst와 같은 순서에 의존하는 연산보다는 findAny 를 병렬에서는 사용하자
        - 소량의 데이터에서는 병렬스트림이 도움되지 않을 수 있음
        - 스트림을 구성하는 자료구조가 적절한지 확인해야함
          - ArrayList를 LinkedList보다 효율적으로 분할 가능.. 
            - LinkedList는 모든 요소를 탐색해야하지만, ArrayList는 요소를 탐색하지않고도 리스트를 분할수있음
          - range 팩토리 메서드로 만든 기본형 스트림도 쉽게 분해가능
          |소스|분해성|
          |--|--|
          |ArrayList|훌륭함|
          |LinkedList|나쁨|
          |IntStream.range|훌륭함|
          |Stream.iterate|나쁨|
          |HashSet|훌륭함|
          |TreeSet|훌륭함|

        - 필터연산은 효과적인 스트림 병렬 처리가 어려움
        - 병합과정(ex. Collector의 combiner 메서드) 비용이 비싸지않도록!
    - 포크/조인 프레임워크
      - 병렬화 할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체결과를 만들도록 설계
      - 분할 정복 알고리즘 사용
      - 일반적으로 애플리케이션에서는 둘 이상의 ForkJoinPool을 사용하지않는다! 싱글톤으로 사용
      - 포크/조인 프레임워크를 제대로 사용하는 방법
        - join 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될떄까지 호출자를 블록시킨다.. 그렇기때문에 두 서브태스크가 모두 시작한 다음에 join을 호출할것!
        - 왼쪽과 오른쪽 작업 모두에 fork 메서드를 호출하는것이 아닌, 한쪽잡업에는 compute를 호출하는것이 효과적!
          - 두 서브태스크의 한 태스크에는 같은 스레드를 재사용 할 수 있으므로 풀에서 불필요한 태스크를 할당하는 오버헤드를 피할수있음(현재 스레드가 할수있는 작업을 다 마무리하는게 좋지.. 굳이 다시 새로운 스레드를 할당하는 작업할 필요가 없다는뜻)
        - 각 서브태스크의 실행 시간은 새로운 태스크를 포킹하는데 드는 시간보다 길어야 효율적!
      - ***작업훔치기*** 를 통해서 ForkJoinPool의 모든 스레드를 거의 공정하게 작업이 배정된다
        - 할일이 없어진 스레드는 유휴 상태로 바뀌는것이 아니라, 다른 스레드 큐의 꼬리에서 작업을 훔쳐온다(Deque라서 가능)
    - Spliterator 인터페이스 <span style="color:yellow">이 부분은 다시 공부해보자.. 어렵다..</span>
- Part3 - 스트림과 람다를 이용한 효과적 프로그래밍
  - 8장 컬렉션 API 개선
    - 리스트와 집합처리 
      - 새로운 컬렉션을 만드는것이 아니라, 기존 컬렉션을 변경한다!
      - 메서드종류
        - removeIf
          - 프레디케이트를 만족하는 요소를 제거..
          - List, Set 구현체 모두 사용가능
          - for-each 루프에서 ConcurrentModificationException 을 예방해줌..
            - 자세한예시는 "자바의정석_Collection.md" 에 정리해놨음
        - replaceAll
          - UnaryOperator 함수를 이용해 요소를 바꿈
          - List 구현체에서 사용
        - sort
          - 리스트를 정렬
          - List 구현체에서 사용
            - Set은 스트림 sorted사용하면될듯..
    - 맵 처리
      - Map인터페이스에 디폴트 메서드로 자주 사용되는 패턴을 만들어놓앗음
        - forEach
          - key, value 사용가능
        - 정렬
          - Value 기준 또는 Key 기준으로 정렬가능
          ```java
            Map<String,String> map=new HashMap<String,String>(){{put("Rapheal","Star Wars");put("Cristina","Matrix");put("Olivia","James Bond");}};
            map.entrySet().stream()
                    .sorted(Map.Entry.comparingByKey()) //key 기준으로 정렬
                    .forEachOrdered(System.out::println); // forEachOrdered는 병렬시 순서보장을 해준다.. 그러나 그렇게되면, 병렬의 이점을 누리지못한다..
          ```
        - getOrDefault
          - key가 존재하지않을때 반환할 default값 셋팅
        - 계산패턴
          - computeIfAbsent
            - 제공된 키에 해당하는 값이 없으면(또는 Null), 키를 이용해 새 값을 계산하고 맵에 추가
          - computeIfPresent
            - 제공된 키가 존재하면 새 값을 계산하고 맵에 추가
          - compute
            - 제공된 키로 새 값을 계산하고 맵에 추가
        - 삭제패턴
          - remove(key,value)
            - 특정 value가 있을때 해당 key를 제거하도록 가능
        - 교체 패턴
          - replaceAll
            - BiFunction을 적용한 결과로 각 항목의 ***값***을 교체
          - replace
        - 합침
          - putAll(Map)
            - 합치려고 하는 대상에 중복된 key가 있으면 합치려고 하는 대상의 값이 들어감
          - merge(key,value,BiFunction)
            - 중복되었을때 어떻게 처리할것인지 구체적으로 명시가능
            - value에 값을 지정하면, 해당 key값의 value에 대한 초기화를 수행하도록 가능하다(해당 key가 기존 map에 없을때)
              - 만약 중복되면 BiFunction 함수 타게되니깐 그에 맞는 중복처리해주면됨 
              - ex. moviesToCount.merge(movieName, 1L, (key, value) -> count + 1L); //movieToCount 맵에 movieName이라는 key가 처음들어오면 값을 1L로 셋팅하고, 중복이면 기존 count에 +1을 해라!
          ```java
            Map<String,String> map1=new HashMap<String,String>(){{put("Rapheal","Star Wars");put("Cristina","Matrix");put("Olivia","James Bond");}};
            Map<String,String> map2=new HashMap<String,String>(){{put("Kim","Star Wars");put("Cristina","Matrix2");put("Park","James Bond");}};
            map1.forEach((k,v) -> map2.merge(k,v,(movie1,movie2)->movie1+" & "+movie2)); // BiFucntion에서 return이 null이면 해당 key는 제거됨
                                                                                        // map1의 Cristina의 value가 null이라면, merge 되엇을때 Matrix2로 대치됨..("Matrix2 & null" 이렇게 반환안된다는거!)
            //map2.putAll(map1); // "Cristina" 라는 중복되는 key의 value는 Matrix 로 엎어쳐짐

            System.out.println(map2);
          ```
      - 개선된 ConcurrentHashMap
        - 리듀스할때, 병렬성 기준값(Threshold)에 따라 병렬처리 가능
          - Threshold가 1이면 병렬.. Long.MAX_VALUE 면 순차..
      - *JAVA8 의 HashMap 성능개선
        - 버킷이 너무 커질 경우 LinkedList로 저장되어있는 데이터를 트리로 변경함
          - key가 String, Number 클래스 같은 Comparable 형태여야만 트리가 지원
  - 9장 - 리팩터링, 테스팅, 디버깅
    - 익명클래스를 람다로 리팩터링해서 불필요한 코드 반복을 줄일수 있다
      - 주의해야할점
        - 익명클래스의 this와 람다내부의 this는 다른객체를 가리킨다
          - 익명클래스의 this는 익명클래스 자신을, 람다내부의 this는 람다를 호출하는 클래스를 가리킨다
          - 익명클래스, 람다 모두 외부의 변수를 사용할수있으나, 익명클래스에서는 외부변수와 같은 변수이름을 선언하여 사용할수잇는반면(외부 변수를 가림 - shadow variable), 람다는 외부 변수와 같은 이름의 변수를 내부적으로 선언해서 사용불가!
          - 익명클래스에서 람다표현식으로 바꿀때, 콘텍스트 오버로딩에 따른 모호함이 초래될수있음
            - 람다표현식을 사용할때 명시적으로 타입캐스팅을 선언해줌
    - 람다표현식이 길어지거나 명확하게 어떤 행동을 하는지 알수없을때에는, 메서드 참조로 리팩터링할것!
    - 명령형 데이터처리된것을 가능하면 스트림으로 리팩터링할것!(가독성 훨씬 좋음)
    - 코드 유연성 개선
      - 람다를 전달해서 다양한 동작을 표현할수잇는, 즉 동작 파라미터화가 가능하여 변화하는 요구사항에 대응할수있도록 만들자
      - 이를 위해서 함수형 인터페이스가 필요!
      - 알아두면 좋은 패턴
        - 조건부 연기 실행
          - 객체의 상태에 따라 특정행동을 수행(조건부 연기) 해야 한다면, 함수형 인터페이스 & 람다표현식(or 메서드 참조)을 활용하자!
            - 이는 가독성이 좋아질뿐아니라, 캡슐화(객체의 상태를 클라이언트에게 직접 노출하지않아도되니깐)도 강화된다!
          - ex. Logging시 특정 레벨에 사용자가 원하는 형식의 로그를 남기고 싶을때.. 
            ```java
                public void log(Level level, Supplier<String> msgSupplier){
                    if(logging.isLoggable(level)){
                        log(level, msgSupplier.get());
                    }
                }
                //넘겨받은 level이 현재 Logging의 level인지를 클라이언트에게 노출할필요없이 Logging 객체에서 진행가능하고(객체지향!), 특정 level에서 찍고 싶은 메세지(더 나아가 여러 행동들)를 사용자에게 전달받음으로써 클라이언트마다 원하는 동작들을 수행할수있을뿐 아니라, 해당 level이 되었을때만 동작하는 지연된(연기) 실행이 되어 불필요한 리소스 낭비가 줄일수있다
            ```
        - 실행 어라운드
          - 같은 준비, 종료과정을 반복적으로 수행하는 코드있다면, 반복적으로 수행하는 부분에서 변화가 잇는부분을 분리하여 파라미터화(동작파라미터 - 함수형인터페이스)해서 클라이언트에게 넘겨받도록한다
          - 템플릿/콜백 패턴과 동일
    - 람다 테스팅
      - 람다를 사용하는 메서드의 동작에 집중!
        - 세부 구현을 포함하는 람다 표현식을 클라이언트에게 공개하지않아야하니깐, 람다표현식을 사용하는 메서드의 동작을 테스트함으로써 람다표현식을 검증할수있다 (람다 검증은 그냥 람다쓰고있는 메서드를 호출해서 그 결과로 검증해라는뜻인듯)
      - 복잡한 람다를 테스트하기위해서는 메서드참조로 변경하여 테스트하는게 좋음(어차피 복잡한 람다는 메서드 참조로빼는게 가독성이 좋기떄문에.. 그리고 메서드참조를 사용하면 해당 람다로직을 검증하기도 수월)
      - 메서드가 람다를 인수로받는다면, 다른 람다로 메서드의 동작을 테스트
    - 디버깅
      - 스트림 파이프라인의 연산들에는 peek 을 사용할수있다! 이는 데이터를 소비하지않기때문에, 연산중간중간에 넣어서 어떻게 데이터가 어떻게 처리되고있는지 디버깅할수있다!
- Part 4 매일 자바와 함께
  - 11장 - null 대신 Optional 클래스
    - null 때문에 발생하는 문제
      - 에러의 근원 : NullPointerException..
      - 코드를 어지럽힘 : 중첩된 null 확인 코드를 추가해야 하므로 null 때문에 코드가독성이 떨어짐
      - 아무 의미가 없음 : null은 아무 의미도 표현하지않음. 
      - 자바 철학에 위배 : 자바는 개발자로부터 모든 포인터를 숨겼는데, null 포인터는 예외로 만들어놧음..
      - 형식 시스템에 구멍을 만듦 : null은 무형식이며 정보를 포함하고있지 않으므로 모든 참조형식에 null을 할당할수 있음.. 이런식으로 null이 할당되기 시작하면서 시스템의 다른 부분으로 Null이 퍼졌을때 애초에 null이 어떤의미로 사용되었는지 알수없음..
    - Optional 클래스
      - java 8은 하스켈과 스칼라의 영향을 받아서 java.util.Optional\<T\> 라는 새로운 클래스를 제공
      - Optional을 사용함으로써 값이 없을수 있음을 명시적으로 보여주는것!
        - 즉, null이 될수도있고 안될수도있는놈이다! 라고 알려주는것
        - 모든 null 참조를 Optional로 대치하는것은 바람직하지않음!! 도메인에 null값이 들어가지않아야할곳에는 Optional을 쓰면안됨! 이때 Null이 발견되었다면 알고리즘의 버그이므로 이를 수정해야함.. Optional을 통해서는 이게 Null이 들어갈수있는 ***선택형값***인지 여부를 구별할수있는것!!
          - 그래서 이를 사용하게되면 도메인 모델의 의미를 더 명확하게 만들수있겠지
        - Optional을 인수로 받거나, Optional을 반환하는 메서드를 정의한다면 결과적으로 이 메서드를 사용하는 모든 사람에게 이 메서드가 빈 값을 받거나 빈 결과를 반환할 수 있음을 잘 문서화해서 제공하는것과 같다!
      - Optional 주의사항
        - Optional에 빈 값을 넣고싶으면, Optional.empty() 를 사용해야함(null을 대입하면안됨)
        - Optional이 empty일때, get을 호출하면 예외떨어짐
        - Map을 사용할수있는데, stream의 map과 비슷하다.. (값은 변경하는역할) 만약, empty라면 아무일도 일어나지않음
        - flatMap의 평준화과정은 두 Optional을 합치는 기능을 수행하면서 둘 중 하나라도 null이면 빈 Optional을 생성하는 연산을 수행하는것
        - Optional에 여러 체인닝되어있을때(map, flatmap 등등 수행) 중간에 하나라도 빈 Optional을 반환한다면, 전체 결과로 빈 Optional을 반환함.. 이때 orElse라는 메서드를 통해서 디폴트값을 제공해줄수있음
        - 도메인 모델에 Optional을 사용했을때 데이터를 직렬화 할수 없다!
          - Optional 클래스는 처음 만들때 필드형식으로 사용할것을 가정하지않았다고함..
          - 직렬화 모델이 필요하다면 Optional로 반환할수있는 메서드를 추가하도록하자!
            ```java
              public class Person{
                private Car car;
                public Optional<Car> getCarAsOptional(){
                  return Optional.ofNullable(car);
                }
              }
            ```
      - Optional의 디폴트 액션과 Optional 언랩을 위한 메서드
        - get()
          - 가장 간단한 메서드면서 동시에 가장 안전하지않은 메서드
          - 빈 optional일때 호출하면 NoSuchElementException을 발생..
          - 되도록 사용하지말것!
        - orElse(T other)
          - Optional이 값을 포함하지 않을때 기본값을 제공
        - orElseGet(Supplier<? extends T> other)
          - orElse 메서드에 대응하는 게으른 버전의 메서드
          - Optional에 값이 없을때만 Supplier가 실행
          - 필요할때만 수행이되니깐 되도록 이를 사용해서 효율성을 높일것!
        - orElseThrow(Supplier<? extends X> exceptionSupplier)
          - Optional이 비어있을때 예외를 발생(내가 원하는예외..)
        - ifPresent(Consumer<? super T> consumer) 
          - 값이 존재할때 인수로 넘겨준 동작을 실행
          - 값이 없으면 아무일도 안일어남
        - ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction) 
          - java 9부터 사용가능
          - 기존 ifPresent에서 Optional이 비어있을때 실행할수있는 Runnable을 인수로받을수 있도록해놓음
      - 두 Optional 센스있게 합치기
        ```java
          public Optional<Insurance> nullSafeFindCheapestInsurance(Optional<Person> person, Optional<Car> car){ //if문으로 막 isPresent() 이렇게 확인할 필요없다!!@!@!@
            return person.flatMap(p -> car.map(c -> findCheapestInsurance(p,c))); //person이 empty이면 바로 empty리턴(flatmap), car가 empty이여도 바로 empty리턴(map)
          }
        
        ```
      - Optional 클래스와 메서드 정리 (p383)
        - 사진넣어놓자
      - Optional을 어디서 사용?
        - 잠재적으로 null이 될 수 있는 대상을 Optional로 감싸자
          - map의 get호출시 null에 대한 처리를 다음과같이.. Optional.ofNullable(map.get("key"));
        - 예외와 Optional 클래스
          - 아래와 같은 유틸클래스를 만들어두면좋음!
          ```java
            public static Optional<Integer> stringToInt(String s){
              try{
                return Optional.of(Integer.parseInt(s));
              }catch(NumberFormatException e){
                return Optional.empty();
              }
            }
          ```
  - 12장 - 새로운 날짜와 시간 API
    - 필요할때 책에서 찾아보자
  - 13장 - 디폴트 메서드
    - default라는 키워드로 인터페이스에 정의할수있음
      - 인터페이스를 구현한 클래스입장에서 구현하지않더라도 인터페이스 자체에서 기본으로 제공해주는 메서드이기때문에 디폴트 메서드라고 함
    - 자바 8부터 나옴..
    - 왜나오게 됏나?
      - 인터페이스에 기능 추가를 했을때, 이를 구현하고있던 모든 구현체들은 인터페이스에 변경된(like 메서드 추가) 부분에 맞추어 변경이 필요했다.. 이에 대한 해결책이 디폴트 메서드!
      - 즉, 코드 구현을 강제하지않기때문에 기존 구현체와의 호환성을 유지할수있다! 
    - 추상클래스 vs 자바8의 인터페이스
      - 공통점
        - 추상메서드와 바디를 포함하는 메서드를 정의 할 수 있음
      - 차이점
        - 클래스는 하나의 추상클래스만 상속받을수 있지만, 인터페이스는 여러개 구현할수있음
        - 추상 클래스는 인스턴스 변수로 공통 상태를 가질수있지만, 인터페이스는 정적필드만 가질수있고, 인스턴스 변수는 가질수없다!
    - 여러 인터페이스를 상속받는 등 충돌이 일어날때 해석규칙
      - 다른 클래스나 인터페이스로부터 같은 시그니처를 갖는 메서드를 상속받을떄는 아래 세가지 규칙에 따른다
        1. 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트 메서드보다 우선됨 (구현한 메서드가 디폴트메서드 보다 항상 우선함!)
        2. 1번 규칙 이외의 상황에서는 서브 인터페이스가 이긴다. 상속관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메서드를 정의할때는 서브 인터페이스가 이긴다. 즉, B가 A를 상속받는다면 B가 A를 이긴다
        3. 여전히 디폴트 메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메서드를 오버라이드하고 호출해야한다 
           - 자바 8부터 `X.super.m(...)` 을 사용하여 어떤 인터페이스의 메서드를 사용할것인지 명시할수있음 
    - 13장을 통한 기타 팁
      - 여러 기능들이 있는 클래스에 특정 메서드 하나만 바꾸고 싶을때는 상속해서 오버라이딩 하지말고, Proxy를 생각하자!
  - 14장 - 자바 모듈 시스템
    - 나중에 시간되면 공부하고 정리할것
  - 
