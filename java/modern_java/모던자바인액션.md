모던자바인액션
- Part 1 - 기초
  - 1장 - 자바 8,9,10,11 : 무슨일이 일어나고있는가?
    - 멀티 코어에 따른 더욱 빠른 데이터 처리가 가능하여졌는데, 자바는 코어 하나만을 기존에 사용하였다.. 이에 따라 멀티코어 이상을 잘 활용할수있도록 병렬처리가 필요해졌고, 이에 대한 대응을 위해 자바 8이상부터 대폭 개선됨(+ 간결함)
    - Java 8에서 제공하는 새로운기술
      - 스트림 API
        - DB의 질의 언어처럼 고수준의 언어로 표현하면, 스트림 라이브러리가 최적의 저수준 실행방법을 선택하여 값을 리턴해준다(forkAndJoin 활용하여 병렬연산같은..)
          - 또한 스트림 파이프라인을 이용해서 입력부분을 여러 CPU 코어에 쉽게 할당할수있다는 부가적인 이득도있음! 즉, 복잡한 병렬작업을 직접처리하지않아도된다!
        - 스트림
          - 한번에 한개씩 만들어지는 연속적인 데이터 항목들의 모임
        - 스트림 메서드로 전달하기위해서는 안전하게 실행할수 잇는 메서드를 만들어야하는데, 이러한 함수를 순수(pure)함수, 부작용없는(side-effect-free) 함수, 상태없는(stateless)함수라 부른다
        - 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제(루프를 이용하여 각 요소를 반복하면서 작업을 수행 - 외부반복), 멀티코어 활용의 어려움을 해결
          - ***컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면, 스트림은 데이터에 어떤 계산을 할것인지 묘사하는것에 중점을 둔다!***
        - 필터링, 추출, 그룹핑, 병렬화!
      - 메서드에 코드를 전달하는 기법
        - 동작파라미터화
          - 동작(행위)을 넘겨줄수있도록 하는것!
          - 메서드를 값처럼 전달가능!(이급시민 -> 일급시민으로 격상시킴)
            - 메서드참조
            - 람다
            - 메서드참조 vs 람다
              - 좀더 의미를 명확하게 할수있는것은 메서드참조!
              - 심플하게 전달해줄수잇는것은 람다표현식
              - 코드의 명확성이 항상 중요하기때문에, 간단한거면 람다표현식을, 로직이 복잡해지면 메서드참조를 사용하자!
        
      - 인터페이스의 디폴트 메서드
        - 인터페이스에 무언가 변경이 필요하면, 기존 해당 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야했는데, 기존 구현을 고치지않고도 인터페이스를 바꿀수 있도록 해준것이 인터페이스의 디폴트메서드
        - 

    - 스트림 API
      - 
  - 2장 - 동작 파라미터화 코드 전달하기
  - 3장 - 람다 표현식
  - Part1 기타 팁
    - 용어정리
      - 함수형 프로그래밍 : 
      - 람다 
        - 익명함수 + 메서드를 인수로 전달가능(메서드참조)
        - 익명 클래스와 유사.. 
      - 함수 : 특정클래스에 종속x. 정적메서드와 같은 의미로 사용
      - 메서드 : 특정 클래스에 종속

      - 익명함수 : 
      - 메서드참조 
      - 익명클래스 : 
      - 리엑티브 프로그래밍 : 
      - 리엑티브 스트림즈 : 
      - https://mangkyu.tistory.com/111
      - https://dinfree.com/lecture/language/112_java_9.html
      - 메소드와 함수 (Method and Function)의 차이점
        - 함수가 메소드를 아우르는 포괄적인 용어이다.
        - 함수는 객체로부터 독립적이며, 메소드는 객체에 종속적이다.
        - 메소드는 거의 모든 면에서 함수와 동일하지만, 아래의 2가지 포인트에서 다른 점이 있다.
          - 메소드는 호출된 객체에 암시적으로 전달된다.
          - 메소드는 클래스 안에 있는 data를 조작할 수 있다.
        - 기본적으로 두 용어의 뜻은 동일하나 '객체(클래스)로부터 독립적인가 아닌가'가 함수와 메소드를 나누는 기준이다.



```java
    public static <T, U extends Comparable<? super U>> Comparator<T> comparing(  //U는 Comparable을 상속받는놈.. Comparable에 들어가는 제네릭 타입은 U의 슈퍼타입가능
            Function<? super T, ? extends U> keyExtractor)
    {
        Objects.requireNonNull(keyExtractor);
        return (Comparator<T> & Serializable)
            (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));   //(c1,c2) -> U타입.compareTo(U타입).. 즉 Function에서 return해주는 타입을 가지고 비교해라..
    }

```