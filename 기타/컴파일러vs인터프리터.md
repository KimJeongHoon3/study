컴파일러vs인터프리터

- 왜 필요한가? 
	- 컴퓨터에 명령을 주기위해서는 기계가 알아먹을수있는 기계어가 필요한데, 이는 사람이 읽을만한(코딩할만한) 고수준의 언어가 아니여서, 고수준의 언어를 기계어와 같은 저수준의 언어로 변경하기 위한 작업이 필요함
	
- 컴파일러 : 컴파일러를 통해 소스코드를 하드웨어를 제어할수있는 기계언어로 바꾸어 주어 실행할수있도록 해준다. 런타임 이전에 소스 코드 전체를 한번 다 훑고 컴퓨터 프로세서가 실행할수있도록 바로 기계어로 변환된다. 이 때문에 실행 전에 에러를 감지할수있고, 각 행마다 실행시키는 인터프리터보다 빠르게 실행된다. 하지만, 보통 OS에 종속적이기 때문에 소스코드를 해당 OS에 맞추어 작성해야되므로 각 환경마다 소스코드가 달라지는 단점이 잇다. 대표적으로 C언어를 들수있다

- 인터프리터 : 고레벨 언어를 중간 코드(intermediate code)로 변환하고 이를 각 행마다 실행한다. 이 중간코드를 실행하는 것이 인터프리터이다. 런타임시에 명령어 단위로 실행되기때문에, 실행되기전까지는 어디서에러가 났는지 확인이 어려우며, 컴파일러보다는 느리게 작동한다. OS에 맞는 인터프리터만 있다면, 어떤환경에서 소스코드를 써도 동일하게 구현된다. 즉, OS에 종속적이지않다. 파이썬에는 analyzer, 자바에서는 자바 interpreter(jvm안에있음) 가 있다.

- 그렇다면 자바는 어떻게돌아가나?
	- 자바는 컴파일러와 인터프리터가 함께쓰는 언어!
	- 자바는 javac 라는 자바 컴파일러를 통해서 바이트 코드로 변환이 일어난다. 하지만, 이는 바로 기계어로 해석된것이 아니다. 이 컴파일된놈을 JVM의 자바 인터프리터가 해당 OS에 맞게 기계어로 해석하여 실행 시켜주어야한다. 바이트 코드로 변환했을시에 정의된 명령어 단위로 해석하여 실행시키는데, 한줄씩읽어나가는 인터프리터의 단점을 보완하기위해서 JIT 컴파일러가 JVM에 있어서, 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 해당 메서드를 더 이상 인터프리팅하지 않고 네이티브 코드로 직접 실행해준다. ("jvm 관련 내용" 참고)
	- 이렇게 함으로써 컴파일러와 인터프리터를 통해서 누릴수있는 장점들을 살릴수 있다.
		- 실행전 에러를 체크할수도있으며, 해당 OS에 맞는 JAVA만 설치하면 어떤 소스코드를 가져와도 실행가능하므로 OS에 종속적이지않다!



- 참고 사이트  
	- https://hanul-dev.netlify.app/java/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0(interpreter)%EC%99%80-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC(compiler)%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90./

	- https://m.blog.naver.com/ehcibear314/221228200531


---

컴파일러는 전체소스를 한번에 기계어 또는 바이트코드로 전환해줌. 실행전에 에러를 찾을 수 있음. 컴파일러를 통해 기계어로 전환되어있다면(ex. .exe파일) 실행속도가 인터프리터에 비해 매우 빠르다.

인터프리터는 소스코드를 한줄씩 실행하는것이다. 파이썬이 대표적인 예이다. 코드를 한줄한줄씩 실행하다보니 컴파일러보다 느리다. 그리고 한줄씩 실행하기때문에 디버깅을 가능하게해주나, 런타임에만 에러를 알 수 있다

자바는 이 둘을 잘 조화해서 컴파일러를 통해 런타임전에 에러를 미리 확인할 수 있고, 컴파일된 바이트코드를 인터프리터가 한줄씩 읽어나가기때문에 디버깅에 용이하다. 그리고 컴파일된 바이트코드는 운영체제 플랫폼에 독립적이게 되는데, 이는 인터프리터가 os에 맞게 적절하게 바이트코드를 해석해주기 때문이다. 즉, 자바는 인터프리터(jvm)는 os에 종속적이나 컴파일러는 독립적이다 