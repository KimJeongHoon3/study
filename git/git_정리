1. git init
2. 파일을 스테이지에 올림(한번 올라가면 계속 올라가있음.. 만약 untract파일에 대한 추가가아닌 기존파일이 변경되면 변경된거를 스테이지에 올려야함) git add
3. 커밋(스냅샷) git commit
4. push

*커밋시 추가된 것만 올라가는게 아니라 모든 파일이 올라가는것이다..!(스냅샷) 소스트리가 기존파일에서 변경된 것만 보여주는것을 해당파일만 더해져서 커밋한다고 생각하면안된다!

계속 암호 칠 필요없이 ssh로 접속하는방법 : https://zeddios.tistory.com/120
https://stackoverflow.com/questions/7438313/pushing-to-git-returning-error-code-403-fatal-http-request-failed
Ssh://git@github~


HEAD : 현재 가리키고 잇는 커밋을 보여줌.. 
	ex) ORIGIN / HEAD 라고 되어있다면 원격저장소(ORIGIN이라 이름을 칭한것인데 바꿀수있음..)에서 가리키고있는곳이다

Merge
	-병합커밋(merge commit) : 병합시 이전 커밋과 커밋하는 대상들이 모두 다를때.. 
	-빨리감기(fast-forward) : 병합시 새로 커밋요청한것이 전부일때.. 
	-충돌(conflict) : 병합시 합쳐져야할 부분이 명확치않음!(변경한곳이 겹친다!)
	ex) 원격지 master 브랜치에서 A라는 버전에 두개의 branch(jh,hm)를 생성하였을경우, jh 브렌치가 원격지의 master에 merge를 하게되면 “빨리감기”가 될것이고, 
이후에 hm브랜치가 merge 하게되면 jh가 master branch에 병합한것과(브랜치 처음따올때의 master와 버전이 다름!) hm이 변경한 데이터를 “병합커밋” 하게된다.. 
이 병합커밋시 변경을 시도하려는곳이 동일하다면 어떤 브랜치꺼로 병합을 해야할지 명확치않게되어 “충돌”이 일어나게된다!

Pull request : “내가 지금 push한것을 merge하기전에 검토한번해줘!” 라고 요청하는것.. 이를 통해서 merge하기전 체크를 받을수있음..
	-해당 내용을 merge 하고 소스트리보면 바로 업뎃이 안되어있을수있는데, 패치를 통해서 최신정보를 가져올수있음..(10분마다 패치가 실행된다함..)

Fork : 다른 원격저장소에 있는것을 복사해서 내 원격저장소에 등록하는것

Rebase(재배치) : fork하고 있는 원본저장소와 현재 나의 원격저장소간에 conflict이 발생할경우, 나의 원격저장소에서 처음 바라본 커밋(base)을 다시 최근 커밋으로 재배치(Rebase)하여 conflict를 쉽게 해결할수있음!
	=> Rebase를 사용하면, 커밋(base)를 기존과 바꾸는것이기 때문에 내 원격저장소에 정상적으로 push가 되지않는다.. 그래서 강제적인 push를 사용해야함..(그래서 혼자쓰고있는 저장소여야한다..) 그리고 pull request!
    -Rebase 타겟의 브랜치가 현재 브랜치보다 이전 커밋버전이라면 변경x.. 타겟 브랜치가 변경이있었다면 Rebase가능..
    -반대로 Rebase타겟의 브랜치가 현재 나의 브랜치의 커밋상태보다 변경된 내용으로 커밋되어있다면(빨리감기병합을 할수있는 상태) rebase 실행시 빨리감기병합을 실행한다...  
    *원리설명
        -HEAD와 대상 브랜치의 공통조상을 찾는다..
        -공통조상 이 후에 생성한 커밋들을 대상 브랜치 뒤로 재배치한다..(만약 공통조상이후에 현재 내 브랜치만 최신이라면 rebase 실행안되겟지..당연히 될게 없지.. 즉, 대상브랜치가 공통조상이후에 뭔가 커밋한게 있어야 실행된다!!! 그뒤로가서붙는다!!)
    -rebase는 반드시 혼자만 쓰는 브랜치에서 수행! 히스토리를 조작하기때문!! 보통 fork하면 conflict해결하고 pull request 하는것보다 rebase로 최신꺼 받아온뒤 pull request 하는게 더 깔끔..
    -rebase는 재배치계속을 통해서 rebase를 완성해야한다..!

Amend : 마지막 커밋또한 변경가능! 이미 푸쉬했다면 강제푸쉬를해야만 변경된커밋을 바꿀수있음..

Cherry pick : 특정 커밋만 반영! 다른 브렌치의 첫번째, 두번째, 세번째 커밋이 있을때.. 두번째에 반영한 내용만 가져올수있음!!(첫번째커밋 반영x, 세번째커밋반영x)

Reset : 되돌리는기능!(마치 아무것도 없었던것처럼..ㅎ)
	-HARD : 체리픽 한 해당 커밋으로 이동하며 이전의 작업한것들은 날아감 
	-MIX : 체리픽 한 해당 커밋으로 이동하고 이전의 작업한 것들 날아가지않음,, (스테이지에 반영되어있지않음)
	-SOFT : 체리픽 한 해당 커밋으로 이동하고 이전의 작업한 것들 날아가지않음,, (스테이지에 반영되어있음)

Revert : 커밋을 되돌리는기능으로 reset과 유사하나 차이점은 히스토리를 남겨주는것!
	-master 브랜치에있는 중간중간에 끼어있는 특정 커밋들을 되돌려야할때 revert를 사용하면된다!! 예를들어 C1<-F1<-C2<-F2<-C3(master)일때, F1과 F2의 커밋들을 되돌려야한다고하였을경우 git revert F2, git revert F1 명령을 때리면 C1<-F1<-C2<-F2<-C3<-RF2<-RF1(master) 이렇게됨!

stash(넣어두다) : 잠깐 치워놨다가 다시쓰는것.. 현재 작업중에 급하게 먼저 고쳐야할 일이 생겼을때 기존의 파일 내용들을 잠시 치워놔야할때 사용! 현재 변경점이 있는 내용은 모두 스테이지상에 사라지게만들고 필요작업하고 커밋한뒤에 잠깐 치워놨던것들을 다시 불러와서 작업할수있음

체크섬 : 해당 커밋의 고유번호..

커밋의 부모는 언제나 이전 커밋! 이전의 커밋을 바라보고있고, diff또한 부모커밋과 현재커밋을 비교하여 보여주는것! 모든버전을 다 뒤지는것아님!

checkout은 브랜치를 변경하는것 말고도 특정 커밋으로도 이동이 가능하다..(git checkout 커밋체크섬) 특정커밋으로 이동하게되면 HEAD는 지정한 커밋으로 이동하게되고 detached HEAD 상태가된다..(현재 브랜치와 같은 곳을 바라보고있지않으므로..) 이때 git branch 명령어를 쳤을때 "*" 는 "HEAD detached at 커밋체크섬" 을 가리킨다..(당연한이야기..)
이때에 브랜치를 현재 HEAD와 동일한 지점으로 옮기려면 git branch -f "브랜치명" 을 때려주고 git checkout "브랜치명" 을 통해 다시 원하는 브랜치에서 작업이가능


—
Git cli
-git config 종류
	1)지역옵션(git config --local) : 현재 git 저장소에서만 유용한 옵션
	2)전역옵션(git config --global) : 현재 사용자를 위한 옵션
	3)시스템옵션(git config --system) : PC 전체 사용자를 위한 옵션

	적용순서 : 1 > 2 > 3
	*git config --list : 현재 프로젝트의 모든 옵션 보여줌

특정 커밋으로 되돌릴때 커밋체크섬대신 손쉽게 표현하는 방법
	-HEAD~<숫자> : HEAD~는 부모커밋, HEAD~n은 n번째 위쪽 조상
	-HEAD^<숫자> : HEAD^는 부모커밋, HEAD~2는 두번째 부모.. 병합커밋처럼 부모가 둘 이사인 커밋에서만 의미가 있다함..(뭔솔..?)


******Git 용어정리 *******
워킹트리 : 작업폴더에서 .git폴더를 뺀것.. 즉, 일반적인 작업이 일어나는곳!
로컬저장소 : .git폴더(이 안에 스테이징, 커밋을 구성하는 객체 등모든것이 저장)
원격저장소 : 로컬 저장소를 업로드하는곳!(Ex.GitHub)
Git저장소 : 엄밀하게는 로컬저장소를 이야기하지만 넓은의미로는 작업폴더를 의미하기도함
작업폴더 : 워킹트리 + 로컬저장소
업스트림 : 로컬저장소와 연결된 원격저장소를 일컫는단어

****************************

******실무에서의 브랜치 이름과 특성*******
feat/기능이름 : 각 개발자가 개발중인 브랜치 직접커밋을 올림
master : [feat/기능이름] 브랜치에서 개발완료된 코드가 합쳐진 브랜치.. 출시전엔 베타버전.. 여기에 직접 커밋하지않고 병합을 통해서만 함
latest : 실제 출시할 코드를 올리는 브랜치.. 개발이 끝나면 출시시점에 [latest] 브랜치로 코드를 병합 

일반적으로 브랜치를 사용할때(구체적으로는 상의해서 정해야함)
-새로운기능추가
-버그수정
	-hotFix, bugFix 같은 이름을 사용
-리베이스나 병합
-이전코드개선
-특정커밋으로 되돌아가고싶을때 : reset과 revert는 까다롭고 위험성이있으므로, 브랜치를 따로 만들어서 사용하되, 정상적으로 완료되었으면 rebase나 병합을 진행하고 그렇지않을경우 Master 브랜치를 그냥 고대로 내비두면끝

master branch가 현재 로컬에 저장되어있다하더라도 이 master branch로 결국 올리는것이므로 master branch는 건들지말고 내가 작업을 위해 만든 브랜치에다가 지지고볶고해야한다.. 그리고 병합할때도 내가 만든 브랜치 기준으로!! master를 base로 하지말것!!

master branch에 병합하기전 꼭 pull request를 사용할것!
    -base : master, compare : 내가 만든 브랜치
    -compare 우측에 able to merge인지 conflict인지 항상확인!
    -Reviewers 설정 : 나와 함께 프로젝트하고있는 사람들
    -labels : 버그, 리뷰필요, 프런트엔드, 백엔드 등을 달아줌


********************************************



기존에 설정된 계정때문에 다른계정으로 Push가 안돌때 사용하는방법(윈도우,맥 다 나와있음)
https://recoveryman.tistory.com/392


************ git 원리 이해 *************
-스테이지에 파일이 올라가면(git add .) index라는 파일이 생성이되는데, index==stage 이다.. 
    -또한 이때에 해당 파일의 내용은 해쉬값으로 변환하여 저장하게되는데, 그 값은 ".git/objects" 여기에 저장된다
-커밋을 완료하면(git commit) object에는 두개의 파일이 추가가된다.. "커밋객체"와 "트리객체"
    -커밋을 실행하면 아래와 같다
    $git commit -m "업"
    [master (root-commit) 3d5f2c6] 업
    1 file changed, 1 insertion(+)
    create mode 100644 cat.txt

    -커밋객체의 내용을 살펴보면 아래와같다
    $git cat-file commit 3d5f2c
    tree 7a5459aa5fe7865d499c6d1c0c7c7f8b278fb74f
    //부모객체있으면 여기에!
    author jeonghun kim <jeremy@biztalk.co.kr> 1597729794 +0900
    committer jeonghun kim <jeremy@biztalk.co.kr> 1597729794 +0900

    업

    -tree의 내용은아래와같다
    $git ls-tree 7a5459
    100644 blob ff5bda20472c44e0b85e570185bc0769a6adec68	cat.txt     //  실제 파일내용

    =>즉 HEAD는 커밋객체((3d5f2c6)를 가리키는데, 해당 커밋객체는 트리객체,blob객체를 가진다.. 그리고 트리객체는 파일의 내용을 가지고있다(blob를 가리킴.. 아마 ./git/objects의 내용을 가리켜서 실제내용을 참조하지않을까..)
    *blob(binary large object) : 모든 파일의 내용은 blob로 저장되고, 동일한 내용이라면 같은 blob값을 가지기때문에 여러개 동일한 데이터를 만들어도 부하나 용량에 관하여 신경쓸필요가없다! 

    *커밋하고 git status 명령시 clean한 상태는 '워킹트리 = 스테이지 = 커밋' 즉, 워킹트리,스테이지,커밋 모두가 같은내용 이라는뜻!

-파일에 내용을 추가하여(git add 안함) git status라 명령하면 modified라고 나타나는데, 이는 스테이지와 워킹트리를 비교하여서 나타는것임!
-인덱스파일
-브랜치를 새로 만들게되면 그냥 "./git/refs/heads/"에 브랜치명으로 파일이 생성되는데, 해당 내용은 커밋의 blob값이 적혀있다. 즉, 브랜치를 만들면 그냥 해당 커밋을 참조하는게 하나 더 늘어나는것!

-.git/HEAD 에는 현재 어떤 브랜치인지를 보여준다.. 예를들어 cat .git/HEAD 명령을 하면 master 이런게 찍힘.. checkout의 원리는 여기 HEAD안의 내용을 바꾸는거임.. +워킹트리와 스테이지 내용을 해당 커밋의 내용으로 변경
    -즉, 체크아웃이란! 해당브랜치로 HEAD를 이동시키고 스테이지와 워킹트리를 HEAD가 가리키는 커밋과 동일한 내용으로 변경하는것! (HEAD 변경시키고 reset --hard 한것과같음..)



*유용한 명령어
git show <커밋체크섬>
git cat-files -t <커밋체크섬> : 커밋체크섬의 타입 
git cat-files <커밋체크섬 타입> <커밋체크섬> : 해당 커밋체크섬의 내용나옴
git ls-tree <커밋체크섬> : 트리객체 볼수있음
git ls-files --stage : 스테이지 내용

*******************************************