Mariadb

-만든사람의 셋째딸 이름 maria
-mysql과 클라이언트나 jdbc는 모두 호환가능(MySQL쓰는 사람들이 Mariadb쓰는데 불편함 없게하기위해!)
-mysql과 서버의 옵티마이저나 스토리지엔진에는 명확한 차이가 잇음!
-dump뜨고 source로 가져오는게 좋음(source는 mysql클라이언트로 접근해서 가능)
    -source는 진행상황볼수있음
    -mysql -u root -p < backup.dump 이런식으로 가져오면 화면상에 아무것도 출력안됨..

-userId와 ip가 같이 인증대상이다.. ex) 'root'@'127.0.0.1' 이건 127.0.0.1외의 ip는 접근불가.. 'root'@'%' root로 모든곳에서 접근가능,, 이 두개가 모두 등록되어있을때는 범위가좁은것이적용! 즉, 127.0.0.1

-CREATE DATABASE [DB이름] DEFAULT CHARATER SET [utf8mb4];
-SHOW CREATE TABLE 테이블명
    -desc와 같이 테이블에 대한 정보들 보여주나, 인덱스나 PK ENGINE 관련한것들도 볼수있다! create 하는 문장 고대로 보여줌!
-테이블 삭제시(drop table) 해당 테이블과 연관된 페이지는 버퍼 풀에서 제거되어야한다.. 그렇기위해서 해당 명령이 실행되면, 버퍼 풀의 모든 캐시페이지를 스캔하는데, InnoDB의 버퍼풀이 크고 사용량이 높다면 테이블 삭제에서 이 작업이 시간을 많이 소모하게된다.. 그런데 이보다 더 중요한부분은 물리적인 데이터파일을 삭제하는데있어서 파일시스템이 EXT3이면 파일의 삭제가 많은 시간을 소모한다(XFS는 좀 빠르다함..) 




-설정관련
    -버퍼 풀 사이즈는 전체 메모리의 50~80프로 권장

-권한
    -특정 테이블이나 열에 권한을 부여하는 계정이 필요하다면, view를 만들어서 제공하라!




*실행계획분석 ( + real mysql)
-옵티마이저가 쿼리 실행시 최적의 실행계획을 수립하는 작업을수행하여 쿼리를 실행(통계정보를 활용하여 최적의 실행계획을 수립)
    *옵티마이저 : 데이터베이스 서버에서 두뇌와 같은 역할
        -비용 기반 최적화 방법과 규칙기반 최적화 방법이 있으나, 현재 대부분의 RDBMS는 비용기반최적화방법을 사용
            *규칙기반 최적화 : 대상테이블의 레코드건수나 선택도 등을 고려하지않고 옵티마이저에 내장된 우선순위에 따라 실행계획을 수립한다... 같은 쿼리에 대해서 거의 항상 같은 실행방법을 만들어냄! 거의 지원안됨!
        -비용 기반 최적화는 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계정보를 이용해 각 실행 계획별 비용을 산출한다.. 이렇게 산출된 각 실행 방법별로 최소비용이 소요되는 처리방식을 선택해 최종쿼리를 실행..
            -비용기반 최적화에서 통계정보는 매우중요한역할.. 통계정보가 제대로 반영되어있지않다면 레인지스캔을 해야할게 풀스캔할수도있음..(Mariadb의 기본적으로 통계정보는 레코드건수와 인덱스의 유니크한 값의 개수 정도가 전부)
            -통계관련된 자세한 내용은 Real Maraidb p119참고
            -통계정보 갱신방법
                -ANALYZE TABLE 테이블명;
                    -ANALYZE를 실행하는동안, MyISAM 테이블은 읽기는 가능하지만 쓰기는 안됨! InnoDB테이블은 읽기와 쓰기 모두안됨!

        -조인쿼리의 실행 계획 최적화를 위한 옵티마이저 옵션은 두가지가있음
            -Exhaustive 검색
                -테이블 갯수 factorial.. ex) 테이블갯수가 3개이면 3! (3*2*1) 
                -상당히 느림..
            -Greedy 검색
                -optimizer_search_depth의 값에 따라 최적의 조인 순서를 결정
                -optimizer_search_depth가 만약 2로 되어있고, 4개의 테이블을 조인한다면, Exhaustive검색과 같이 모든경우의 수를 나열하는것이아닌, 처음 두 테이블을 가지고 최적의 비용을 찾고 나온 결과를 가지고 다시 테이블을 비교하여 최적의 비용을 찾게된다..
                -Exhaustive 검색보다 확실히 빠르지만, 기본적으로 optimizer_search_depth은 62로 셋팅되어있다. 그렇게된다면 테이블이 62개보다 많지않은이상 Greedy 검색의 장점을 누리지못하게되는데, 그래서 5~8로 셋팅하는것이 좋다한다..(5개 이상의 테이블을 조인하는경우라면)

-실행계획
    -Explain
        -쿼리문장의 특성에 따라 한줄 이상의 결과가 표시
        -사용된 테이블의 개수만큼 레코드가 출력
        -쿼리문장에서 사용된 테이블이 표시되고 위에서 아래(id가 작은숫자부터 높은숫자)로 접근한 테이블을 보여줌
        -필요에 따라 실행계획은 산출하기위해 쿼리의 일부분을 직접 실행할때도있음,, 그래서 무거운 쿼리의 경우에는 실행계획의 조회또한 느려질 가능성이있음
            -예를들어, 서브쿼리를 통해서 상수값을 구했을때는 실행계획단에서 쿼리를 직접실행함..
        -컬럼구성
            -id 컬럼
                -서브쿼리가 있는 SQL의 경우에는 두개이상의 단위쿼리(쿼리를 쪼갠것)를 볼수있는데, 이때 실행계획에서는 ID가 두개 이상의 값이 나온다
                -여러 테이블을 join할때는 테이블마다 실행계획 레코드가 출력되지만 같은 id값을 가진다
            
            -select_type
                -"Select 쿼리"가 어떤 타입의 쿼리인지 표시되는 컬럼
                -종류
                    -SIMPLE : UNION 이나 서브쿼리를 사용하지않는 단순한 쿼리. 일반적으로 제일 바깥 SELECT 쿼리의 select_type이 SIMPLE로 표시(Join도 SIMPLE로!).. join 아닌 이상 하나만존재
                    -PRIMARY : UNION 이나 서브쿼리를 가지는 SElect 쿼리의 실행계획에서 가장 바깥쪽에 있는 단위 쿼리는 PRIMARY로 표시.. 그래서 하나만 존재..
                    -UNION : FROM절에서 UNION을 여러개 사용하게되면, 첫번째 UNION을 사용한 문장에는 DERIVED로 나타나고 나머지는 UNION으로 표시됨
                        *DERIVED는 UNION된 쿼리결과들을 모아서 저장하는 임시테이블임..
                    -Dependant UNION : where 조건문에 IN 사용했을때, IN안에 UNION을 사용하게되면, 외부쿼리 먼저 실행하고 그 이후에 서브쿼리를 실행한다.. 보통은 서브쿼리가 먼저실행되나, DEPENDANT가 붙었을때는 외부부터 시작하여 생각한대로 인덱스를 타지못하는 경우가 생기니 DEPENDANT 안생기도록 주의할것
                    -UNION RESULT : UNION 결과를담아두는 테이블.. UNION의 결과를 임시테이블로 생성하게되는데, 이 임시테이블을 지칭.. 실제 쿼리의 단위쿼리가 아니기때문에 id값은 없음!
                    -SUBQUERY : FROM절에서 사용하는 서브쿼리는 DERIVED 로 표현되고, 나머지위치에서는 SUBQUERY로 표현!
                        *서브쿼리는 사용하는 위치에 따라 명칭을 다르게부른다!
                            -Nested Query
                                -Select되는 컬럼에 사용된 서브쿼리
                            -Sub Query
                                -Where절에서 사용된 경우
                            -Derived
                                -From 절에 사용된 서브쿼리.. 일반적으로는 RDBMS에서 "인라인 뷰"라고 부른다함
                                -파생테이블!
                            *서브쿼리가 반환하는 값의 특성에 따라 다음과 같이 구분
                                -스칼라 서브 쿼리 : 하나의 값만 반환(컬럼이 단 하나인 레코드 1건만)하는 쿼리
                                -로우 서브 쿼리 : 컬럼의 개수에 관계없이 하나의 레코드만 반환하는 쿼리

                    -DEPENDENT SUBQUERY : 바깥쪽(Outer) SELECT 쿼리에서 정의된 컬럼을 사용하는 경우
                    -DERIVED : FROM절에서 SUBQUERY를 만들면 임시테이블을 만들게되어 DERIVED 라고 나타남.. 이전에는 서브쿼리로 만들어진 DERIVED에 대해서 인덱스가 적용이안되었지만 Mariadb5.3 버전부터는 지원가능.. 그러나 되도록 join으로 바꿀수있으면 바꿔라!!!
                    -UNCACHEABLE SUBQUERY : 캐시 못쓰는 서브쿼리
                        -DEPENDENT SUBQUERY나 SUBQUERY는 캐시를 모두 사용하나, SUBQUERY는 캐시한 데이터가 자주 바뀌지 않으니 캐시를 쓰는 효과를 볼수있다.. 그러나 DEPENDENT SUBQUERY는 데이터가 자주바뀌므로 캐시를 계속 생성해낸다..
                    -MATERAILIZED : DERIVED와 유사함.. 임시테이블만든것.. 서브쿼리의 내용을 임시테이블로 구체화(materialization) 한 후, 임시테이블과 테이블을 조인하여 처리하는 형태로 최적화됨.. 
                    -INSERT, UPDATE, DELETE도 모두 지원됨..
            
            -table 칼럼
                -테이블컬럼에 "< xxx >" 이런식으로 둘러쌓여있는게 있는데, 이는 임시테이블을 의미한다. ex) <derived2> 는, id가 2번인 실행계획으로 만들어진 파생테이블을 가리킨다
                -table 컬럼을 보고 순서를 파악할수있다
                    ex) 
                        id     select_type       table    ...
                        1        PRIMARY       <derived2>
                        1        PRIAMRY          e
                        2        DERIVED        dept_emp
                    
                        위와같이 실행계획이 나왔다면, 순서는 아래와같다
                        1) 첫번째 라인의 테이블이 <derived2>라고 적혀있으니, id2 번의 임시테이블(파생테이블)이 먼저 만들어져야함 의미한다.
                        2) 세번째 라인의 id 2는 dept_emp테이블을 가지고 파생테이블(DERIVED)을 생성한다
                        3) 세번째 라인의 분석이 끝났으므로 다시 첫번째 라인으로 돌아감
                        4) 첫번째 라인과 두번째 라인은 같은 id값을 가지고 있는 것으로 봐서 2개의 테이블이 조인됨을 알수있음.. <derived2>테이블이 e 테이블보다 먼저(윗라인) 표시되어있기 때문에 <derived2>가 드라이빙 테이블이 되고, e 테이블이 드리븐 테이블 된다.
                            즉, <derived2> 테이블을 먼저 읽어서 e테이블로 조인을 실행했다@!
                        
            -type 컬럼
                -레코드를 어떤 방식으로 읽었는지 알수있음(풀스캔? 인덱스? 등)
                -하나의 단위 SELECT 쿼리에서 아래 종류중에 하나만 사용하며, index_merge(where a or b)를 제외하고는 반드시 하나의 인덱스만 사용!!
                -종류(아래로 갈수록 느린것)
                    -system : 레코드가 1건만 존재하거나 한건도 존재하지않는 테이블을 참조하는 형태의 접근방법.. MyISAM or MEMORY 일때만 쓰이고 InnoDB나 XtraDB엔진에서는 안쓰인다 (InnoDB로 할경우 index 가 사용)
                    -const : 쿼리의 WHERE 조건절에 PK나 Unique Key 가지고 반드시 1건을 반환하는 쿼리의 처리방식,, 다른 DBMS에서는 이를 "유니크 인덱스 스캔"이라고 표현
                        -만약 PK로 여러 컬럼이 지정되어있을때, 하나의 컬럼으로 조회하게되면 const 안됨! ref로 잡힘(비록 1건만 조회되더라도! 엔진 입장에서는 확실히 알수가없으니!)
                        -Mariadb(MySQL)의 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 통째로 상수화한다는 뜻임
                            explain
                            select count(*)
                            from employees e1
                            where e1.first_name=(SELECT first_name from employees e2 where e2.emp_no=10001);

                            => 결과
                            id    select_type     table     type       ....
                            1     PRIAMRY           e1       ref
                            2     SUBQUERY          e2       const

                            => 해석
                            서브쿼리가 먼저 해석되었는데, 왜 2번으로 나타나는지... 의문......?????????????????????/

                    -eq_ref : 여러테이블이 조인되었을때 나타나게되는데, 처음 테이블이 읽은것을 다음 테이블의 PK or UK의 검색조건에 사용될때 eq_ref가 표시됨..(드리븐 테이블이 조인시 PK or UK를 사용하였나) 즉, 조인에서 두번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이있어야 사용할수있음! 
                    -ref : 인덱스의 종류와 관계없이 동등조건(=) 으로 검색할때는 ref 접근방법이 사용! ex) PK가 두개 이상의 열로 지정되어있을때 하나의 열로만 검색하면 const가 아닌 ref로 나타남
                    *const, eq_ref, ref 모두 동등비교연산자 이어야함!( ex) = ...) 인덱스 분포도만 적절하면 튜닝할 필요없는 상태! 

                    -fulltext : 전문검색 인덱스.. match ~ against ~ 를 사용하게됨.. 텍스트를 어떻게 쪼개서저장하고있는지 구분자를 어떻게 둘것인지를 잘 셋팅하면 TEXT타입으로 데이터가 많이 들어가있을때 검색에 유리,, range가 보통 더 빠르다함
                    -ref_or_null : ref와 접근방식동일한데 null 추가된것임 ("=" + "OR" + "IS NULL")
                    -unique_subquery : IN(subquery) 형태의 쿼리를 위한 접근 방식.. 서브쿼리에서 중복되지않은 유니크한 값만 반환될때 이 접근방법을 사용하나, mysql 5.5(mariadb10.0) 부터는 IN(서브쿼리) 방식을 join으로 접근하도록 개선되어서 unique_subquery와 index_subquery는 보기 쉽지않음!
                    -index_subquery : IN(subquery) 에 중복값이 있을때, 인덱스를 이용해 중복값을 제거하는 접근.. 비용이 크지않지만 중복값을 제거하는 비용이 있긴함.. 위에서 이야기했듯이 개선된 옵티마이저는 이를 join으로 접근해서 보기힘듬
                    -range : 인덱스 레인지 스캔 형태의 접근방법,, 인덱스를 범위로 검색! 이 접근방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 어느정도의 성능은 보장된다할수있다함.. ex) < , > , Between, IN, LIKE, IS NULL, 동일환컬럼으로 OR 등 
                    *인덱스 레인지 스캔(혹은 레인지스캔)이라하면 const,ref,range 세가지 접근 방법을 모두 묶어서 지칭..

                    -index_merge : 2개 이상의 인덱스를 이용해 각자의 검색결과를 만들어 낸후 그 결과를 병합하는 처리방식.. 생각보다 효율적이지 않다함..(AND와 OR 연산이 복잡하게 연결된 쿼리에서 제대로 최적화 안됨, 여러 인덱스를 읽어야하므로 range방식보다 후질수있음,, 처리된 결과가 두개이상의 집합이될텐데, 이때 교집합이나 합집합 또는 중복제거와 같은 부가적인 작업이 필요..)
                    -index : 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미! 인덱스의 필요한 부분만 읽는 range와는 다르다!!!!! 느려!
                        -그래도 풀테이블스캔보다는 빠를수있음,, 
                            -데이터 파일 전체보다 인덱스가 크기가 작으니깐
                            -인덱스 페이지는 정렬되어있으니께!
                            -select하는 값이 인덱스값이라 굳이 데이터페이지까지 안가도되면.. 
                    -ALL : 인덱스 아예 안탄것.. 이 외에는 모두 index 탄것임
                        -테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거하고 반환..
                        -대량의 디스크 IO를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어들이는 기능이 InnoDB에 있음.. 이를 Read Ahead라함
                            -Read Ahead : 페이지가 연속해서 몇번 읽히게 되면 백그라운드로 작동하는 읽기 스레드가 최대 한 번에 64개의 페이지씩 한꺼번에 디스크로부터 읽어들이기 때문에 한번에 페이지 하나씩 읽어들이는 작업보다는 상당히 빠르게 레코드를 읽을수 있음

            -possible_keys 컬럼
                -사용될법한 인덱스들의 목록.. 실제 사용된것이 아님.. 무시해도됨
            
            -key 칼럼
                -여기에 표시되는 인덱스가 실제 사용된 인덱스
                -쿼리 튜닝시 여기에 사용되는 인덱스를 보고 의도했던대로 잘 되었는지 확인할것!
            
            -key_len 컬럼
                -다중 컬럼으로 만들어진 인덱스에서 몇개의 컬럼까지 사용했는지 알수있음.. ex) dept_no(char(4))와 emp_no(INT) 로 인덱스가 잡혀있을경우, dept_no만 사용했다면 key_len이 12로 나타나고 emp_no까지 사용했다면 16으로 적힌다 (INT는 4바이트, mysql의 utf-8은 char가 3바이트씩..)
                -mysql 5.1이상의 버전에서는 "컨디션푸시다운" 이라는것을 통해서 범위제한조건이든 체크조건이든 모두 스토리지엔진에서 처리가능하도록 만들어졌기때문에 key_len에 범위제한조건과 체크조건 모두 포함된 인덱스 길이가 나타난다
                    -mysql 5.1미만일때는 체크조건은 MySQL엔진에서 수행하기때문에 key_len은 범위제한조건만 나타난다. 즉, 두개의 컬럼으로 인덱스가 잡혀있어도, 범위제한 조건이 하나여서 하나의 컬럼만 사용하면 해당 길이만 나타난다..
            -ref 컬럼
                -참조조건("equal 비교"조건)으로 어떤 값이 제공됐는지 보여줌
                -상수값지정했따면 ref 컬럼은 const로 표시,, 다른 테이블의 컬럼값이면 그 테이블 명과 컬럼 명이 표시
                -func라고 지정될때가있는데, 이는 사용자가 명시적으로 변환을 했을때(ex. 수식을 넣어준다든가..) 혹은 내부적으로 Mariadb서버가 내부적으로 값을 변환해야할때 나타난다(ex. 숫자타입인데 문자타입으로 넣어줬을때.. 내부적으로 전환하는동작) 
                    -되도록이면 서버가 내부적으로 func 안하도록 해주는게좋음!!
            
            -rows 컬럼
                -통계정보를 참고하여 나타남.. 
                -예측값이라 아주 정확하진 않음..
                -레코드의 예측치가 아니라, 쿼리를 처리하기 위해 얼마 많은 레코드를 디스크로부터 읽고 체크해야하는지를 의미
                -rows가 많다면(실제 테이블의 데이터와 유사하게 나온다면) 테이블풀스캔때릴것이고 아니면, 인덱스 태울것임..
            
            -extra 컬럼
                -종류
                    -full scan on null key
                        -col1 IN (SUBQUERY) 에서 col1이 null이 될수있을때, null이라면 fullscan을 한다는 것을 의미
                        -col1이 null이면 SUBQUERY에 값이 있으면 null로 반환되고 SUBQUERY에 값이 하나도 없으면 false가 된다.. 그리고 여기서 null일때는 full scan을 수행한다
                        -풀스캔을 막기위해서는 조건에 "col1 IS NOT NULL And col1 IN (SUBQUERY)" 로 조건을 주면된다!
                    -impossible ~~~
                        -데이터가 없거나(기초자료 없을때..) 쿼리에 문제가있다는것이니 확인할것!

                    -Not exists
                        -아웃터조인을 이용해 안티조인을 수행하는 쿼리에서 extra 컬럼에 not exists 메세지가 표시됨
                            -A테이블에는 존재하나, B테이블에는 존재하지 않는것을 조회할때 NOT IN, NOT EXIST, 아웃터조인등을 사용할수있는데, 이를 안티조인이라함
                        -not exists 쿼리문으로 변경했다는 의미가 아니다!! 내부적으로 안티조인에 맞게 최적화되었다는것!
                    -Range checked for each record(index map:N)
                        -각 레코드마다 레인지스캔을 때린다
                        -index map에 지정한 숫자 N은 16진수로 표시되는데, 이는 인덱스로 사용할애들을 이야기하는것
                            ex) 0x19이면, 11001 이므로, 첫번째인덱스(대개 PK), 4번째인덱스, 5번째인덱스가 사용되었다는것!(11001에서 맨 오른쪽부터가 첫번째인덱스)
                    
                    -using filesort
                        -적절한 인덱스 없을때 메모리버퍼에 복사해서 퀵소트로 정렬수행(MySQL엔진에서 처리)
                        -ORDER BY 사용시 나타나게되며, 되도록이면 인덱스를 태워서 별도의 메모리버퍼에 복사하지않도록 하는것이 좋다!
                        -너무 많아서 메모리에 충분치않으면 디스크로 가기때문에 많이 느려지는데, 그렇지않으면 괜찮다한듯..?

                    -using index
                        -커버링 인덱스라고도 부름
                        -인덱스를 사용해서 데이터 페이지까지 굳이 가지않아도 되는 상황,, 즉, 인덱스페이지에 select하려는 데이터가 포함되어있음!(select할때 인덱스 컬럼이 있거나, PK 컬럼이 있을때!! *PK컬럼은 보조 index 리프페이지에 함께들어있기때문에 가능!(index의 리프페이지에서 PK값으로 실제 데이터 페이지 찾아가게됨! PK값의 리프페이지가 데이터페이지이므로!))
                        -커버링 인덱스는 실행 계획의 type에 관계없이 사용가능.. 즉 어떤 type이던지 위의 상황에서 커버링인덱스로 사용되었으면 됨
                    -using index for group-by
                        -group by 처리가 "인덱스를 이용"할때 쿼리의 실행계획에서 나타남
                        -이를 "루스 인덱스 스캔"이라고함
                        -인덱스를 순서대로 쭉 읽는것(타이트 인덱스 스캔)이 아님! 필요한 부분만 듬성듬성 읽는것!
                            *타이트 인덱스 스캔 의 예 : count(*), SUM(), AVG() 과 같이 하나도 빠짐없이 필요한것 (이때는 위 문구 안나타남..)
                            *루스 인덱스 스캔의 예 : MAX, MIN 등
                        -where 절에 인덱스가 포함되어있지않고, group by 절에 인덱스가 포함되어있으면 타이트 인덱스 스캔이 일어남
                        -where 절에 인덱스가 포함되어있고, group by도 해당 인덱스 컬럼으로 조회하면 루스 인덱스 스캔이 일어남
                            -그러나 where절에서 데이터를 걸렀을때 데이터가 많지않으면 그냥 타이트 인덱스 스캔이 일어나고, 데이터가 많으면 루스인덱스 스캔이 일어남..!(옵티마이저가 비용계산해서..)
                    -using sort_union(...), using union(...), using intersect(...)
                        -index_merge 사용시 두개 이상의 인덱스를 사용하여 어떻게 병합했는지를 알려줌
                        -using intersect(...) : 인덱스를 사용하는 조건이 AND 로 연결되는 경우, 각 처리결과에서 교집합으로 추출해내는 작업할때
                        -using union(...) : 인덱스를 사용하는 조건이 OR로 연결된 경우, 각 처리 결과에서 합집합을 추출해내는 작업할때
                        -using sort_union(...) : using union과 같은 작업을 수행하지만, 합집합할 대상이 많을때 내부적으로 PK로 정렬수행후 병합한뒤 데이터 가져옴(그냥 using union은 데이터 다 가져온다음 병합수행)

                    -using temporary
                        -임시테이블이 생성되었다는뜻!
                        -디스크에생성되었는지, 메모리에 생성되엇는지는 알수 없음
                        -이게 extra컬럼에 나타나지않았다고 해서 임시테이블이 생성되지않았다는 뜻은 아님!!
                            *임시테이블이 생성되는경우
                                -FROM절에서 사용된 서브쿼리
                                -COUNT(DISTINCT column)를 포함하는 쿼리도 인덱스를 사용할수 없는 경우에 임시테이블 만들어짐
                                -UNION 이나 UNION ALL이 사용된 쿼리(임시테이블 만들어서 결과병합)
                                -인덱스를 사용하지못하는 정렬작업.. using filesort(꼭 그런건 아님.. 드라이빙테이블의 컬럼값으로 정렬하면 임시테이블 생성안한다함.... 이랫다저랫다..ㅡㅡ)

                    -using where
                        -Mariadb(mysql)는 내부적으로 크게 Mariadb(mysql)엔진과 스토리지엔진(Innodb,MyISAM)으로 나뉘는데, 스토리지엔진은 디스크나 메모리 상에서 필요한 레코드를 읽거나 저장하는 역할을 하고, MariaDB(mysql)엔진은 스토리지 엔진으로부터 받은 레코드를 가공또는 연산하는 작업을 수행한다
                        -이때, MariaDB(mysql)엔진에서 별도의 가공이나 필터링을 수행하게되면 using where이 extra 컬럼에 나타난다
                        -세부적으로 explain extended의 filtered 컬럼에서 using where이 성능상에 이슈를 주는지 알수있음!!!
                    
                    -using index condition
                        -WHERE 조건절을 가진 쿼리가 실행될때, WHERE 절의 조건이 인덱스를 사용할수 있다면 먼저 인덱스를 읽어서 조건에 부합되는지 여부를 판단하여 필요시 데이터 파일의 레코드를 읽는것!
                            => 범위제한조건은 스토리지엔진에서, 체크조건은 MySQL엔진에서 진행되었으나, 체크조건또한 스토리지엔진에서 진행한다!!!
                        - 예를들어 first name 이라는 컬럼에 인덱스 잡혀져있을때, WHERE first_name like 'LEE%' AND first_name like '%matt' 라고 되어있을떄
                            MariaDB 10.0 이전에는 스토리지 엔진에서 like 'LEE%' 만 확인하여 데이터페이지의 모든 컬럼 데이터를 가져온뒤 MariaDB 엔진에서 %matt에 대한 처리를 해주었다.. 그래서 extra 컬럼에 using where이 적혀있었음
                            그러나 10.0 이후에는 스토리지 엔진에서 LEE% 뿐 아니라 %matt에 대한 처리도 하여 데이터페이지에 필요한 컬럼의 값들을 가져오게되었는데, 그때 extra 컬럼에 using index condition이라고 나타남
                    -rowid-ordered scan, key-ordered scan
                        -어느정도 인덱스를 통해서 읽다가 PK로 정렬해서 데이터를 가져오는것..
                            -클러스터 인덱스는 리프페이지가 데이터페이지므로 범위조건 검색에 PK로 검색하면 데이터페이지 왔다갔다하는 비용을 상당히 줄일수있으니 개이득
		    -Select tables optimized away
                -완전 최적화된 쿼리.. 이보다 빠를순없다..
                -Max나 Min값이 인덱스를 탔을때 나타나거나 count(*)와 같이 바로 갯수만 세면 되는것들..
                -MySQL 공식 문서 내용 : The query contained only aggregate functions (MIN(), MAX()) that were all resolved using an index, or COUNT(*) for MyISAM, and no GROUP BY clause. The optimizer determined that only one row should be returned.
                -이거 관련해서 상당히 자세하게 분석해놓음 : https://blog.naver.com/PostView.nhn?blogId=pjt3591oo&logNo=221030483713

    -explain extended
        -filtered 컬럼추가
            -스토리지엔진에서 넘어온 레코드가 Mariadb엔진에서 얼마나 걸러졌는지를 알려줌
            -20이면 Mariadb에 의해서 20%가 남았다는뜻.. 즉, 100개 데이터중에 80개 걸러져서 20개 남았다!
                -100이면 하나도 걸러지지않고 100% 넘어온것
            -단순히 통계정보로 예측된값이라 매우 정확하지않음
        -추가 옵티마이저 정보 알수있음
            -explain extended실행후 SHOW WARNINGS 명령을 날리면 옵티마이저가 분석해서 다시 재조합한쿼리문장을 볼수있음.. 알아보기 어렵기도하지만 쿼리를 어떻게 해석했고 어떤 처리를했는지 알수있으니 유용함!
    -explain partitions
        -partition 컬럼추가
            -어떤 파티션에서 조회해오는지 partition 컬럼에서 확인가능
            -extended와 같이 사용 못함


-쿼리실행절차
    1) 사용자로부터 요청된 SQL문장을 Mariadb가 이해할수있는 수준으로 쪼갠다(파스트리 parse tree)
        -"SQL파서" 라는 모듈이 파스트리를 만들어줌.. 여기서 SQL이 문법적으로 잘못됐다면 걸러줌
        -즉, Mariadb는 SQL문장 그 자체가 아니라, SQL파스트리를 통해서 쿼리를 실행!
    2) SQL의 파싱정보(파스트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
        -최적화 및 실행계획수립단계!,, 옵티마이저에서 처리함! 여기서 실행계획인 만들어짐..

    3) 두번째 단계에서 결정된 것을 토대로 스토리지엔진으로부터 데이터를 가져온다 + MySQL엔진에서 스토리지 엔진으로부터 받은 데이터 조인 또는 정렬
        *스토리지엔진 : 여기에 InnoDB, MyISAM, Memory.. 등이 있음
    
    => 1,2번은 주로 MySQL 엔진에서 주로 수행하고, 3번은 스토리지엔진과 MySQL엔진에서 주로 수행된다..


    Connection API <-> Connection Handler <-> SQL인터페이스, SQL파서, SQL 옵티마이저, 캐시&버퍼 <-> 스토리지엔진 <-> Disk파일시스템, 데이터 및 로그 파일


-옵티마이저 힌트
    -옵티마이저에게 쿼리의 실행계획을 어떻게 수립해야할지 알려주는것
    -종류
        -STRAIGHT_JOIN
            -select문장 바로 뒤에사용..
            -쿼리에 명시된 테이블대로 join 됨.. 즉 첫번째에 명시된 테이블이 드라이빙테이블
                ex) select STRAIGHT_JOIN 컬럼
                    from A
                        join B
                        join C
                            ON ~~
                    이렇게 되어있다면 조인순서는 (A -> B -> C) 이렇게됨
            -Where 조건에 나오는 값까지 포함해서 그 조건에 만족하는 레코드 건수가 적은 테이블부터 읽도록 하는게좋음(언제나 join 대상 즉, 드리븐 테이블에는 on절의 조건에 맞도록 인덱스 지정필수!)
                -드라이빙 테이블은 보통 인덱스 지정안되어있으면 옵티마이저가 선정함.. 그리고 인덱스 둘다 지정안되어있으면 레코드 갯수 적은것!(여기서도 where 조건이후의 레코드 건수임)
            -MariaDB의 옵티마이저는 STRAIGT_JOIN을 사용하면 앞뒤재지않고 고대로, 아무리 겁나 비효율적이라해도 사용자가 지정한 순서대로 읽으므로 주의할것
        
        -USE INDEX / FORCE INDEX / IGNORE INDEX
            -테이블 뒤에 사용
            -보통은 옵티마이저가 인덱스를 알아서 잘 고르지만, 3~4개 이상의 컬럼을 포함하는 비슷한 인덱스가 여러개있을때는 옵티마이저가 이상하게 지정할때가있음.. 그때는 강제로 특정인덱스 사용하도록 지정해주는게좋음
            -PK 사용하고싶으면 PRIMARY 라고 하면됨
            -USE INDEX, FORCE INDEX : 해당 인덱스를 사용하라고 옵티마이저에게 권하는것.. 보통 옵티마이저가 사용하지만 선택을 반드시 하는것은 아니다(두개의 차이는 옵티마이저에게 권하는 강도의차이인데 크게 차이는 없다함..)
            -IGNORE INDEX : 해당 인덱스는 사용하지말라고하는것,,, 테이블풀스캔 유도할때 사용함
            -용도도 표시해줄수있음(이는 크게 고려하지않아도됨)
                -USE INDEX FOR JOIN : JOIN이라는 키워드는 조인뿐만 아니라 레코드를 검색하기위한 용도까지 포함.. MariaDB는 한건의 레코드도 JOIN이라고 표현되기때문!
                -USE INDEX FOR ORDER BY : ORDER BY에서만 사용할수있도록..
                -USE INDEX FOR GROUP BY : GROUP BY에서만 사용할수있도록..
        
        -SQL_NO_CACHE
            -select 문장 바로 뒤에사용
            -쿼리의 성능을 테스트하는데에 있어서 반드시 필요
                -기본적으로 select하는데 오랜시간 걸렸다하더라도 다시 동일한 쿼리를 실행하면 쿼리캐시에 의해서 빠르게 결과값을 가져온다.. 이를 사용하면 쿼리의 정확한 테스트가 어렵기때문에 이를 사용하여 테스트를 진행하는것이좋다
            -select 문장에서만 사용가능


*count(*)이 빠른것은 건수만 가져오기때문에 실제 데이터를 찾아가기위한 "랜덤 I/O" 가 발생하지않기때문이다(인덱스를 타게되면 인덱스 페이지에서 다 카운팅하기때문에 빠름)

-실행계획 분석시 주의사항
    -select_type 컬럼의 주의사항
        -DERIVED : From 절에 사용된 서브쿼리로부터 발생한 임시 테이블을 의미.. 임시테이블은 메모리에 저장될수도있고 디스크게 저장될수도있는데, 데이터의 크기가 커서 디스크에 저장된다면 성능이 떨어진다..
        -DEPENDENT SUBQUERY : 서브쿼리가 자체적으로 실행되지 못하고, 외부쿼리에서 값을 전달받아 실행되는 경우.. 서브쿼리가 먼저 실행되지못하고 외부쿼리의 결과값에 의존적이기때문에 전체적인 쿼리의 성능을 느리게 만든다...

    -type 컬럼의 주의사항
        -ALL, index : 둘다 전체 레코드를 대상으로 하는 작업방식이라 OLTP환경에서는 해당 실행계획이 보인다면 인덱스를 추가하거나 변경이 필요하다

    -key 컬럼의 주의사항
        -인덱스 사용못할때 아무것도 안보임.. 인덱스 태울수있도록 인덱스만들던, where 조건문 잘 사용할것

    -Rows 컬럼의 주의사항
        -실제 가져오려는 레코드 수보다 훨씬 많은 수가 찍혀있다면 쿼리가 인덱스를 정상적으로 사용하고있는지, 인덱스가 충분히 작업범위를 좁혀 줄수있는 컬럼으로 구성되어있는지 확인해야함!
        -Rows 컬럼은 limit을 고려하지않기때문에 Limit 1로 하였을경우 rows가 1이 아니다!
    -Extra 컬럼의 주의사항
        -쿼리의 실행계획이 좋지않은경우
            -Range checked for each record
            -using filesort
            -using join bufffer
            -using temporary
            -using where (이는 Rows에 나타나있는 값과 실제 select되는 레코드수를 같이 비교해야함)
        -쿼리의 실행계획이 좋은경우
            -Distinct
            -Using index : 커버링 인덱스로 처리되고잇는것! Mariadb에서 제공할수있는 최고의 성능이라함!
            -Using index for group-by

/* select#1 */ select count(0) AS `count(*)` from `employees`.`employees` `e1` 
where `employees`.`e1`.`first_name` = (/* select#2 */ select `employees`.`e2`.`first_name` from `employees`.`employees` `e2` where `employees`.`e2`.`last_name` = 'Matt')


-최적화(MySQL의 주요 처리 방식)
    -MariaDB(mysql) 엔진에서 데이터를 처리하게되면 성능에 미치는 영향력이 큰데, 쿼리의 성능을 저하시키는데 한몫하는 경우가 많다.. 스토리지엔진으로 부터 받은 데이터를 MariaDB엔진이 아무런 가공 작업하지않고 사용자에게 전달한다면 최상의 성능을 보장하는 쿼리가 되겠지만, 그렇게 되기가 쉽지않기때문에 최적화에 대해서 잘 공부해두면 더 좋은 쿼리가 나올수잇다!
    -풀테이블 스캔
        -상당히 오래걸리는작업..
        -InnoDB나 XtraDB는 리드 어헤드(Read Ahead) 라는 작업을 통해서 버퍼 풀에다가 데이터를 가져다 놓는다.. 이를 통해 상대적으로 테이블 풀스캔에 대해 빠른 성능을 보장한다..
        -innodb_read_ahead_threshold 를 사용해서 얼마나 더 자주 리드 어헤드를 할지 설정할수있음
    
    -ORDER BY(using filesort)
        -인덱스를 사용하지않고 정렬을 수행해야할때 사용.. 인덱스를 사용하는게 당연빠르나, 레코드가 많지않으면 메모리에서 filesort가 처리되므로 충분히 빠름!
        -언제 나타나나?
            -정렬 기준 너무 많아서 요건별로 모두 엑세스를 생성하는것이 불가..(모두 인덱스를 태울수없으므로..)
            -GROUP BY의 결과 또는 DISTINCT와 같은 처리의 결과를 정렬해야하는 경우
            -UNION의 결과와 같이 임시테이블의 결과를 다시 정렬해야하는경우
            -랜덤하게 결과레코드를 가져와야하는경우(이건언제..?)
        -소트 버퍼(임시테이블이랑은 다르다!!)를 통해서 정렬을 수행하게되는데, 데이터가 소트버퍼의 크기보다 클때는, 디스크에 임시로 저장해놨다가 정렬을 수행한다.. 그래서 느려진다.. 그러나 소트버퍼의 값을 한없이 늘린다고 좋은게아니다.. 세션별로 생성이 되기때문에 너무많이늘리면 OS의 메모리 부족현상이 나고 OS는 가장 점유를 많이하고있는 프로세스를 kill하기때문에 DB가 뻗을수있다..
            -쿼리실행완료시 소트버퍼는 바로 반납
        -정렬알고리즘
            -싱글패스(최신): 한번에 필요 데이터 모두 가져오고 정렬수행 => 메모리 사용 상대적으로 많음, 레코드 적을때 유리 
            -투패스(구식): 정렬 대상 컬럼과 PK를 먼저 데이터 파일에서 가져온뒤 정렬수행하고 다시 테이블 읽어서 나머지 필요데이터 가져옴 => 메모리 사용 상대적으로 적음,, 레코드 많을때 유리 
            => 보통 싱글패스를 사용하나, BLOB, TEXT 타입의 컬럼이 SELECT 대상에 포함될때 + max_length_for_sort_data 파라미터로 설정된 값보다 클때 투패스 사용!
        -SELECT시 *을 사용하여 모든 컬럼을 가져오는것은 정렬버퍼의 입장에서 결코 좋지않은 영향을 미친다.. 왜냐하면 가져오는 데이터의 크기가 커질수록 정렬하는데에는 부담이 가게되기때문!
        -정렬처리 방식
            -인덱스를 사용한 정렬
                -조인과 함께 사용될때, 클러스터 인덱스 컬럼을 가지고 WHERE 조건문에서 검색하고, ORDER BY도 해당 컬럼으로 진행한다면, 정렬이 이미 되어있기때문에 별도의 정렬이 필요없다.. 그러니 겁나 빠를것이다..
                    -인덱스 + 네스티드 루프 => 검색시 자동정렬! but 해시인덱스나 전문검색은 정렬x.. 또한 조인버퍼가 사용되면 정렬보장안됨
                -extra에 별도 내용 표기안됨
            -드라이빙 테이블만 정렬(조인이 없는 경우 포함) : extra 컬럼에 "Using filesort" 가 표시
                -인덱스가 없다면 이게 효과적!!
                -인덱스가 없는 컬럼을 정렬해야하는 경우 드라이빙 테이블의 컬럼으로 정렬을하는게좋다..!!
                -***"드라이빙 테이블을 인덱스 없는 컬럼"***으로 sort한 뒤(sort buffer에서 수행) 조인 수행
                -정렬이 이루어진 이후에 조인하기때문에 밑에보다 상대적으로 더 적은 레코드를 정렬! 좀더 빠름!

            -조인결과를 임시테이블로 저장한 후, 임시테이블에서 정렬 : extra 컬럼에 "Using temporary; Using filesort"가 같이 표시..
                -***"드리븐 테이블의 컬럼"***으로 ORDER BY를 한경우..
                -이는 조인한 결과값을 가지고 임시테이블을 만든뒤 sort하여 결과데이터를 전달한다..
                -정렬해야할 레코드가 제일 많기 때문에 느리다!!!
        
            -JDBC 같은 경우, MariaDB에서 스트리밍방식으로 주나, 버퍼를 채워서 요청에 반환하기때문에 느리다함.. 스트리밍방식도 있다고하는데.. 디스크에서 데이터를 조회해오는데 시간이 많이걸릴듯한데.. 이게 많은 차이가있을지..?(확인필요..)
            -인덱스를 사용하지못하고 filesort를 진행하게되엇는데, 만약 1000건 중에 LIMIT 10으로 조건을 주었다면 1000건은 모두 정렬하고 10건만 가져오는것이 아니라 10건이 채워지면 바로 리턴을 준다.. 이게 성능적으로 1000건을 소팅하는것보다는 성능이 괜찮겠지만 어쨋든 퀵소트 알고리즘을 사용하기때문에 이에대한 비용이 적용이된다.. 그렇기때문에 최대한 인덱스를 사용하는것이 좋음!!


            -퀵소트 알고리즘 알아볼것!
            -ORDER BY .. LIMIT n 최적화  //////////// 무슨말 ???????
                -ORDER BY절을 가진 쿼리가 인덱스를 사용하지 못할때, 서버에서 실시간 정렬(Using filesort)을 수행해야한다. 소트버퍼에서 퀵 소트 알고리즘을 수행함.. 만약 이때, 레코드가 너무 많으면 계속 소팅하고 병합하는 작업이 이어진다.. 이는 CPU와 디스크에 많은부담!
                -이에 MYSQL은 소트버퍼의 크기보다 작은 경우에 우선순위 큐를 만들고 그 큐를 이용해서 정렬을 수행.. 이렇게 우선순위 큐를 이용하면 퀵 소트 알고리즘으로 900건의 결과를 모두 정렬할 필요가 없으며 단순히 employees 테이블의 레코드를 하나씩 읽어서 우선순위 큐에만 넣어주면된다..
                즉, 소트 버퍼의 크기가 256KB이므로 조회한 데이터가 이보다작으면 그냥 큐에넣고 sort해서 빠르게 결과값 가져간다는것!

    -GROUP BY
        -GROUP BY에 사용되는 조건절(HAVING)은 튜닝하려고 인덱스를 고민할필요없음..(여기서는 인덱스 안탐)
        -타이트 엔덱스 스캔
            -GROUP BY 되는 컬럼에 인덱스가 생성되어있음
            -그룹함수(ex. SUM..) 사용시 임시테이블이 사용될수도있음(항상 사용되는것은 아님)
            -이미 인덱스를 통해서 GROUP BY를 하는것이기에 정렬되어있음.. 추가정렬필요 x
            -실행계획에서 extra 컬럼에 using index for group-by, Using temporary, Using filesort와 같은 코멘트 남기지않음!

        -루스 인덱스 스캔
            -단일 테이블에서 가능
            -분포도가 낮을수록 더 좋은 효과를 보임..(건너뛸 데이터가 많아지니깐)
            -별도의 임시테이블 필요없음
            -조건문이 루스인덱스 스캔에서 변경되는 예시
                where from_date='1985-03-01'
                group by emp_no;
             => where emp_no=10001 and for_date='1985-03-01', where emp_no=10002 and for_date='1985-03-01', where emp_no=10003 and for_date='1985-03-01' .... 와 동일하다!
            -실행계획에서 extra 컬럼에 using index for group-by 나타남 

        -임시테이블 사용하는 group by
            -group by의 컬럼이 인덱스 안잡혀있으면 임시테이블을 만들어서, 해당 임시테이블의 unique 값으로 group by의 컬럼값이 잡히게되고, 필요한 레코드의 값을 연산해서 데이터를 리턴한다
                -group by가 임시테이블로 처리되는 경우 사용되는 임시테이블은 항상 유니크 키를 가진다! 그니까 더 느리다!
        
    -DISTINCT
        -DISTINCT 가 인덱스를 사용하지 못할때는 "항상" 임시테이블 필요(하지만 Extra 컬럼에 Using temporary 표시안댐)
            -인덱스있어도 임시테이블만든다....
        -정렬보장안됨.. 아래 두 문장은 내부적으로 같은작업을 수행하나 정렬의 차이만 있음(group by든 distinct든 인덱스를 사용하면 모두 정렬된다.. 왜 이렇게 나눳지..?)
            SELECT DISTINCT emp_no FROM salaries;  -- 정렬안됨
            SELECT emp_no FROM salaries GROUP BY emp_no;  -- 정렬됨 (GROUP BY .. ORDER BY NULL 이런거 봤을때 group by는 내부적으로 정렬을 따로 수행하는듯함.. distinct는 아예 이런 신경을 안쓴다는거일듯!)
        -SELECT DISTINCT col1, col2 ..
            => 이는 col1만 유니크하게 Select 하는것이 아니라, col1과 col2 를 합쳐서 유니크하게 select하는것이다!! 
                일부컬럼만 유니크하게 가져오는 방법은 "없다"
        -COUNT,MIN,MAX와 같은 집합함수에서 DISTINCT 여러번쓰면 DISTINCT쓴만큼 임시테이블 만들어짐..
        


    -임시테이블(Using temporary)
        -***정렬이나 그룹핑할때는 임시테이블이 생성이되는데, 이러한 작업은 "MySQL엔진"에서 이루어진다!***
        -create temporary table로 만든 임시테이블과는 다르다!
        -쿼리 수행하면 바로 삭제됨..
        -임시테이블이 메모리를 사용할때는 MEMORY 스토리지 엔진을 사용하며, 디스크에 저장될때는 Aria 스토리지 엔진을 이용(Mariadb)
            -MySQL은 디스크에 저장될떄 MyISAM 엔진 사용
        -일반적으로 Using temporary가 실행계획의 extra 컬럼에 나타나면 임시테이블이 만들어지는것으로 보면되는데, 꼭 그렇게 표시가 안되어도 내부임시테이블이 만들어질수잇다
            -> 가장 확실한것은 " show session status like 'Created_tmp%tables'; " 이 문장으로 확인해볼것 
        -임시테이블에 유니크 인덱스를 걸어놓는데, 이는 유니크 인덱스가 없을때보다 처리성능이 느림
        -디스크에 저장되는경우는 TEXT나 BLOB와 같은 대용량 컬럼이있는경우나 SELECT되는 컬럼중에 512바이트 이상일때, GROUP BY나 DISTINCT 컬럼에서 512바이트 이상인 크기의 컬럼, 임시테이블에 저장할 데이터의 전체크기가 tmp_table_size 또는 max_heap_table_size 시스템 설정 값보다 큰 경우
        -버전이 업그레이드됨에따라(Mysql5.5이상) derived(파생테이블)에 인덱스를 줄 수 있음.. join 쿼리시 성능향상을위해
        -SELECT * FROM employees GROUP BY last_name ORDER BY first_name;  (extra 컬럼에 using temporary; Using filesort 라고 적힘)
            => 동작순서
            1) employees 테이블의 모든 컬럼을 포함한 임시테이블을 생성(MEMORY 테이블)
            2) employees 테이블로부터 첫번째 레코드를 InnoDB 스토리지 엔진으로부터 가져와서 
            3) 임시테이블에 같은 last name이 있는지 확인
            4) 없다면 임시테이블에 insert
            5) 있으면 임시테이블에 update 또는 무시
            6) 임시테이블의 크기가 커지면 임시테이블을 Aria 스토리지 엔진을 이용해서 디스크로 이동
            7) employees 테이블에서 읽을게 없을때까지 2~6반복(해당쿼리에서는 30만회 => 모든 레코드)
            8) 최종 내부 임시테이블에 저장된결과에 대해 정렬 작업을 수행
            9) 클라이언트에 결과반환
        *참고로 group by에서 sum을할때 반드시 임시테이블을 만드는것은 아님..!(인덱스 있으면 안만들더라..)
        -Memory(HEAP) 테이블의 모든 컬럼은 고정크기 컬럼!!! 그렇기 때문에 TEXT나 BLOB가 필요하지않다면 select하지말것!!
            ex) varchar(512)에 utf8이면 512*3 바이트 차지.. 그리고 한글자만 들어있어도 고정이라 512*3 바이트 차지..
        -아래의 쿼리로 임시테이블이 디스크에 생성했는지 메모리에 생성됐는지 확인가능
            -SHOW SESSION STATUS LIKE 'Created_tmp%'
                -created_tmp_tables : 임시테이블이 메모리던 디스크던 계속 누적해서 올라감
                -created_tmp_disk_tables : 임시테이블이 디스크일때만 누적해서 올라감

    -index condition pushdown
        -인덱스를 가지고 비교하는작업은 스토리지엔진에서 가능한데, "인덱스의 컬럼이라도 인덱스를 온전히 사용하기가 어려운경우" (ex. 인덱스컬럼 like '%abc' )는 Mariadb 엔진이 다시한번 필터링을 해야했다.. Mysql5.6 이상부터는 해당 내용을 ***인덱스에만 포함되어있는 컬럼***이라면 스토리지엔진에서 처리하도록 변경해주었음!
    
    -멀티 레인지 리드(Multi Range Read)
        -넌 클러스터드 인덱스를 사용하여 여러 컬럼의 여러 레코드를 조회하게되었을때 랜덤엑세스가 상당히 많이 발생된다(인덱스의 리프페이지가 클러스터 인덱스의 키를 가리키고 그 키를 따라 데이터 페이지를 가게되는데, 같은 데이터 페이지에 있는 데이터라 할지라도 한번에 다 못읽고 계속 레코드 건수마다 access 하게됨)
        -이런 랜덤IO를 줄이기위해서 멀티 레인지 리드, 줄여서 MRR을 도입하였음..
        -이는 인덱스 튜플을 적정한 양만큼 읽은 후 그 튜플을 rowid(클러스터 인덱스) 순서대로 정렬해서 데이터 파일의 레코드를 읽는것!(이렇게 되었을때 동일 데이터페이지는 한번에 가져올수있기에 레코드 건건마다 왔다갔다안해도되고, 버퍼 풀에 남아있을수있기때문에 더 빠르게 가져올수있다함)
        -extra 컬럼에 다음 3가지로 나타남
            -Rowid-ordered scan
                -조인이 수행되는 쿼리에서 드리븐 테이블을 읽을때 멀티 레인지 리드가 적용되는 방식!
                -드리븐 테이블의 join 컬럼을 MRR버퍼에서 정렬하고 데이터 가져옴
            -Key-ordered scan
                -조인이 수행되는 드라이빙 테이블을 읽은 후 조인 컬럼을 정렬해서 그 순서대로 드리븐 테이블을 읽는 최적화 방법
                -드라이빙테이블의 조인되는 컬럼을 MRR 버퍼에서 정렬한후 드리븐 테이블의 데이터가져옴
                    -드리븐 테이블에서 조인되는 컬럼이 PK(클러스터인덱스) 여야함
            -key-ordered rowid-ordered scan
                -위의 두개가 짬뽕된것.. 
                -join 컬럼이 드리븐 테이블 컬럼의 넌 클러스터드 인덱스면 구현가능
                    -드리븐 테이블의 인덱스 페이지에 정렬되어 접근하고, 드리븐 테이블이 다시 클러스터인덱스에 맞춰 정렬한뒤 데이터 조회
        -주의사항
            -적은 레코드일때는 MMR 더 느림
            -mmr과 mmr_sort_keys 옵션을 활성화해야함


    -index_merge(인덱스 머지)
        -하나의테이블에서 두개이상의 인덱스를 이용한것!
        -여러개의 where 조건 절이 있을때 각각의 조건들이 서로다른 인덱스를 사용하는데, 각각의 조건을 만족하는 레코드 건수가 많을것으로 예상되면 mariadb는 인덱스 머지 를 실행!
        -쉽게 이야기하면 조건에 맞는 인덱스 태워서 레코드 가져온뒤 병합하는것!
        -종류
            -using union
                -합집합
                -두 집합의 결과를 합칠때 중복되는 레코드가 나올수 있는데, 이는 "우선순위큐" 라는것을 통해 중복제거..(우선순위큐는 나중에 동작하는것을 한번 찾아볼것!)
                -또한 우선순위큐를 사용할수잇는것은, 이미 합치기 전의 데이터들이 정렬되어있기때문에 가능한것! (클러스터 인덱스가 있는 데이터들에 대해 넌클러스터드 인덱스들로 찾았을때..)
                
            -using sort_union
                -합집합
                -우선순위 큐 사용x, 동등비교가 아니라 범위조건은 해당 컬럼으로 정렬이 되기때문에 다시 내부적으로 정렬이 필요하다! 이때 using sort_union
                    -클러스터 인덱스가 있으면 (해당컬럼+클러스터인덱스 컬럼)으로 정렬
                    ex) hire_date가 2020-11-10 ~ 2020-11-20으로 검색한다면, 2020-11-10 은 PK로 정렬되어있고, 다음 2020-11-11 범위안에 PK로 정렬되어있음,, 아무튼 순서는 hire_date가 기준이기함..
            -using intersect
                -교집합!
                -방식은 using union과 동일!
    -테이블 조인
        -조인알고리즘
            -조인 캐시 레벨(join_cache_level)
                -설정하는 정수값에 따라 아래 종류의 알고리즘을 어디까지 사용할수있을지를 정함
                -알고리즘 종류 (아래 알고리즘 사용을 위해서는 p311 참고해서 기타 설정값들도 셋팅이필요함)
                    1) 블록 네스티드 루프(flat)
                    2) 블록 네스티드 루프(increment)
                    3) 블록 네스티드 루프 해쉬 (flat)
                    4) 블록 네스티드 루프 해쉬 (increment)
                    5) 배치 키 엑세스 (flat)
                    6) 배치 키 엑세스 (increment)
                    7) 배치 키 엑세스 해쉬 (flat)
                    8) 배치 키 엑세스 해쉬 (increment)
            -join 종류
                -조인버퍼 사용x
                    -단순 네스티드 루프
                        -일반적인 웹서비스용의 OLTP(OnLine-Transaction Processing) 에서 주로 사용.
                    -인덱스를 이용해서 join 문 사용하는경우는 대부분 단순 네스티드 루프(드라이빙 테이블의 가장 바깥 for문으로 시작해서 안쪽으로 드리븐 테이블의 레코드를 검색하는 식으로 루프를 돈다)
                    -OUTER JOIN을 사용할때 조심해야할 부분이있는데, ***on절에 조건을 명확히*** 넣어야한다
                        -예를들어 from tab1 left join tab2 on tab1.key=tab2.key " and tab2.col='abc' " 와 from tab1 left join tab2 on tab1.key=tab2.key " where tab2.col='abc' " 는 다르다!
                        -전자는 네스티드 루프를 돌때 조건에 들어갔기때문에 tab2.col이 abc가 아닌것들도 null이 나올것이고, 후자는 inner join과 동일하게취급된다!(null이 없으니 실행계획에서 걍 inner join으로 'abc' 찾는정도로 생각함)
                -조인버퍼 사용
                    -블록 네스티드 루프(flat)
                        -블록(block) 이라는것은 조인용으로 별도의 버퍼가 사용되었다는것!
                        -BNL 방식은 조인 칼럼에 적절한 인덱스가 없을 때 수행될 수 있는 방식
                        -보통 카테시안 조인일때 사용이 되는데, 만약 조인버퍼를 사용하지않으면 드라이빙 테이블에서 걸리진 레코드만큼 드리븐테이블에서 데이터 가져오는 작업이 이루어짐.. 중복될것임..
                        -extra필드에 Using Join buffer 라는 분구가 표시됨
                        -조인 버퍼에 드라이빙 테이블의 데이터를 넣고 드리븐테이블과 join
                            =>드리븐 테이블이 드라이빙 테이블이 되고 조인버퍼가 드리븐테이블이됨
                    -블록 네스티드 루프(increment)
                        -조인 버퍼에 레코드를 통째로 저장하는것이 아니라 포인터만 저정
                        -3개이상의테이블에서 기존에 조인버퍼로 사용된 데이터가 있다면 다음 조인버퍼에서는 포인터로 지정하여 데이터가 중복되서 저장되지않도록함
                    -블록 네스티드 루프 해쉬 (flat)
                        -동등비교 조건에서만 사용
                        -해시 조인 순서
                            1) 빌드단계
                                -일반적으로 레코드 건수가 적은 테이블에서 조인 컬럼의 해시값을 계산하여 그 값으로 해시 테이블을 생성(조인버퍼에 생성)
                            2) 프로브단계
                                -남은 테이블(드리븐테이블?)의 조인 컬럼의 해시를 계산해서 빌드단게에서 만들어진 해시 테이블을 검색하여 최종 조인 결과를 만들어냄
                        -조인 버퍼 사이즈(join_buffer_size) 보다 크다면, 빌드와 프로브단계를 여러번 반복해서 실행
                        -대용량에 적합하고, 웹 기반의 OLTP서비스와 같이 적은 레코드 건수로 join을 하게되면 네스티드 루프 조인이 더 빠름..
                    -블록 네스티드 루프 해쉬 (increment)
                    -배치 키 엑세스 (flat)
                        -MRR 사용하는것
                    -배치 키 엑세스 (increment)
                    -배치 키 엑세스 해쉬 (flat)
                    -배치 키 엑세스 해쉬 (increment)

            -조인시 주의사항
                -정렬이 필요하면 ORDER BY는 항상 명시할것! 성능저하안된다!(기존에 이미 정렬을 수행했다면 명시해놔도 사용안함)

    -서브쿼리
        -세미조인 서브쿼리 최적화
            -SELECT .. 
             FROM outer_tables
             WHERE expr IN (SELECT ... FROM inner_tables ...)
             => 이렇게 반쪽만 조인의 성격을 가지는 쿼리들도 조인이 "세미조인"
            
            -최적화 종류
                -Table pullout 최적화
                    -서브쿼리 안의 테이블을 outer table로 가져와서 조인하여 결과값 가져오도록 최적화하는 방법
                -FirstMatch 최적화
                    -아우터 쿼리가 독립적으로 인덱스를 적절히 사용할수 있는 별도의 조건을 가지고있으면서 서브쿼리가 사용된 경우에 자주선택
                    SELECT *
                    FROM employees e
                    WHERE e.first_name='Matt' 
                        AND e.emp_no IN(
                            SELECT t.emp_no FROM titles t
                            WHERE t.from_date BETWEEN '1995-01-01' AND '1995-01-30'
                        )
                    => e.first_name 조건이 인덱스 타고 데이터 걸리진 뒤에 titles 테이블과 조인!(emp_no) e 테이블이 드라이빙 테이블이기에, titles 테이블의 조건에 맞는것을 찾는데, 이때 조건절에 from_date 값이 맞는게 하나라도 발견되면 바로 해당 emp_no는 더이상 안찾음!(firstMatch 최적화!)
                    => 여기서 핵심은 e.first_name과 깉은 인덱스를 조건으로 두고있다는것!

                -Semi-join Materialization 최적화
                    -서브쿼리를 통째로 임시테이블로 저장하여 join을 수행하는것!
                    -위의 예에서 " WHERE e.first_name='Matt' " 문장을 제거하면 확인가능
                        => 서브쿼리에서 emp_no를 유니크키로 하여 임시테이블이 생성된다!! 그리고 임시테이블과 employees 테이블이 조인!
                    
                -LooseScan 최적화
                    -group by 최적화의 루스 인덱스 스캔과 유사함
                    -서브쿼리를 먼저 읽어서, 아우터 쿼리의 연결되는 컬럼의 중복데이터들을 제외..
                    -SELECT ... FROM ... WHERE expr IN (SELECT keypart1 FROM tab WHERE ...) //keypart1의 중복데이터는 빠르게 건너뜀..(loose scan 최적화가 적용되었기때문)
                    -SELECT ... FROM ... WHERE expr IN (SELECT keypart2 FROM tab WHERE keypart1='상수' ...)

                -DuplicateWeedout 최적화
                    -세미 조인 서브쿼리를 inner join 쿼리로 바꿔서 실행하고 마지막에 중복된레코드를 제거하는 방법을 처리되는 최적화알고리즘
                    -말 그대로 join과 같은 수행할 작업 다하고 중복된 데이터(duplicate)를 잡초 뽑듯이 제거(weed out) 하는것!

        -세미조인이 아닌 서브쿼리 최적화
            -Materialization
                -
            -IN-to-EXISTS
                -서브쿼리가 외부쿼리의 컬럼을 참조하는 상관 서브쿼리일때!(성능 후짐)
                -IN을 EXISTS로 변환해서 실행하는것!

        -서브쿼리 캐시 ???????????????
            -상관 서브쿼리의 경우 아우터쿼리의 실행 결과 레코드 건수만큼 서브쿼리가 반복적으로 실행이되는데, 이를 메모리 캐시에 담아두어서 서브쿼리 다시 실행하지않고 캐시내용을 즉시 리턴하는것!(내용이 잘 이해안감..)

where 조건문 인덱스로 정의되어있는 순서대로 컬럼을 사용해야하나.. 그렇게 만든 뒤 컬럼 앞이나 뒤에 인덱스 없는 컬럼와도 인덱스태운다.. (AND일때만!! OR는 아님!!.. 몰랏다..)

-스토리지 엔진
    -DML을 실행하면 Innodb 버퍼 풀(메모리)에 데이터가 변경되는데, 사용자가 결과 응답을 받는시점은 메모리에 데이터를 쓰게되엇을때이다. 즉, 디스크에 쓰는 타이밍이 아니라는것이다. DML을 통해 페이지에 기록(여기서 페이지는 Innodb 버퍼풀의 관리단위.. 한 페이지에 16KB.. 메모리에 올려져있음)이 되어있으나 아직 디스크에 반영이 안되어있는것을 dirty라고하고 이를 디스크에 쓰는것을 flush 라고 한다

    -"innodb_print_all_deadlocks" 시스템변수 를 ON으로 변경하면 deadlock 의 모든 이력이 에러로그에 남게된다..
        -SHOW ENGINE INNODB STATUS 는 가장 최근의 데드락밖에 안남음..