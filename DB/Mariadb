Mariadb

-만든사람의 셋째딸 이름 maria
-mysql과 클라이언트나 jdbc는 모두 호환가능(MySQL쓰는 사람들이 Mariadb쓰는데 불편함 없게하기위해!)
-mysql과 서버의 옵티마이저나 스토리지엔진에는 명확한 차이가 잇음!
-dump뜨고 source로 가져오는게 좋음(source는 mysql클라이언트로 접근해서 가능)
    -source는 진행상황볼수있음
    -mysql -u root -p < backup.dump 이런식으로 가져오면 화면상에 아무것도 출력안됨..

-userId와 ip가 같이 인증대상이다.. ex) 'root'@'127.0.0.1' 이건 127.0.0.1외의 ip는 접근불가.. 'root'@'%' root로 모든곳에서 접근가능,, 이 두개가 모두 등록되어있을때는 범위가좁은것이적용! 즉, 127.0.0.1

-CREATE DATABASE [DB이름] DEFAULT CHARATER SET [utf8mb4];
-SHOW CREATE TABLE 테이블명
    -desc와 같이 테이블에 대한 정보들 보여주나, 인덱스나 PK ENGINE 관련한것들도 볼수있다! create 하는 문장 고대로 보여줌!
-테이블 삭제시(drop table) 해당 테이블과 연관된 페이지는 버퍼 풀에서 제거되어야한다.. 그렇기위해서 해당 명령이 실행되면, 버퍼 풀의 모든 캐시페이지를 스캔하는데, InnoDB의 버퍼풀이 크고 사용량이 높다면 테이블 삭제에서 이 작업이 시간을 많이 소모하게된다.. 그런데 이보다 더 중요한부분은 물리적인 데이터파일을 삭제하는데있어서 파일시스템이 EXT3이면 파일의 삭제가 많은 시간을 소모한다(XFS는 좀 빠르다함..) 




-설정관련
    -버퍼 풀 사이즈는 전체 메모리의 50~80프로 권장

-권한
    -특정 테이블이나 열에 권한을 부여하는 계정이 필요하다면, view를 만들어서 제공하라!




*실행계획분석
-옵티마이저가 쿼리 실행시 최적의 실행계획을 수립하는 작업을수행하여 쿼리를 실행
    *옵티마이저 : 데이터베이스 서버에서 두뇌와 같은 역할
        -비용 기반 최적화 방법과 규칙기반 최적화 방법이 있으나, 현재 대부분의 RDBMS는 비용기반최적화방법을 사용
        -비용 기반 최적화는 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계정보를 이용해 각 실행 계획별 비용을 산출한다.. 이렇게 산출된 각 실행 방법별로 최소비용이 소요되는 처리방식을 선택해 최종쿼리를 실행..
            -비용기반 최적화에서 통계정보는 매우중요한역할.. 통계정보가 제대로 반영되어있지않다면 레인지스캔을 해야할게 풀스캔할수도있음..(Mariadb의 기본적으로 통계정보는 레코드건수와 인덱스의 유니크한 값의 개수 정도가 전부)
            -통계관련된 자세한 내용은 Real Maraidb p119참고

        -조인쿼리의 실행 계획 최적화를 위한 옵티마이저 옵션은 두가지가있음
            -Exhaustive 검색
                -테이블 갯수 factorial.. ex) 테이블갯수가 3개이면 3! (3*2*1) 
                -상당히 느림..
            -Greedy 검색
                -optimizer_search_depth의 값에 따라 최적의 조인 순서를 결정
                -optimizer_search_depth가 만약 2로 되어있고, 4개의 테이블을 조인한다면, Exhaustive검색과 같이 모든경우의 수를 나열하는것이아닌, 처음 두 테이블을 가지고 최적의 비용을 찾고 나온 결과를 가지고 다시 테이블을 비교하여 최적의 비용을 찾게된다..
                -Exhaustive 검색보다 확실히 빠르지만, 기본적으로 optimizer_search_depth은 62로 셋팅되어있다. 그렇게된다면 테이블이 62개보다 많지않은이상 Greedy 검색의 장점을 누리지못하게되는데, 그래서 5~8로 셋팅하는것이 좋다한다..(5개 이상의 테이블을 조인하는경우라면)

-실행계획
    -Explain
        -쿼리문장의 특성에 따라 한줄 이상의 결과가 표시
        -쿼리문장에서 사용되 테이블이 표시되고 위에서 아래(id가 작은숫자부터 높은숫자)로 접근한 테이블을 보여줌
        -필요에 따라 실행계획은 산출하기위해 쿼리의 일부분을 직접 실행할때도있음,, 그래서 무거운 쿼리의 경우에는 실행계획의 조회또한 느려질 가능성이있음
        -컬럼구성
            -id 컬럼
                -서브쿼리가 있는 SQL의 경우에는 두개이상의 단위쿼리(쿼리를 쪼갠것)를 볼수있는데, 이때 실행계획에서는 ID가 두개 이상의 값이 나온다
                -여러 테이블을 join할때는 테이블마다 실행계획 레코드가 출력되지만 같은 id값을 가진다
            
            -select_type
                -Select 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼
                -종류
                    -SIMPLE : UNION 이나 서브쿼리를 사용하지않는 단순한 쿼리. 일반적으로 제일 바깥 SELECT 쿼리의 select_type이 SIMPLE로 표시(Join도 SIMPLE로!)
                    -PRIMARY : UNION 이나 서브쿼리를 가지는 SElect 쿼리의 실행계획에서 가장 바깥쪽에 있는 단위 쿼리는 PRIMARY로 표시.. 그래서 하나만 존재..
                    -UNION : FROM절에서 UNION을 여러개 사용하게되면, 첫번째 UNION을 사용한 문장에는 DERIVED로 나타나고 나머지는 UNION으로 표시됨
                        *DERIVED는 UNION된 쿼리결과들을 모아서 저장하는 임시테이블임..
                    -Dependant UNION : where 조건문에 IN 사용했을때, IN안에 UNION을 사용하게되면, 외부쿼리 먼저 실행하고 그 이후에 서브쿼리를 실행한다.. 보통은 서버쿼리가 먼저실행되나, DEPENDANT가 붙었을때는 외부부터 시작하여 생각한대로 인덱스를 타지못하는 경우가 생기니 DEPENDANT 안생기도록 주의할것
                    -UNION RESULT : UNION 결과를담아두는 테이블.. UNION의 결과를 임시테이블로 생성하게되는데, 이 임시테이블을 지칭.. 실제 쿼리의 단위쿼리가 아니기때문에 id값은 없음!
                    -SUBQUERY : FROM절에서 사용하는 서브쿼리는 DERIVED 로 표현되고, 나머지위치에서는 SUBQUERY로 표현!
                        *서브쿼리는 사용하는 위치에 따라 명칭을 다르게부른다!
                            -Nested Query
                                -Select되는 컬럼에 사용된 서브쿼리
                            -Sub Query
                                -Where절에서 사용된 경우
                            -Derived
                                -From 절에 사용된 서브쿼리.. 일반적으로는 RDBMS에서 "인라인 뷰"라고 부른다함
                            
                            *서브쿼리가 반환하는 값의 특성에 따라 다음과 같이 구분
                                -스칼라 서브 쿼리 : 하나의 값만 반환(컬럼이 단 하나인 레코드 1건만)하는 쿼리
                                -로우 서브 쿼리 : 컬럼의 개수에 관계없이 하나의 레코드만 반환하는 쿼리

                    -DEPENDENT SUBQUERY : 바깥쪽(Outer) SELECT 쿼리에서 정의된 컬럼을 사용하는 경우
                    -DERIVED : FROM절에서 SUBQUERY를 만들면 임시테이블을 만들게되어 DERIVED 라고 나타남.. 이전에는 서브쿼리로 만들어진 DERIVED에 대해서 인덱스가 적용이안되었지만 Mariadb5.3 버전부터는 지원가능.. 그러나 되도록 join으로 바꿀수있으면 바꿔라!!!
                    -MATERAILIZED : DERIVED와 유사함.. 임시테이블만든것.. 서브쿼리의 내용을 임시테이블로 구체화(materialization) 한 후, 임시테이블과 테이블을 조인하여 처리하는 형태로 최적화됨.. 
                    -INSERT, UPDATE, DELETE도 모두 지원됨..
            
            -table 칼럼
                -테이블컬럼에 "< xxx >" 이런식으로 둘러쌓여있는게 있는데, 이는 임시테이블을 의미한다. ex) <derived2> 는, id가 2번인 실행계획으로 만들어진 파생테이블을 가리킨다
                -table 컬럼을 보고 순서를 파악할수있다
                    ex) 
                        id     select_type       table    ...
                        1        PRIMARY       <derived2>
                        1        PRIAMRY          e
                        2        DERIVED        dept_emp
                    
                        위와같이 실행계획이 나왔다면, 순서는 아래와같다
                        1) 첫번째 라인의 테이블이 <derived2>라고 적혀있으니, id2 번의 임시테이블(파생테이블)이 먼저 만들어져야함 의미한다.
                        2) 세번째 라인의 id 2는 dept_emp테이블을 가지고 파생테이블(DERIVED)을 생성한다
                        3) 세번째 라인의 분석이 끝났으므로 다시 첫번째 라인으로 돌아감
                        4) 첫번째 라인과 두번째 라인은 같은 id값을 가지고 있는 것으로 봐서 2개의 테이블이 조인됨을 알수있음.. <derived2>테이블이 e 테이블보다 먼저(윗라인) 표시되어있기 때문에 <derived2>가 드라이빙 테이블이 되고, e 테이블이 드리븐 테이블 된다.
                            즉, <derived2> 테이블을 먼저 읽어서 e테이블로 조인을 실행했다@!
                        
            -type 컬럼
                -레코드를 어떤 방식으로 읽었는지 알수있음(풀스캔? 인덱스? 등)
                -하나의 단위 SELECT 쿼리에서 아래 종류중에 하나만 사용하며, index_merge를 제외하고는 반드시 하나의 인덱스만 사용!!
                -종류(아래로 갈수록 느린것)
                    -system : 레코드가 1건만 존재하거나 한건도 존재하지않는 테이블을 차모하는 형태의 접근방법.. MyISAM or MEMORY 일때만 쓰이고 InnoDB나 XtraDB엔진에서는 안쓰인다 (InnoDB로 할경우 index 가 사용)
                    -const : 쿼리의 WHERE 조건절에 PK나 Unique Key 가지고 반드시 1건을 반환하는 쿼리의 처리방식,, 다른 DBMS에서는 이를 "유니크 인덱스 스캔"이라고 표현
                        -만약 PK로 여러 컬럼이 지정되어있을때, 하나의 컬럼으로 조회하게되면 const 안됨! ref로 잡힘(비록 1건만 조회되더라도! 엔진 입장에서는 확실히 알수가없으니!)
                        -Mariadb의 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 통째로 상수화한다는 뜻임
                            explain
                            select count(*)
                            from employees e1
                            where e1.first_name=(SELECT first_name from employees e2 where e2.emp_no=10001);

                            => 결과
                            id    select_type     table     type       ....
                            1     PRIAMRY           e1       ref
                            2     SUBQUERY          e2       const

                            => 해석
                            서브쿼리가 먼저 해석되었는데, 왜 2번으로 나타나는지... 의문......?????????????????????/

                    -eq_ref : 여러테이블이 조인되었을때 나타나게되는데, 처음 테이블이 읽은것을 다음 테이블의 PK or UK의 검색조건에 사용될때 eq_ref가 표시됨.. 즉, 조인에서 두번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이있어야 사용할수있음! 
                    -ref : 인덱스의 종류와 관계없이 동등조건(=) 으로 검색할때는 ref 접근방법이 사용! ex) PK가 두개 이상의 열로 지정되어있을때 하나의 열로만 검색하면 const가 아닌 ref로 나타남
                    *const, eq_ref, ref 모두 동등비교연산자 이어야함!( ex) = , <= , >= ...) 인덱스 분포도만 적절하면 튜닝할 필요없는 상태! 

                    -fulltext : 전문검색 인덱스.. match ~ against ~ 를 사용하게됨.. 텍스트를 어떻게 쪼개서저장하고있는지 구분자를 어떻게 둘것인지를 잘 셋팅하면 TEXT타입으로 데이터가 많이 들어가있을때 검색에 유리
                    -ref_or_null : ref와 접근방식동일한데 null 추가된것임
                    -unique_subquery : IN(subquery) 형태의 쿼리를 위한 접근 방식.. 서브쿼리에서 중복되지않은 유니크한 값만 반환될때 이 접근방법을 사용하나, mysql 5.5(mariadb10.0) 부터는 IN(서브쿼리) 방식을 join으로 접근하도록 개선되어서 unique_subquery와 index_subquery는 보기 쉽지않음!
                    -index_subquery : IN(subquery) 에 중복값이 있을때, 인덱스를 이용해 중복값을 제거하는 접근.. 비용이 크지않지만 중복값을 제거하는 비용이 있긴함.. 위에서 이야기했듯이 개선된 옵티마이저는 이를 join으로 접근해서 보기힘듬
                    -range : 인덱스 레인지 스캔 형태의 접근방법,, 인덱스를 범위로 검색! 이 접근방버보 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 어느정도의 성능은 보장된다할수있다함.. ex) < , > , Between, IN, LIKE, IS NULL 등 
                    *인덱스 레인지 스캔(혹은 레인지스캔)이라하면 const,ref,range 세가지 접근 방법을 모두 묶어서 지칭..

                    -index_merge : 2개 이상의 인덱스를 이용해 각자의 검색결과를 만들어 낸후 그 결과를 병합하는 처리방식.. 생각보다 효율적이지 않다함..(AND와 OR 연산이 복잡하게 연결된 쿼리에서 제대로 최적화 안됨, 여러 인덱스를 읽어야하므로 range방식보다 후질수있음,, 처리된 결과가 두개이상의 집합이될텐데, 이때 교집합이나 합집합 또는 중복제거와 같은 부가적인 작업이 필요..)
                    -index : 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미! 인덱스의 필요한 부분만 읽는 range와는 다르다!!!!! 느려!
                        -그래도 풀테이블스캔보다는 빠를수있음,, 
                            -데이터 파일 전체보다 인덱스가 크기가 작으니깐
                            -인덱스 페이지는 정렬되어있으니께!
                            -select하는 값이 인덱스값이라 굳이 데이터페이지까지 안가도되면.. 
                    -ALL : 인덱스 아예 안탄것.. 이 외에는 모두 index 탄것임
                        -테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거하고 반환..
                        -대량의 디스크 IO를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어들이는 기능이 InnoDB에 있음.. 이를 Read Ahead라함

            -possible_keys 컬럼
                -사용될법한 인덱스들의 목록.. 실제 사용된것이 아님.. 무시해도됨
            
            -key 칼럼
                -여기에 표시되는 인덱스가 실제 사용된 인덱스
                -쿼리 튜닝시 여기에 사용되는 인덱스를 보고 의도했던대로 잘 되었는지 확인할것!
            
            -key_len 컬럼
                -다중 컬럼으로 만들어진 인덱스에서 몇개의 컬럼까지 사용했는지 알수있음.. ex) dept_no(char(4))와 emp_no(INT) 로 인덱스가 잡혀있을경우, dept_no만 사용했다면 key_len이 12로 나타나고 emp_no까지 사용했다면 16으로 적힌다 (INT는 4바이트, mysql의 utf-8은 char가 3바이트씩..)

            -ref 컬럼
                -참조조건(equal 비교조건)으로 어떤 값이 제공됐는지 보여줌
                -상수값지정했따면 ref 컬럼은 const로 표시,, 다른 테이블의 컬럼값이면 그 테이블 명과 컬럼 명이 표시
                -func라고 지정될때가있는데, 이는 사용자가 명시적으로 변환을 했을때(ex. 수식을 넣어준다든가..) 혹은 내부적으로 Mariadb서버가 내부적으로 값을 변환해야할때 나타난다(ex. 숫자타입인데 문자타입으로 넣어줬을때.. 내부적으로 전환하는동작) 
                    -되도록이면 서버가 내부적으로 func 안하도록 해주는게좋음!!
            
            -rows 컬럼
                -통계정보를 참고하여 나타남.. 
                -예측값이라 아주 정확하진 않음..
                -레코드의 예측치가 아니라, 쿼리를 처리하기 위해 얼마 많은 레코드를 디스크로부터 읽고 체크해야하는지를 의미
                -rows가 많다면(실제 테이블의 데이터와 유사하게 나온다면) 테이블풀스캔때릴것이고 아니면, 인덱스 태울것임..
                -
            
            -extra 컬럼
                -종류
                    -using index
                        -커버링 인덱스라고도 부름
                        -인덱스를 사용해서 데이터 페이지까지 굳이 가지않아도 되는 상황,, 즉, 인덱스페이지에 select하려는 데이터가 포함되어있음!(select할때 인덱스 컬럼이 있거나, PK 컬럼이 있을때!! *PK컬럼은 index 리프페이지의 레코드 주소값과 같기때문에 PK컬럼까지는 using index뜬다!)
                    -using index for group-by
                        -group by 처리가 인덱스를 이용할때 쿼리의 실행계획에서 나타남
                        -이를 루스 인덱스 스캔이라고함
                        -인덱스를 순서대로 쭉 읽는것(타이트 인덱스 스캔)이 아님! 필요한 부분만 듬성듬성 읽는것!
                            *타이트 인덱스 스캔 의 예 : count(*), SUM(), AVG() 과 같이 하나도 빠짐없이 필요한것
                            *루스 인덱스 스캔의 예 : MAX, MIN 등
                        -where 절에 인덱스가 포함되어있지않고, group by 절에 인덱스가 포함되어있으면 타이트 인덱스 스캔이 일어남
                        -where 절에 인덱스가 포함되어있고, group by도 해당 인덱스 컬럼으로 조회하면 루스 인덱스 스캔이 일어남
                            -그러나 where절에서 데이터를 걸렀을때 데이터가 많지않으면 그냥 타이트 인덱스 스캔이 일어나고, 데이터가 많으면 루스인덱스 스캔이 일어남..!(옵티마이저가 비용계산해서..)
                    -using temporary
                        -임시테이블이 생성되었다는뜻!
                        -디스크에생성되었는지, 메모리에 생성되엇는지는 알수 없음
                        -이게 extra컬럼에 나타나지않았다고 해서 임시테이블이 생성되지않았다는 뜻은 아님!!
                            *임시테이블이 생성되는경우
                                -FROM절에서 사용된 서브쿼리
                                -COUNT(DISTINCT column)를 포함하는 쿼리도 인덱스를 사용할수 없는 경우에 임시테이블 만들어짐
                                -UNION 이나 UNION ALL이 사용된 쿼리(임시테이블 만들어서 결과병합)
                                -인덱스를 사용하지못하는 정렬작업.. using filesort(꼭 그런건 아님.. 드라이빙테이블의 컬럼값으로 정렬하면 임시테이블 생성안한다함.... 이랫다저랫다..ㅡㅡ)

                    -using where
                        -Mariadb는 내부적으로 크게 Mariadb엔진과 스토리지엔진(Innodb,MyISAM)으로 나뉘는데, 스토리지엔진은 디스크나 메모리 상에서 필요한 레코드를 읽거나 저장하는 역할을 하고, MariaDB엔진은 스토리지 엔진으로부터 받은 레코드를 가공또는 연산하는 작업을 수행한다
                        -이때, MariaDB엔진에서 별도의 가공이나 필터링을 수행하게되면 using where이 extra 컬럼에 나타난다
                        -세부적으로 explain extended의 filtered 컬럼에서 using where이 성능상에 이슈를 주는지 알수있음!!!
                    
                    -using index condition
                        -WHERE 조건절을 가진 쿼리가 실행될때, WHERE 절의 조건이 인덱스를 사용할수 있다면 먼저 인덱스를 읽어서 조건에 부합되는지 여부를 판단하여 필요시 데이터 파일의 레코드를 읽는것!
                        - 예를들어 first name 이라는 컬럼에 인덱스 잡혀져있을때, WHERE first_name like 'LEE%' AND first_name like '%matt' 라고 되어있을떄
                            MariaDB 10.0 이전에는 스토리지 엔진에서 like 'LEE%' 만 확인하여 데이터페이지의 모든 컬럼 데이터를 가져온뒤 MariaDB 엔진에서 %matt에 대한 처리를 해주었다.. 그래서 extra 컬럼에 using where이 적혀있었음
                            그러나 10.0 이후에는 스토리지 엔진에서 LEE% 뿐 아니라 %matt에 대한 처리도 하여 데이터페이지에 필요한 컬럼의 값들을 가져오게되었는데, 그때 extra 컬럼에 using index condition이라고 나타남
                    -rowid-ordered scan, key-ordered scan
                        -어느정도 인덱스를 통해서 읽다가 PK로 정렬해서 데이터를 가져오는것..
                            -클러스터 인덱스는 리프페이지가 데이터페이지므로 범위조건 검색에 PK로 검색하면 데이터페이지 왔다갔다하는 비용을 상당히 줄일수있으니 개이득

    -explain extended
        -filtered 컬럼추가
            -스토리지엔진에서 넘어온 레코드가 Mariadb엔진에서 얼마나 걸러졌는지를 알려줌
            -20이면 Mariadb에 의해서 20%가 남았다는뜻.. 즉, 100개 데이터중에 80개 걸러져서 20개 남았다!
            -단순히 통계정보로 예측된값이라 매우 정확하지않음
        -추가 옵티마이저 정보 알수있음
            -explain extended실행후 SHOW WARNINGS 명령을 날리면 옵티마이저가 분석해서 다시 재조합한쿼리문장을 볼수있음.. 알아보기 어렵기도하지만 쿼리를 어떻게 해석했고 어떤 처리를했는지 알수있으니 유용함!
    -explain partitions
        -partition 컬럼추가
            -어떤 파티션에서 조회해오는지 partition 컬럼에서 확인가능
            -extended와 같이 사용 못함


-쿼리실행절차
    1) 사용자로부터 요청된 SQL문장을 Mariadb가 이해할수있는 수준으로 쪼갠다(파스트리 parse tree)
        -"SQL파서" 라는 모듈이 파스트리를 만들어줌.. 여기서 SQL이 문법적으로 잘못됐다면 걸러줌
        -즉, Mariadb는 SQL문장 그 자체가 아니라, SQL파스트리를 통해서 쿼리를 실행!
    2) SQL의 파싱정보(파스트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
        -최적화 및 실행계획수립단계!,, 옵티마이저에서 처리함! 여기서 실행계획인 만들어짐..

    3) 두번째 단계에서 결정된 것을 토대로 스토리이엔진으로부터 데이터를 가져온다
        *스토리지엔진 : 여기에 InnoDB, MyISAM, Memory.. 등이 있음

    Connection API <-> Connection Handler <-> SQL인터페이스, SQL파서, SQL 옵티마이저, 캐시&버퍼 <-> 스토리지엔진 <-> Disk파일시스템, 데이터 및 로그 파일


-옵티마이저 힌트
    -옵티마이저에게 쿼리의 실행계획을 어떻게 수립해야할지 알려주는것
    -종류
        -STRAIGHT_JOIN
            -select문장 바로 뒤에사용..
            -쿼리에 명시된 테이블대로 join 됨.. 즉 첫번째에 명시된 테이블이 드라이빙테이블
                ex) select STRAIGHT_JOIN 컬럼
                    from A
                        join B
                        join C
                            ON ~~
                    이렇게 되어있다면 조인순서는 (A -> B -> C) 이렇게됨
            -Where 조건에 나오는 값까지 포함해서 그 조건에 만족하는 레코드 건수가 적은 테이블부터 읽도록 하는게좋음(언제나 join 대상 즉, 드리븐 테이블에는 on절의 조건에 맞도록 인덱스 지정필수!)
                -드라이빙 테이블은 보통 인덱스 지정안되어있으면 옵티마이저가 선정함.. 그리고 인덱스 둘다 지정안되어있으면 레코드 갯수 적은것!(여기서도 where 조건이후의 레코드 건수임)
            -MariaDB의 옵티마이저는 STRAIGT_JOIN을 사용하면 앞뒤재지않고 고대로, 아무리 겁나 비효율적이라해도 사용자가 지정한 순서대로 읽으므로 주의할것
        
        -USE INDEX / FORCE INDEX / IGNORE INDEX
            -테이블 뒤에 사용
            -보통은 옵티마이저가 인덱스를 알아서 잘 고르지만, 3~4개 이상의 컬럼을 포함하는 비슷한 인덱스가 여러개있을때는 옵티마이저가 이상하게 지정할때가있음.. 그때는 강제로 특정인덱스 사용하도록 지정해주는게좋음
            -PK 사용하고싶으면 PRIMARY 라고 하면됨
            -USE INDEX, FORCE INDEX : 해당 인덱스를 사용하라고 옵티마이저에게 권하는것.. 보통 옵티마이저가 사용하지만 선택을 반드시 하는것은 아니다(두개의 차이는 옵티마이저에게 권하는 강도의차이인데 크게 차이는 없다함..)
            -IGNORE INDEX : 해당 인덱스는 사용하지말라고하는것,,, 테이블풀스캔 유도할때 사용함
            -용도도 표시해줄수있음(이는 크게 고려하지않아도됨)
                -USE INDEX FOR JOIN : JOIN이라는 키워드는 조인뿐만 아니라 레코드를 검색하기위한 용도까지 포함.. MariaDB는 한건의 레코드도 JOIN이라고 표현되기때문!
                -USE INDEX FOR ORDER BY : ORDER BY에서만 사용할수있도록..
                -USE INDEX FOR GROUP BY : GROUP BY에서만 사용할수있도록..
        
        -SQL_NO_CACHE
            -select 문장 바로 뒤에사용
            -쿼리의 성능을 테스트하는데에 있어서 반드시 필요
                -기본적으로 select하는데 오랜시간 걸렸다하더라도 다시 동일한 쿼리를 실행하면 쿼리캐시에 의해서 빠르게 결과값을 가져온다.. 이를 사용하면 쿼리의 정확한 테스트가 어렵기때문에 이를 사용하여 테스트를 진행하는것이좋다
            -select 문장에서만 사용가능


*count(*)이 빠른것은 건수만 가져오기때문에 실제 데이터를 찾아가기위한 "랜덤 I/O" 가 발생하지않기때문이다

-실행계획 분석시 주의사항
    -select_type 컬럼의 주의사항
        -DERIVED : From 절에 사용된 서브쿼리로부터 발생한 임시 테이블을 의미.. 임시테이블은 메모리에 저장될수도있고 디스크게 저장될수도있는데, 데이터의 크기가 커서 디스크에 저장된다면 성능이 떨어진다..
        -DEPENDENT SUBQUERY : 서브쿼리가 자체적으로 실행되지 못하고, 외부쿼리에서 값을 전달받아 실행되는 경우.. 서브쿼리가 먼저 실행되지못하고 외부쿼리의 결과값에 의존적이기때문에 전체적인 쿼리의 성능을 느리게 만든다...

    -type 컬럼의 주의사항
        -ALL, index : 둘다 전체 레코드를 대상으로 하는 작업방식이라 OLTP환경에서는 해당 실행계획이 보인다면 인덱스를 추가하거나 변경이 필요하다

    -key 컬럼의 주의사항
        -인덱스 사용못할때 아무것도 안보임.. 인덱스 태울수있도록 인덱스만들던, where 조건문 잘 사용할것

    -Rows 컬럼의 주의사항
        -실제 가져오려는 레코드 수보다 훨씬 많은 수가 찍혀있다면 쿼리가 인덱스를 정상적으로 사용하고있는지, 인덱스가 충분히 작업범위를 좁혀 줄수있는 컬럼으로 구성되어있는지 확인해야함!
        -Rows 컬럼은 limit을 고려하지않기때문에 Limit 1로 하였을경우 rows가 1이 아니다!
    -Extra 컬럼의 주의사항
        -쿼리의 실행계획이 좋지않은경우
            -Range checked for each record
            -using filesort
            -using join bufffer
            -using temporary
            -using where (이는 Rows에 나타나있는 값과 실제 select되는 레코드수를 같이 비교해야함)
        -쿼리의 실행계획이 좋은경우
            -Distinct
            -Using index : 커버링 인덱스로 처리되고잇는것! Mariadb에서 제공할수있는 최고의 성능이라함!
            -Using index for group-by

/* select#1 */ select count(0) AS `count(*)` from `employees`.`employees` `e1` 
where `employees`.`e1`.`first_name` = (/* select#2 */ select `employees`.`e2`.`first_name` from `employees`.`employees` `e2` where `employees`.`e2`.`last_name` = 'Matt')


-최적화
    -MariaDB 엔진에서 데이터를 처리하게되면 성능에 미치는 영향력ㅇ디 큰데, 쿼리의 성능을 저하시키는데 한몫하는 경우가 많다.. 스토리지엔진으로 부터 받은 데이터를 MariaDB엔진이 아무런 가공 작업하지않고 사용자에게 전달한다면 최상의 성능을 보장하는 쿼리가 되겠지만, 그렇게 되기가 쉽지않기때문에 최적화에 대해서 잘 공부해두면 더 좋은 쿼리가 나올수잇다!
    -풀테이블 스캔
        -상당히 오래걸리는작업..
        -InnoDB나 XtraDB는 리드 어헤드(Read Ahead) 라는 작업을 통해서 버퍼 풀에다가 데이터를 가져다 놓는다.. 이를 통해 상대적으로 테이블 풀스캔에 대해 빠른 성능을 보장한다..
        -innodb_read_ahead_threshold 를 사용해서 얼마나 더 자주 리드 어헤드를 할지 설정할수있음
    
    -ORDER BY(using filesort)
        -인덱스를 사용하지않고 정렬을 수행해야할때 사용.. 인덱스를 사용하는게 당연빠르나, 레코드가 많지않으면 메모리에서 filesort가 처리되므로 충분히 빠름!
        -언제 나타나나?
            -정렬 기준 너무 많아서 요건별로 모두 엑세스를 생성하는것이 불가..(무슨말..?)
            -GROUP BY의 결과 또는 DISTINCT와 같은 처리의 결과를 정렬해야하는 경우
            -UNION의 결과와 같이 임시테이블의 결과를 다시 정렬해야하는경우
            -랜덤하게 결과레코드를 가져와야하는경우(이건언제..?)
        -소트 버퍼를 통해서 정렬을 수행하게되는데, 데이터가 소트버퍼의 크기보다 클때는, 디스크에 임시로 저장해놨다가 정렬을 수행한다.. 그래서 느려진다.. 그러나 소트버퍼의 값을 한없이 늘린다고 좋은게아니다.. 세션별로 생성이 되기때문에 너무많이늘리면 OS의 메모리 부족현상이 나고 OS는 가장 점유를 많이하고있는 프로세스를 kill하기때문에 DB가 뻗을수있다..
        -SELECT시 *을 사용하여 모든 컬럼을 가져오는것은 정렬버퍼의 입장에서 결코 좋지않은 영향을 미친다.. 왜냐하면 가져오는 데이터의 크기가 커질수록 정렬하는데에는 부담이 가게되기때문!
        -정렬처리 방식
            -인덱스를 사용한 정렬
                -조인과 함께 사용될때, 클러스터 인덱스 컬럼을 가지고 WHERE 조건문에서 검색하고, ORDER BY도 해당 컬럼으로 진행한다면, 정렬이 이미 되어있기때문에 별도의 정렬이 필요없다.. 그러니 겁나 빠를것이다..
            
            -드라이빙 테이블만 정렬(조인이 없는 경우 포함) : extra 컬럼에 "Using filesort" 가 표시
                -인덱스가 없다면 이게 효과적!!
                -인덱스가 없는 컬럼을 정렬해야하는 경우 드라이빙 테이블의 컬럼으로 정렬을 하는게 좋다..
                -드라이빙 테이블을 인덱스 없는 컬럼으로 sort한 뒤(sort buffer에서 수행) 조인 수행
                -정렬이 이루어진 이후에 조인하기때문에 밑에보다 상대적으로 더 적은 레코드를 정렬! 좀더 빠름!

            -조인결과를 임시테이블로 저장한 후, 임시테이블에서 정렬 : extra 컬럼에 "Using temporary; Using filesort"가 같이 표시..
                -드리븐 테이블의 컬럼으로 ORDER BY를 한경우..
                -이는 조인한 결과값을 가지고 임시테이블을 만든뒤 sort하여 결과데이터를 전달한다..
                -정렬해야할 레코드가 제일 많기 때문에 느리다!!!
        
            -JDBC 같은 경우, MariaDB에서 스트리밍방식으로 주나, 버퍼를 채워서 요청에 반환하기때문에 느리다함.. 스트리밍방식도 있다고하는데.. 디스크에서 데이터를 조회해오는데 시간이 많이걸릴듯한데.. 이게 많은 차이가있을지..?(확인필요..)

            -퀵소트 알고리즘 알아볼것!
            -ORDER BY .. LIMIT n 최적화
                -ORDER BY절을 가진 쿼리가 인덱스를 사용하지 못할때, 서버에서 실시간 정렬(Using filesort)을 수행해야한다. 소트버퍼에서 퀵 소트 알고리즘을 수행함.. 만약 이때, 레코드가 너무 많으면 계속 소팅하고 병합하는 작업이 이어진다.. 이는 CPU와 디스크에 많은부담!
                -이에 MYSQL은 소트버퍼의 크기보다 작은 경우에 우선순위 큐를 만들고 그 큐를 이용해서 정렬을 수행.. 이렇게 우선순위 큐를 이용하면 퀵 소트 알고리즘으로 900건의 결과를 모두 정렬할 필요가 없으며 단순히 employees 테이블의 레코드를 하나씩 읽어서 우선순위 큐에만 넣어주면된다.. 
                즉, 소트 버퍼의 크기가 256KB이므로 조회한 데이터가 이보다작으면 그냥 큐에넣고 sort해서 빠르게 결과값 가져간다는것!

