- 인덱스
  - 인덱스 사용목적
    - 랜덤IO를 줄여주기위함! (이를 통한 빠른검색)
  ---
      - 기본적으로 디스크에 쓰는 작업은 느리다. 그러나 SSD와 같은 저장매체를 통해서 기존 HDD보다 약 1000배 빠른 성능을 낼수있다
      - 디스크에 데이터를 쓰기 위해서는 디스크 헤더를 움직여서 쓸 위치에 정하는 작업이 이루어진다. 순차 I/O와 같은 경우는 캐시를 활용해서 여러 요청을 한번에 디스크에 쓸수 있다. 그러나 랜덤 I/O와 같은 경우는 한번에 캐시로 모아서 쓰지못하고 요청할때마다 헤더의 위치를 찾아주는 작업이 이루어진다. 랜더I/O를 순차I/O로 변경하도록 해주는 방법은 많지않다. 그래서 쿼리 튜닝의 목적은 랜덤 I/O 자체를 줄여주는것이다! 
      - SSD로 랜덤I/O가 일어난다면 HDD보다 훨씬빠름! 순차I/O는 큰 차이없음
  ---
  - 인덱스 또한 디스크에서 읽어와야한다.. 그래도 인덱스같은경우 읽어오게되면 버퍼풀에 남아있게되고, 버퍼풀과 change버퍼를 통해서 인덱스의 변경이 일어나도 계속해서 최신의 인덱스를 유지한다. 그때에, 인덱스 외의 데이터를 조회하려면 당연히 버퍼풀에는 있지않을것이고, 이를 위해서 디스크로 접근하여 랜덤IO가 일어나게된다! (클러스터링 인덱스(PK)는 데이터페이지가 리프노드이기 때문에, 디스크 접근 안할수도있겟다.. 확인해보니 데이터 insert하고 나서 select할때 Innodb_buffer_pool_reads 변수의 값이 증가되지않는것으로 보았을때, 디스크를 읽지않고 버퍼풀에 저장된 클러스터링 인덱스의 리프노드로 접근하는듯함.. 물론 버퍼풀이 가득차면 다른이야기일듯..?)
    - Innodb_buffer_pool_reads : 버퍼풀에 데이터가 없어서 디스크에서 직접 읽은 논리적 수
    - Innodb_buffer_pool_read_requests : 버퍼풀에서 논리적인 읽기 요청 횟수
    - innodb buffer pool hit ratio = Innodb_buffer_pool_read_requests / (Innodb_buffer_pool_read_requests + Innodb_buffer_pool_reads)
    - innodb buffer pool hit ratio 값이 낮으면 디스크에 대한 접근이 많다는 이야기므로 버퍼풀사이즈를 늘려야한다!!

  - 인덱스는 key value 형태로 구성되어있다
    - key는 컬럼의 값, value는 주소
      - value의 주소는 데이터주소(PK값)가 될수있고, 또 다른 인덱스 페이지의 주소(자식노드)가 될수있다.
      - 데이터주소(PK값) 이라고 한것은, MySQL(Innodb)에서 실제 데이터들은 인덱스페이지(엄밀히는 리프노드)가 곧 데이터 페이지인 클러스터 인덱스인 PK를 통해서 데이터를 가져오기때문!
    - ~~(key는 컬럼(들)의 값, value는 리프노드일때는 해당컬럼의 데이터페이지주소를, 브런치|루트 노드일때는 해당컬럼의 인덱스페이지(자식노드) 주소)~~
  - 인덱스는 정렬이 된 상태로 저장되고, 데이터파일을 그냥 들어오는 순서대로 저장된다(클러스터드 인덱스는 데이터파일이 정렬이되서 저장됨). 여기서 중간에 데이터를 삭제한다면, 빈 공간에 데이터를 insert 하기때문에 반드시 순서대로 저장되는것은 아님!
  - 데이터의 저장성능(Insert, update, delete)을 희생하고 그 대신 읽기 속도를 높이는것!

  - 인덱스 알고리즘 종류
    - B-Tree 인덱스
      - 루트, 브랜치(루트나 리프가 아니면 모두 브랜치), 리프노드로 구성
      - 변형되지않은 key값
      - 루트가 리프랑 같지않으면, 루트나 브랜치노드에서는 value가 페이지번호로 구성
      - 리프노드는 데이터페이지를 가리킴(MyISAM, Memory 스토리지엔진은 맞음. 그러나, innodb는 클러스터인덱스(ex. PK)에서 리프노드가 데이터페이지이고, 다른 보조인덱스는 리프노드에 PK가 있음)
        - 그래서 데이터페이지를 통해서 데이터를 읽어오려면 랜덤I/O가 발생하는것! 레코드 한건마다 데이터페이지로가서 데이터를 가져와야함!
      - 인덱스의 레코드는 정렬되어있으나, 데이터의 레코드는 정렬이 되어있지않음
      - 인덱스키를 추가, 삭제 할 경우에는 split 이라는 노드를 분리하는 상황이 올때 많은 작업을 필요로 한다.(페이지에 데이터가 많아지면 split이 일어나겟지..) 왜냐하면 디스크로부터 데이터를 읽고 쓰는 상황들이 생겨나기때문이다. 이때, InnoDB는 일시적으로 changeBuffer에 기록하고 바로 응답을 해준다. (만약, split 할 필요 없으면 버퍼풀에 인덱스 추가하고 바로 응답함.) 그리고 changeBuffer는 백그라운드로 때에 맞추어 디스크 인덱스 파일에 머지시킨다.. 삭제도 이런방법과 동일!
        - 인덱스 생성과정(B-TREE)
          1. 해당 인덱스 컬럼의 값이 어디에 들어가면 좋을지 ***검색***
          2. 레코드 주소값과 더불어 인덱스에 해당 컬럼값 ***저장*** (리프노드에 저장할 곳이 있을때.. 없으면 split 일어남!)
        - 인덱스 삭제시에는 해당 인덱스를 삭제한다는 마킹작업을 필요로함.. 이 마킹작업을 하기위해서 디스크에 IO가 필요.. 그러나 이때도 changeBuffer가 동일하게 작업함. 그래서 느리지않음
        - Secondary Index의 insert,delete,update 작업을위한 buffer가 ChangeBuffer
        - *변경작업에 해당하는 page가 buffer pool에 존재하지 않을때만 change buffer에 변경한다고함(http://minsql.com/mysql/mysql-innodb-architecture-change-buffer/)
          - 결국 위의 상황도 해당하는거.. split은 새로운 page를 만드는거니깐.. 버퍼풀에 없을것이고 그러니깐 changeBuffer에 일단 저장해놓겟네.. 
      - 인덱스키를 수정할때는 해당 인덱스를 삭제하고 추가하는것!
      - 100%일치 또는 앞부분(like '~%') 검색시 사용가능하나 인덱스키에 변형이 있으면 사용불가!
      - InnoDB는 넥스트키 락과 같은경우 인덱스를 잠근후, 레코드를 잠그기때문에 인덱스를 어떻게 설정하는지가 매우 중요함!
      - 영향을 미치는 요소들
        - 인덱스 키 값의 크기
        - B-Tree 깊이
        - 선택도(기수성)
        - 읽어야하는 레코드 건수(보통 전체 레코드의 1/4정도로 인덱스가 못거르면 풀스캔으로 간다함..)
      - B-Tree 인덱스를 통한 데이터 읽기
        - 인덱스에서 순서대로 데이터를 읽어오는데, 데이터를 한건 읽어올때마다 랜덤IO 발생!
          - 만약 인덱스를 통해서 3건만 검색이 되었다면, 3건에 대한 데이터의 랜덤IO가 총 3번 발생!! 
        - 인덱스 레인지 스캔
          - const, ref, range
        - 인덱스 풀 스캔
          - 인덱스의 처음부터 끝까지 모두 읽는 방식!
            - 예를들어, A,B,C 컬럼순서로 인덱스가 생성되어있는데, 검색조건에 B or C만 줄때..
          - 만약 커버링 인덱스의 상태라면 테이블 풀 스캔보다는 효율적이다
          - 인덱스 리프노드의 맨앞 또는 맨끝으로 가서 쭉 스캔.. 리프노드에서 리프와 리프 사이를 연결하는 구조는 linkedList로 되어있음!
        - 루스 인덱스 스캔
          - 느슨하게, 듬성듬성 인덱스를 읽는것!
          - 인덱스 레인지스캔이나 인덱스 풀스캔은 타이트 인덱스 스캔에 속한다.
          - GROUP BY 에서 MAX나 MIN 함수에 대한 최적화이다!
      - 다중컬럼 인덱스
        - 뒤에 있는 컬럼은 앞에있는 컬럼에 의존하여 정렬한다! 아무리 뒤에 있는 컬럼의 데이터가 테이블의 가장 처음의 값이라할지라도, 앞에 있는 컬럼의 데이터에 의해서 결정되게된다!(즉, 앞에잇는 컬럼의 데이터가 맨 마지막데이터를 의존한다면 거의 마지막에 셋팅되어잇을것이다..)
      - B-Tree 인덱스의 정렬 및 스캔방향
        - mysql 8 부터는 혼합정렬 가능(근데 제약조건이 따랐던거같음.. 이는 찾아봐야함)
          - ex) CREATE INDEX ix_01 ON table(col1 ASC, col2 DESC)
        - 기본값을 오름차순으로 정렬되어잇음
        - 인덱스의 스캔방향은 정순(오름차순), 역순(내림차순) 으로 모두 가능. 즉, MySQL의 옵티마이저가 정순으로 읽을지, 역순으로 읽을지 결정한다!
      - B-Tree 인덱스를 효율적으로 사용하는방법
        - 작업범위 결정조건을 많이 사용할수록 효율적! 체크조건은 많다고해서 성능을 높이지못한다! (확실하게 이해가 안갔으니,, p228 참고할것!)
        - **작업범위 결정조건**은 불러오는 레코드를 줄일수 있으나, **체크조건**은 MySQL엔진에서 데이터를 이미 다 가져온것을 걸러주는것만 하기때문에 성능에 큰 영향을 미치지못한다!!!
        - 작업 범위 결정조건으로 사용못하는 놈들(체크조건으로 가능할수도)
          - NOT-EQUAL로 비교된 경우 (<>, NOT IN, NOT BETWEEEN, IS NOT NULL)
          - LIKE '%??'
          - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형되서 비교했을때
          - 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변ㅅ환해야 비교가 가능한경우)
          - 문자열 데이터 타입의 콜레이션이 다를경우
        - *Where column IS NOT NULL 은 작업 범위 결정조건임!(Null값도 인덱스로 관리됨)
        - *크다 작다 비교후에 동등비교(=) 는 체크조건임!(작업범위 결정조건으로만 활용할수없음!!)
        - like 비교는 크다 또는 작다 비교와 동급으로 생각하면될듯!
         
    - Hash 인덱스
      - 해시알고리즘을 통해서 key값이 변경되어 버켓에 저장되기때문에 동등비교검색만 사용가능하다!(범위, like 이런거 안댐!)
        - 또한 그래서 key값이 작고 검색이 빠르다.. 
        - 트리구조가 아니기때문에 키값이 포함된 버킷을 찾아서 빠르게 데이터 파일로 접근할수있음
      - 메모리기반의 테이블에 주로 구현,,디스크 기반의 대용량 테이블용도로는 사용하지않는다!
      - 해시 함수 결과가 넓으면 즉, 버킷이 많이 생성되면 될수록 메모리 차지하는것은 커지나, 해시 충돌이 일어나지않기때문에 상당히 빠르고 효율적이게 검색이 가능하다. 그러나, 해시함수 결과가 좁으면 즉, 버킷이 적게 생성될수록 메모리 차지하는것은 작아지나, 해시 충돌이 일어나기때문에 필터링 과정이 필요하고 이는 자연스레 성능저하를 가져온다!
      - InnoDB는 지원x, MEMORY 스토리지엔진과 NDB클러스터는 지원함
    - R-Tree
      - 공간 인덱스
    - Fractal-Tree 인덱스
      - 디스크의 랜덤I/O를 줄이기위해 순차 I/O로 변환해서 처리한다!!
      - 이를 스트리밍 B-Tree 라고도 부름
    - 전문검색 인덱스

  - 클러스터링 인덱스
    - 클러스터키가 선택되는 우선순위
      1. Primary key
      2. not null + unique index
      3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 ***내부적***으로 생성하여 선택(사용자가 사용못함)
    - PK에 적용되어있음
      - PK 적용되어있지않으면 아래의 순위대로 클러스터키 선택
        1. NOT NULL + UNIQUE INDEX 중에서 첫번째 인덱스를 클러스터 키로 선택
        2. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터 키로 선택 
             - PK나 UK 없으면 InnoDB테이블에서는 아무런 의미없는 숫자값으로 클러스터링 되고있게됨.. 이는 내부적인것으로 외부에서 확인도 불가하기때문에 그냥 직접 만들어서 명시하는게 좋음..    
             - If the table has no PRIMARY KEY or suitable UNIQUE index, InnoDB internally generates a hidden clustered index named GEN_CLUST_INDEX on a synthetic column containing row ID values. The rows are ordered by the ID that InnoDB assigns to the rows in such a table. The row ID is a 6-byte field that increases monotonically as new rows are inserted. Thus, the rows ordered by the row ID are physically in insertion order. (https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html)

    - 레코드의 저장위치가 프라이머리 키값에 의해 결정 => 데이터페이지가 정렬되어있음
    - 리프노드=데이터페이지
    - 범위검색에 매우 빠름
    - 클러스터 인덱스의 단점
      - 클러스터 키값이 클수록 인덱스 페이지의 크기 증가
      - 보조 인덱스를 검색할때 PK로 다시한번 검색해야하므로 처리 성능이 조금 느림
      - INSERT할때 데이터의 저장위치를 결정해줘야하니깐 처리성능이 느림
      - PK변경시 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 느림
    - 보조 인덱스
      - InnoDB의 보조 인덱스의 리프노드에는 PK를 가리킴
        - MyISAN은 데이터의 주소값을 가리킴
    - 클러스터 테이블 사용시 주의사항 
      - 클러스터 인덱스 키의 크기
      - 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 컬럼으로 생성하자!
      - PK는 반드시 명시하라! => 어차피 안쓰면 내부적으로 Auto_increment 생성한다..
      - 그냥 PK가 길어진다면 PK걍쓰는것도 좋은데, 보조인덱스도 필요한경우라면 AUTO_INCREMENT를 PK로 잡고 긴거는 인덱스로 써라!(보조 인덱스는 PK를가지고 인덱스 페이지를 구성하게되니깐 PK 너무 길어지면 안좋겟지?!)
  - 유니크 인덱스
    - 유일값!
    - null 저장가능, 여러개 저장가능(null은 값이 아니다!)  
    - 보조 인덱스와의 성능비교
      - 유니크 인덱스와 보조인덱스는 내부적으로 같은 구조로 돌아간다.. 다만, 보조 인덱스로 검색을하게되면 상대적으로 레코드가 많이 검색이 되기때문에 유니크 인덱스보다 느리다고 느껴지는것뿐이다. 그냥 레코드를 많이 검색하면 그만큼 랜덤 I/O가 생기니깐 느려진것이지 유니크인덱스가 뭔가 특별해서는 아니다
      - 또한, 데이터를 insert할때 유니크인덱스와같은경우 중복을 확인해야하기 때문에, s-lock을 잡게된다.. 그런데 이게 데드락 유발을 많이시키고 당연히 insert할때 시간도 많이 잡는다.. 되도록이면 유니크 인덱스는 사용을 자제하자..!!
  - 외래키
    - 자식 테이블에 데이터를 insert할때 부모 테이블에 참조하는 값이 있는지 확인하는 과정을 거치는데, 이때 읽기잠금을 건다.. 이는, 다른 쿼리 실행에 많은 영향을 미치기때문에 되도록이면 안쓰는게 좋다!
  - 기타 주의사항
    - 통계정보를 가지고 실행계획을 수립하는데, 정상적으로 통계가 현재레코들르 반영하고있지않다면 인덱스를 제대로 타지못할수있다! Analyze 명령을 통해서 통계정보를 다시 수립하도록!!(cardinality 컬럼이 특히 중요!)

  
  - 그림이랑 정리 잘되어있는 사이트 : https://12bme.tistory.com/138




