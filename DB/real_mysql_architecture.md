# real_mysql_architecture

- MySQL 서버 = MySQL 엔진 + 스토리지 엔진
  - MySQL 엔진 (두뇌역할)
    - 커넥션핸들러 : 클라이언트의 접속 및 쿼리요청을 처리
    - SQL파서 
      - 사용자 요청으로 들어온 쿼리 문장을 분리해 트리 형태의 구조로 만들어 내는 작업을 진행
      - 쿼리 문장의 기본오류를 여기서 걸러넴
    - 전처리기
    - 옵티마이저 : 쿼리의 최적화 실행을 위함 
  - 스토리지 엔진(손 역할 - 핸들러로 부르기도함)
    - 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어옴
    - InnoDB로 테이블을 지정하면 InnoDB 스토리지엔진이 해당 테이블의 select, update, delete, insert 등의 작업을 담당한다
  - MySQL엔진과 스토리지엔진은 ***핸들러 API***를 통해서 데이터를 주고받는다!
    ```sql
    -- 핸들러 API를 통해서 얼마나 많은 데이터 작업이 있었는지 확인가능
    SHOW GLOBAL STATUS LIKE 'Handelr%' 
    ```
---
- MySQL 스레딩 구조
  - 포어그라운드 스레드(클라이언트 스레드)
    - MySQL 서버에 접속한 클라이언트 수만큼 존재.
    - 주로 각 클라이언트 사용자가 요청하는 쿼리문장을 처리함
    - 데이터를 MySQL의 데이터버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우네느 직접 디스크의 데이터나 인덱스파일로부터 데이터를 읽어와서 작업을 처리
    - 디스크의 쓰기 요청의 경우에 InnoDB는 백그라운드에서 실행하며, MyISAM은 포어그라운드에서 직접 쓰기까지 처리
      - 포어그라운드는 주로 읽기에서 사용된다고 보면됨

  - 백그라운드 스레드(MyISAM는 거의해당사항없음)
    - 스레드 종류
      - ChangeBuffer를 병합하는스레드
        - 인덱스 관련!("real_mysql_index" 참고)
          - 인덱스 추가, 삭제, 변경시 ChangeBuffer라는 곳에 임시로 저장해놓고 이를 병합함.. (이게 없으면 인덱스 페이지 고치는데 시간이 많이걸릴때 노답..)
      - 로그를 디스크로 기록하는 스레드
      - InnoDB버퍼풀의 데이터를 디스크에 기록하는 스레드
        - 그래서 데이터 처음 Insert하면 버퍼에 기록되고끝나지, 디스크에 기록될때까지 기다리지않음
      - 데이터를 버퍼로 읽어들어들이는 스레드      
      - 잠금이나 데드락을 모니터링하는 스레드
      - 이 모든 스레드를 총괄하는 메인스레드
  - InnoDB에는 쓰기작업 버퍼링 가능, 일괄처리 o
  - MyISAM은 쓰기작업 버퍼링 기능x, 디스크에 저장될떄까지 기다림.
---
- 메모리 할당 및 사용구조
  - 글로벌 메모리영역 : 클라이언트 수와 무관하게 하나의 메모리 공간에 할당
    - 키 캐시(MyISAM)
    - 버퍼풀(InnoDB)
    - 쿼리캐시
    - 바이너리 로그파일
    - 로그 버퍼
    - 테이블 캐시
  - 로컬(세션) 메모리 영역 : 클라이언트 스레드가 사용하는 메모리영역
    - 커넥션 버퍼
    - Result 버퍼
    - Read 버퍼
    - 조인 버퍼
    - 랜덤 Read 버퍼
    - 정렬(Sort) 버퍼
---
- 쿼리 실행 구조
  1. 파서
    - 사용자 요청으로 들어온 쿼리 문장을 분리해 트리 형태의 구조로 만들어 내는 작업을 진행
    - 쿼리 문장의 기본오류를 여기서 걸러넴
  2. 전처리기
    - 파서 트리를 기반으로 쿼리문장에 구조적인 문제점있는지 확인.
    - 권한없으면 여기서 거른다함..
  3. 옵티마이저
    - 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당(두뇌)
  4. 실행엔진
    - 옵티마이저를 통해서 처리된 내용을 가지고 핸들러에게 요청하는 역할
    - 옵티마이저가 회사의 경영진이라면, 실행엔진은 중간관리자, 핸들러는 실무자라고 할수있음
    - 실행엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할
  5. 핸들러(스토리지 엔진)
    - MySQL 서버의 가장 밑단에서 MySQL 실행엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당.
    - InnoDB 테이블을 조작하는 경우에 핸들러는 Innodb 스토리지 엔진이됨
--- 
- 복제
  - 마스터
    - 데이터의 조작 및 변경이 일어나면(select같은건 노노), 바이너리 로그로 기록
    - 슬레이브 서버에서 변경내역을 요청하면 바이너리 로그를 읽어 슬레이브로 넘김(바이너리 로그 덤프 스레드)
  - 슬레이브
    - 슬레이브 서버의 IO 스레드가 마스터 서버에 접속해 변경 내역을 요청하고 받아온 변경 내역을 릴레이 로그에 기록
    - 슬레이버 서버의 SQL 스레드가 릴레이 로그에 기록된 내역을 재실행함으로써 슬레이브데이터를 마스터와 동일하게 셋팅하게되는것임
---
- 쿼리 캐시
  - 쿼리 캐시의 구조는 간단히 Map과 같은(키, 값) 데이터 구조로 구현
  - 쿼리의 결과 값을 값에 저장
  - 쿼리 캐시 관련 내용 
    - 동일한 쿼리내용에 대해서 결과 데이터를 저장해놓고 반환
    - 그러나, 해당 테이블에 변화가일어나면 쿼리 캐시를 비우는 작업이 일어나게되고, 쿼리캐시는 모든 세션이 공유되기때문에 비우는 동안에 글로벌 락이 걸림. 그로인해 접근하는 다른 세션의 쿼리는 대기..
    - 그렇기때문에 자주 변경이 일어나는 테이블은 비추.. 자주변경이 없는 테이블에서는 추천
    - 쿼리캐시 관련 참고사이트
      - https://jupiny.com/2021/01/10/mysql-query-cache-disadvantage/
      - http://jason-heo.github.io/mysql/2014/08/19/reset-query-cache.html#:~:text=Query%20Cache%20%ED%81%B4%20%EB%95%8C%EC%9D%98%20%EB%8B%A8%EC%A0%90&text=Global%20Lock%20%EB%AC%B8%EC%A0%9C%EB%A1%9C%201,%ED%81%B0%20%EA%B2%BD%EC%9A%B0%20%EB%8D%94%20%EC%98%A4%EB%9E%98%20%EA%B1%B8%EB%A6%B0%EB%8B%A4.
    - 8점대 버전에서는 없어짐
  
---
- InnoDB
  - InnoDB 스토리지 엔진 아키텍처
    - 레코드 기반잠금! => 동시성 처리 가능!
    - InnoDB 스토리지 엔진의 특성
      - 프라이버리 키에 의한 클러스터링
        - 오라클의 IOT(Index Organized Table)와 동일한 구조가 InnoDB에서는 일반적인 테이블의 구조
      - 잠금이 필요없는 일관된 읽기
        - MVCC(Multi Version Concurrency Control) 라는 기술을 이용해 락을 걸지않고 읽기를 수행!
          - Serializable 격리수준은 제외
      - 외래키 지원
        - 데드락 자주발생할수있으니 사용비추
      - 자동 데드락 감지
        - 감지된 데드락은 관련 트랜잭션 중에서 ROLLBACK이 가장 용이한 트랜잭션(ROLLBACK 했을때 복구 작업이 가장 작은 트랜젝션)을 강제 종료
      - 자동화된 장애복구
        - 손실이나 장애로부터 데이터를 보호하기 위해 여러가지 메커니즘 탑재(자세한건 990쪽 참고)
      - 오라클의 아키텍처 적용(이는 잘모르겠음..)
        - MVCC, 언두 데이터가 시스템 테이블 스페이스에 관리, 테이블 스페이스 개념 등..

  - InnoDB 버퍼 풀(메모리)
    - 디스크의 데이터 및 인덱스 정보를 메모리에 캐시
    - 쓰기 일괄처리를 위한 버퍼 역할도 함 => 그로인해 디스크에 아직 반영되지않은 "더티페이지"가 있게되고, 이를 특정 이벤트에 맞추어 디스크에 write 함 (모든 더티페이지를 write하는것은 또 아니고, 필요한 만큼만!)
      - 여기서 write하는곳은 테이블 스페이스이다.. 리두로그가 저장되는곳이랑은 다름!
  - 언두(UNDO) 로그(메모리)
    - 변경되기 전의 데이터를 보관
    - 목적
      - 트랜잭션 롤백대비
        - 예를들어 update로 특정 데이터를 변경했다면, ***커밋이 이루어지는것과 상관없이*** 무조건 데이터 파일(데이터/인덱스 버퍼)는 변경이 이루어진다. 그때 롤백을 하게되면 언두로그를 통해 이전 데이터를 가져오게되는것..
      - 트랜잭션의 격리수준을 유지하면서 높은 동시성제공
        - READ-COMMITED에서 특정 데이터의 COMMIT이 이루어지기 전에 그 전의 데이터만 보여질수있는것도 언두로그가있기떄문
        - REPEATABLE-READ 수준에서도 특정 트랜잭션에 계속해서 다른 트랜잭션에서 변경이일어나도 계속해서 동일한 데이터만 select 할수있는것도 언두로그와 트랜잭션 아이디를 활용해서 동일한 데이터를 가져오는것임
    - "잠금 없는 일관된 읽기" 또한 언두로그를 통해서 가능
      - 오랜시간동안 활성상태인 트랜잭션으로인해 언두로그의 적절한 삭제가 이루어지지않으면, MySQL 서버가 느려질수있으니 커밋이나 롤백을 통해서 빠르게 트랜잭션을 완료할것!
      - 커밋이 된다고 언두영역의 백업데이터가 항상 바로 삭제되는것은 아니고, 언두영역을 필요로하는 트랜잭션이 더 없을때 비로소 삭제!
  - ChangeBuffer(메모리)
    - 인덱스 변경이 일어날때, 디스크에 직접 쓰는것이 아닌, 임시 공간에 저장. 이 임시공간이 ChangeBuffer. 적당한때에 버퍼풀에 병합
    - [mysql 공식 사이트에서 changeBuffer관련 해석](http://minsql.com/mysql/mysql-innodb-architecture-change-buffer/)
  - 리두(REDO) 로그 및 로그버퍼 (ib_logfile0,ib_logfile1 ...)
    - 버퍼풀 만으로 ACID 보장이 어려우므로 이를 보장하기 위해 따로 변경된 내용을 순차적으로 디스크에 저장하는데, 이를 리두로그(로그)라고 함.
      - ACID는 DB에서 ***트랜잭션의 무결성***을 보장하기위한 4가지요소
        - A(Atomic) : 트랜잭션은 원자성 작업이어야함..(쪼갤수없는!)
        - C(Consistent) : 일관성
        - I(Isolated) : 격리성
        - D(Durable) : 한번 저장된 데이터는 지속적으로 유지되어야함
        - 일관성과 격리성은 서로다른 두개의 트랜잭션에서 동일 데이터를 조회하고 변경하는 경우에 상호 간섭이 없어야함을 의미!
    - 이 리두로그에 write하기위한 버퍼가 리두로그 버퍼(일괄처리를 위해)
  - MVCC(Multi Version Concurrency Control)
    - 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는기능
    - MVCC의 가장 큰 목적은 잠금을 사용하지않는 일관된 읽기를 제공하는데 잇음
    - 언두로그를 사용
    - 하나의 레코드에 대해 2개의 버전(multi version)이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러가지 상황에 따라 달라지는(Cocurreny control)구조
      - 레코드 하나를 변경했을경우, 변경한 레코드는 버퍼풀에 기록되고, 이전 데이터는 언두로그에 기록된다(하나의 레코드에 대해 2개의 버전-multi version)
      - 격리수준에 따라 해당 트랜잭션에 언두로그의 데이터를 보여줄수도있고, 버퍼풀에 기록된 데이터를 보여줄수도있다(상황에 따라 데이터 컨트롤을 다르게 - Cocurreny control)